---
layout: post
title: "浏览器的工作原理摘要"
description: ""
category: 
tags: [浏览器]
---

原文地址：[http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/](http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)

浏览器的高层结构：

1. 用户界面
2. 浏览器引擎
3. 呈现引擎
4. 网络
5. 用户界面后端
6. JavaScript解析器
7. 数据存储

默认情况下，呈现引擎可以显示HTML和XML文档和图片。通过插件（或浏览器扩展程序）还可以显示其他类型的内容。

呈现引擎的主流程：

1. 解析HTML文档，并将各标记逐个转化成“内容树”上的DOM节点
2. 解析外部CSS文件以及样式元素中的样式数据，创建呈现树
3. 布局：为每个节点分配一个应出现在屏幕上的确切坐标
4. 绘制：呈现引擎遍历呈现树，由用户界面后端将每个节点绘制出来

为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上，它不必等到整个HTML文档解析完毕之后，就开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。

解析文档是将文档转化成为有意义的结构，解析器通常将解析工作分给以下两个组件来处理：

1. 词法分析器，负责将输入内容分解成一个个有效标记
2. 解析器，负责根据语言的语法规则分析文档的结构，从而构建解析树

所有常规的解析器都不适用于HTML，原因是HTML的处理更为“宽容”，它允许你省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。

影响：

1. 这是HTML如此流行的原因：它能包容你的错误，简化网络开发
2. 这使得它很难编写正式的语法，HTML无法很容易地通过常规解析器解析

解析器的输出“解析树”是由DOM元素和属性节点构成的树结构。DOM是文档对象模型的缩写，它是HTML文档的对象表示，也是外部内容与HTML元素之间的接口。

HTML无法使用常规的自上而下或自下而上的解析器进行解析，原因在于：

1. 语言的宽容本质
2. 浏览器历来对一些常见的无效HTML用法采取包容态度
3. 解析过程需要不断地反复，在HTML中，如果脚本标记包含`document.write`，就会添加额外的标记，这样解析过程上就更改了输入内容

[HTML5规范详细地描述了解析算法](http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html)。此算法由两个阶段组成：标记化和树构建。

标记化是词法分析过程，将输入内容解析成多个标记。HTML标记包括起始标记、结束标记、属性名称和属性值。

标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记。如此反复直到输入结束。

在创建解析器的同事，也会创建`Document`对象。在树构建阶段，以`Document`为根节点的DOM树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记对应的DOM元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到DOM树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。

解析结束后，浏览器会将文档标注为交互状态，并开始解析那些处于“defferred”模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为“完成”，一个“加载”事件将随之触发。

CSS可以使用各种解析器进行解析，事实上，[CSS规范定义了CSS的词法和语法](http://www.w3.org/TR/CSS2/grammar.html)。

处理脚本和样式表的顺序：

1. 脚本：网络的模型是同步的。网页作者希望解析器遇到`<script>`标记时立即解析并执行脚本。文档的解析将停止，知道脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。作者可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5增加了一个选项，可以将脚本标记为异步，以便由其他现成解析和执行。
2. 预解析：在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上接在，从而提高总体速度。预解析器不会修改DOM树，而是将这项工作交由主解析器处理，预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。
3. 样式表：理论上，应用演示表不会更改DOM树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复。这看上去是一个非典型案例，但事实上非常普遍。Firefox在样式表加载和解析的过程中，会禁用所有脚本。而对于Webkit而言，仅当脚本尝试访问样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。

在DOM树构建的同时，浏览器还会构建另一个树结构：呈现树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让你按照正确的顺序绘制内容。

每一个呈现器都代表了一个矩形的区域，通常对应于相关节点的CSS框，它包含侏儒宽度、高度和位置等集合信息。

呈现器和DOM元素相对应的，但并非一一对应。非可视化的DOM元素不会插入呈现树中，例如`head`元素。如果元素的`display`属性值为`none`，那么也不会显示在呈现树中。

有一些DOM元素对应多个可视化对象，例如`select`或者由于内容太长而折行的文本。

有一些呈现对象对应于DOM节点，但在树中所在的位置与DOM节点不同，例如浮动定位和绝对定位的元素，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。

构建呈现树的流程：

1. Firefox：系统针对DOM更新注册展示层，作为侦听器。展示层将框架创建工作委托给`FrameConstructor`，由该构造器解析样式并创建框架。
2. Webkit：解析样式和创建呈现器的过程称为“附加”。每个DOM节点都有一个`attach`方法。附加是同步进行的，将节点插入DOM树需要调用新的节点`attach`方法。

处理`html`和`body`标记就会构建呈现树的根节点，它的尺寸就是视口，即浏览器窗口显示区域的尺寸。呈现树的其余部分以DOM树节点插入的形式来构建。

构建呈现树时，需要计算每一个呈现对象的可视化属性。这是通过计算每个元素的样式属性来完成的。样式包括来自各种来源的样式表、内联样式元素和HTML中的可视化属性（经过转化以匹配CSS样式属性）。

样式计算存在以下难点：

1. 样式数据是一个超大的结构，存储了无数的样式属性，可能造成内存问题。
2. 如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。
3. 应用规则涉及到相当复杂的层叠规则。

浏览器会把所有匹配的规则存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。

规则树通过缓存整个结构为我们提供帮助，假定底层节点没有提供结构的定义，则可使用上层节点中的缓存结构。

在计算某个特定元素的样式上下文时，首先计算规则树中的对应路径，或者使用现有路径。然后沿此路径应用规则，在新的样式上下文中填充数据。从路径中 拥有最高优先级的底层节点（通常也是最特殊的选择器）开始，并向上遍历规则树，直到结构填充完毕。

样式对象具有与每个可视化属性一一对应的属性。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。如果定义不止一个，需要通过层叠顺序来解决。

根据CSS2规则，层叠的顺序为：

1. 浏览器声明
2. 用户普通声明
3. 作者普通声明
4. 作者重要声明
5. 用户重要声明

同样顺序的声明会根据特异性进行排序。选择器的特异性由[CSS2规范](http://www.w3.org/TR/CSS2/cascade.html#specificity)定义如下：

1. a：如果声明来自`style`属性，而不是带有选择器的规则，则记为1，否则为0
2. b：记为选择器中ID属性的个数
3. c：记为选择器中其他属性和伪类的个数
4. d：记为选择器中元素名称和为元素的个数

将四个数字按`a-b-c-d`这样链接起来，构成特异性。

呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。

HTML采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出集合信息。处于流中靠后位置元素通常不会影响靠前位置元素的集合特征，因此布局可以按从左至右、从上到下的顺序遍历文档（表格计算除外）。

为避免对所有细小更改都进行整体布局，浏览器采用一种“dirty位”系统。如果某个呈现器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。

全局布局是指出发了整个呈现树范围的布局，触发原因可能包括：

1. 影响所有呈现器的全局样式更改，例如字体大小更改
2. 屏幕大小调整

布局可以采用增量方式，也就是只对dirty呈现器进行布局。

增量布局是异步执行的，全局布局往往是同步触发的。有时，当初始布局完成之后，如果一些属性发生变化，布局就会作为回调触发。

布局通常具有以下模式：

1. 父呈现器确定自己的宽度。
2. 父呈现器依次处理子呈现器，并且设置子呈现器x、y坐标，调用子呈现器的布局（这会计算子呈现器的高度）。
3. 父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用。
4. 将其dirty位设置为false。

呈现器宽度是根据容器块的宽度、呈现器样式中的`width`属性以及边距和边框计算得出的。这些值会缓存起来，以用于需要布局而宽度不变的情况。

如果呈现器在布局过程中需要换行，会立刻停止布局，并告知其父代需要换行。父代会创建额外的呈现器，并对其调用布局。

在绘制阶段，系统会遍历呈现树，并调用呈现器的`paint`方法，将呈现器的内容显示在屏幕上。绘制工作时使用用户界面基础组件完成的。

[CSS2规范定义了绘制流程的顺序](http://www.w3.org/TR/CSS21/zindex.html)。绘制的顺序其实就是元素进入堆栈样式上下文的顺序：

1. 背景颜色
2. 背景图片
3. 边框
4. 子代
5. 轮廓

当发生变化时，浏览器会尽可能做出最小的响应。一些重大变化会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。

呈现引擎采用了单线程，几乎所有的操作（除了网络操作）都是在单线程中进行的。网络操作可由多个并行现成执行。并行连接数是有限的。

浏览器的主线程是事件循环。它是一个无线循环，永远处于接受处理状态，并等待事件（如布局和绘制事件）发生，并进行处理。

[CSS框模型](http://www.w3.org/TR/CSS2/box.html)描述的是针对文档树中的元素而生成，并根据可视化格式模型进行布局的矩形框。每个框都有一个内容区域（例如文本、图片等），还有可选的周围补白、边框和边距区域。

所有元素都有一个`display`属性，决定了它们所对应生成的框类型：

1. block：块元素。
2. inline：行内元素。
3. none：不生成CSS框。

三种定位方案：

1. 普通：根据对象在文档中的位置进行定位，也就是说对象在呈现树中的位置和它在DOM树中的位置相似，并根据其框类型和尺寸进行布局。
2. 浮动：对象先按照普通流进行布局，然后尽可能地向左或向右移动。
3. 绝对：对象在呈现树中的位置和它在DOM树中的位置不同。

定位方案是由`position`和`float`属性设置的。

框的布局方式是由以下因素决定的：

1. 框类型
2. 框尺寸
3. 定位方案
4. 外部信息，例如图片大小和屏幕大小

框类型：

1. block框：形成一个block，在浏览器窗口中拥有其自己的矩形区域
2. inline框：没有自己的block，但是位于容器的block内

block采用的是一个接一个的垂直格式，而inline采用的是水平格式。

inline框防止在行中或“行框”中。这些行至少和最高的框一样高，还可以更高，当框根据“底线”对齐时，这意味着元素的底部需要根据其他框中非底部的位置对齐。如果容器的高度不够，inline元素就会分为多行放置。

定位：

1. 相对：先按照普通方式定位，然后根据所需偏移量进行移动。
2. 浮动：浮动框会移动到行的左边或右边，其他框会浮动在它的周围。

绝对定位和固定定位是准确定义的，与普通流无关，元素不参与普通流。尺寸是相对于容器而言的。在固定定位中，容器就是可视区域。即使在文档滚动时，固定框也不会移动。

CSS框分散到多个堆栈中，在每一个堆栈中，会首先绘制后面的元素，然后在顶部绘制前面的元素，以便更靠近用户。如果出现重叠，新绘制的元素就会覆盖之前的元素。

堆栈是按照`z-index`属性进行排序的。具有`z-index`属性的框形成了本地堆栈。视口具有外部堆栈。
