<!DOCTYPE html>
<html>

  <head>
    <title>简析jQuery几个绑定事件方法的优劣异同</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="/common/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/blog.css">
  </head>

  <body>
    <div class="blog-masthead">
      <div class="container">
        <nav class="blog-nav"><a href="/" class="blog-nav-item active">主页</a><a href="/posts" class="blog-nav-item">文章</a><a href="/tags" class="blog-nav-item">标签</a><a href="/projects" class="blog-nav-item">项目</a><a href="/about" class="blog-nav-item">关于</a></nav>
      </div>
    </div>
    <div class="container">
      <div class="blog-header">
        <h1 class="blog-title">小麦的二三事</h1>
        <p class="lead blog-description">他大舅他二舅，都是他舅</p>
      </div>
      <div class="col-sm-8 blog-main">
        <div class="row">
          <div class="blog-post">
            <h2 class="blog-post-title">简析jQuery几个绑定事件方法的优劣异同</h2>
            <p class="blog-post-meta">写于2013年07月10日 关于<a href="/tags/JavaScript">JavaScript</a>,<a href="/tags/jQuery">jQuery</a></p>
            <p>今天被问到jQuery中绑定事件的方式，回答了<code>bind</code>、<code>live</code>、<code>on</code>三种。继续被问到哪种方式比较好。当时我毫不犹豫地说是<code>on</code>。继续被追问说除了<code>on</code>还知不知道有什么更好的方式绑定事件。当时哥就蒙了，还有更好的绑定事件的方式吗？决定写一下jQuery中绑定事件有哪些方式，各种方式之间的区别又是啥。</p>
            <h3 id="-bind">.bind</h3>
            <p>先看看jQuery官方是怎么描述<code>bind</code>的：</p>
            <blockquote>
              <p>Attach a handler to an event for the elements.</p>
            </blockquote>
            <p>简单地说就是往元素上绑定事件处理程序。该方法接受三个参数：</p>
            <ol>
              <li><code>eventType</code>，绑定事件的名称。名称可以是任意的，接受自定义事件（只能通过<code>trigger</code>触发）。</li>
              <li><code>eventData</code>，可选，绑定事件附加的数据，这个数据会附在事件对象的<code>data</code>属性里面。</li>
              <li><code>handler</code>，事件处理程序，每次触发事件都会执行这个事件处理程序。</li>
            </ol>
            <p><strong>必须在一个已存在的元素上才能使用<code>bind</code>。</strong><code>bind</code>只能把事件处理程序绑定到指定的DOM元素上面。注意的是，如果为该对象的同一个事件绑定多个事件处理程序，则其执行的顺序是按照其绑定的先后顺序决定的。</p>
            <p>假如绑定的对象只是一个DOM元素（例如通过id选择器选择），那么用<code>bind</code>是可以的，不会带来太多额外的开销。但是当选择器选择的DOM对象个数非常多，由于要在每一个元素上都绑定同一个事件处理程序，会带来额外的开销，包括获取DOM元素、遍历所有DOM元素绑定事件处理程序等。而且由于<code>bind</code>绑定时机的局限性，一般在频繁动态创建和删除DOM的场景下都不会使用<code>bind</code>。</p>
            <h3 id="-live">.live</h3>
            <p>又看看jQuery官方是怎么描述<code>live</code>的：</p>
            <blockquote>
              <p>Attach an event handler for all elements which match the current selector, now and in the future.</p>
            </blockquote>
            <p>可以为所有匹配该选择器的元素（无论存在与否）绑定事件处理程序。该方法接受的参数跟<code>bind</code>是一致的。</p>
            <p>这个方法把事件处理程序绑定到<code>document</code>上，根据触发事件的DOM对象是否满足选择器而决定是否执行事件处理程序。由于事件处理程序是绑定在<code>document</code>上的，所有无论在绑定事件的时候选择器对应的元素是否存在，都能在事件触发之后正确执行相关的事件处理程序。</p>
            <p>根据官方的说法，<code>live</code>有以下几个缺点：</p>
            <ol>
              <li>jQuery按照选择器先获取所有匹配的DOM对象，这个开销是不必要的。</li>
              <li>不支持链式的写法。</li>
              <li>因为所有的事件处理程序都是绑定在<code>document</code>元素，如果目标元素所在的DOM树节点比较深，会有一个比较长的冒泡路径。</li>
              <li>在iPad、iTouch和iPhone上，<code>click</code>事件不会冒泡到<code>document</code>上（囧）。</li>
              <li><code>event.stopPropagation</code>不能阻止事件冒泡，因为事件已经冒泡到<code>document</code>上面了（囧）。</li>
              <li>与别的事件绑定方法共用会有意想不到的结果。例如<code>$(document).off(&quot;click&quot;)</code>。</li>
            </ol>
            <p>鉴于以上种种缺点，<strong>这个方法在1.7已经被声明是废弃的了。</strong>1.7之后的版本应该是用<code>on</code>来替代，1.7之前的版本应该用<code>delegate</code>来替代。</p>
            <h3 id="-delegate">.delegate</h3>
            <p>再看看jQuery官方是怎么描述<code>delegate</code>的：</p>
            <blockquote>
              <p>Attach a handler to one or more events for all elements that match the selector, now or in the future, based on a specific set of root elements.</p>
            </blockquote>
            <p>跟<code>live</code>不一样，<code>delegate</code>可以把事件处理程序委托到一个指定的“根”元素上面（而<code>live</code>一定是<code>document</code>）。这个方法接受四个参数：</p>
            <ol>
              <li><code>selector</code>，选择器，当触发事件的DOM元素匹配这个选择器时触发事件处理程序。</li>
              <li><code>eventType</code>，同<code>bind</code>。</li>
              <li><code>eventData</code>，同<code>bind</code>。</li>
              <li><code>handler</code>，同<code>bind</code>。</li>
            </ol>
            <p>从参数上看，由于<code>delegate</code>可以指定一个元素作为“根”，则没有<code>live</code>的缺点1、缺点2和缺点3。跟<code>live</code>类似，<code>event.stopPropagation</code>在代理的事件处理程序中也是无效的，更有甚者，假如在“根”元素的DOM树下，其中一个元素的这个事件处理程序阻止了事件冒泡，那么代理的事件处理程序将被阻止执行。在1.7之前，<code>delegate</code>是最效率的事件绑定方式。在1.7，<code>delegate</code>已经被<code>on</code>代替了。</p>
            <h3 id="-on">.on</h3>
            <p>最后看看jQuery官方是怎么描述<code>on</code>的：</p>
            <blockquote>
              <p>Attach an event handler function for one or more events to the selected elements.</p>
            </blockquote>
            <p>有点返璞归真的感觉，就是往选中的元素绑定某个事件处理程序。在1.7里，<code>on</code>提供了所有有关于事件绑定的功能，这个方法接受四个参数：</p>
            <ol>
              <li><code>events</code>，要绑定的事件，可以多个，用空格隔开。</li>
              <li><code>selector</code>，可选，过滤选择器，只有匹配这个选择器的元素才执行事件处理程序。如果没有提供则认为是绑定在选中的元素上。</li>
              <li><code>data</code>，可选，同<code>bind</code>的<code>eventData</code>。</li>
              <li><code>handler</code>，同<code>bind</code>。</li>
            </ol>
            <p><code>on</code>比较有趣的是<code>selector</code>这个参数。如果没有，则跟<code>bind</code>一样是绑定在某个特定的元素上。如果有，则跟<code>delegate</code>类似，是一个事件代理，把<code>selector</code>匹配的元素的事件处理程序代理到选中的元素上。</p>
            <p><em>小细节：<code>load</code>、<code>scroll</code>、<code>error</code>不支持事件委托哦亲！</em></p>
            <p>从jQuery的官方文档看出来，jQuery强烈建议后来写的代码都用<code>on</code>作为事件绑定的方式。所有关于事件绑定的内容，如事件名称及其命名空间、直接绑定和事件委托、事件处理程序及其运行上下文（<code>this</code>）、附加数据还有事件性能等说明，都写在<code>on</code>的那一页。从代码上看，之前的<code>bind</code>、<code>live</code>、<code>delegate</code>在1.7里面的实现都变成是<code>on</code>了。从接口上看<code>on</code>也统一了绑定事件处理程序的各种接口。就让<code>on</code>来得更猛烈一些吧！</p>
            <p>由于时间关系，对于<code>on</code>的研究还要继续，需要解决的问题有：</p>
            <ol>
              <li>究竟<code>on</code>能否解决在事件委托的情况下不能使用<code>event.stopPropagation</code>的问题？</li>
              <li>假如在委托模式下，选择元素的其中一个子元素阻止事件冒泡，<code>on</code>委托的事件处理程序还能否顺利执行？</li>
            </ol>
            <p>明天继续探讨。</p>
            <nav class="pager">
              <li><a href="/posts/2013/07/08/three-column-layout-middle-first.html" title="经典三列布局之如何让中间的列先显示出来">上一篇</a></li>
              <li><a href="/posts/2013/07/11/jquery-event-2.html" title="jQuery事件绑定研究续">下一篇</a></li>
            </nav>
          </div>
        </div>
      </div>
      <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
        <div class="sidebar-module">
          <h4>文章</h4>
          <ol class="list-unstyled">
            <li><a href="/posts/2014/02">2014年02月</a></li>
            <li><a href="/posts/2014/01">2014年01月</a></li>
            <li><a href="/posts/2013/12">2013年12月</a></li>
            <li><a href="/posts/2013/11">2013年11月</a></li>
            <li><a href="/posts/2013/10">2013年10月</a></li>
            <li><a href="/posts/2013/09">2013年09月</a></li>
            <li><a href="/posts/2013/08">2013年08月</a></li>
            <li><a href="/posts/2013/07">2013年07月</a></li>
            <li><a href="/posts/2013/01">2013年01月</a></li>
            <li><a href="/posts/2012/12">2012年12月</a></li>
          </ol>
        </div>
        <div class="sidebar-module">
          <h4>标签</h4>
          <ol class="list-unstyled">
            <li><a href="/tags/notes">notes(5)</a></li>
            <li><a href="/tags/css">css(23)</a></li>
            <li><a href="/tags/html">html(10)</a></li>
            <li><a href="/tags/JavaScript">JavaScript(106)</a></li>
            <li><a href="/tags/前端">前端(9)</a></li>
            <li><a href="/tags/jQuery">jQuery(29)</a></li>
            <li><a href="/tags/http">http(4)</a></li>
            <li><a href="/tags/node">node(3)</a></li>
            <li><a href="/tags/html5">html5(7)</a></li>
            <li><a href="/tags/Flash">Flash(30)</a></li>
          </ol>
        </div>
      </div>
    </div>
    <div class="container"></div>
    <footer class="blog-footer">
      <p>Powerby MaiZhiying</p>
    </footer>
  </body>

</html>