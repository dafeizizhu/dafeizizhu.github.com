<!DOCTYPE html>
<html>

  <head>
    <title>jQuery事件绑定研究续</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="/common/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/blog.css">
  </head>

  <body>
    <div class="blog-masthead">
      <div class="container">
        <nav class="blog-nav"><a href="/" class="blog-nav-item active">主页</a><a href="/posts" class="blog-nav-item">文章</a><a href="/tags" class="blog-nav-item">标签</a><a href="/projects" class="blog-nav-item">项目</a><a href="/about" class="blog-nav-item">关于</a></nav>
      </div>
    </div>
    <div class="container">
      <div class="blog-header">
        <h1 class="blog-title">小麦的二三事</h1>
        <p class="lead blog-description">他大舅他二舅，都是他舅</p>
      </div>
      <div class="col-sm-8 blog-main">
        <div class="row">
          <div class="blog-post">
            <h2 class="blog-post-title">jQuery事件绑定研究续</h2>
            <p class="blog-post-meta">写于2013年07月11日 关于<a href="/tags/JavaScript">JavaScript</a>,<a href="/tags/jQuery">jQuery</a></p>
            <p>昨天留下了两个问题：</p>
            <ol>
              <li>究竟<code>on</code>能否解决在事件委托的情况下不能使用<code>event.stopPropagation</code>的问题？</li>
              <li>假如在委托模式下，选择元素的其中一个子元素阻止事件冒泡，<code>on</code>委托的事件处理程序还能否顺利执行？</li>
            </ol>
            <p>针对问题1，先做一个实验，<a href="http://jsfiddle.net/Ask5n/2/">参考这里</a>：</p>
            <p>HTML：</p> <pre><code>&lt;div id=&quot;root&quot;&gt;
    &lt;div id=&quot;outer&quot;&gt;
        Outer
        &lt;div id=&quot;inner&quot;&gt;Inner&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
            <p>JavaScript：</p> <pre><code>$(&quot;#root&quot;).on(&quot;click&quot;, function (evt) {
    alert(&quot;click on root&quot;);
});

$(&quot;#root&quot;).on(&quot;click&quot;, &quot;#outer&quot;, function (evt) {
    alert(&quot;click on outer delegate&quot;);
});

$(&quot;#root&quot;).on(&quot;click&quot;, &quot;#inner&quot;, function (evt) {
    alert(&quot;click on inner delegate, and i stop propagation!&quot;);
    evt.stopPropagation();
});
</code></pre>
            <p>单击<code>#inner</code>，成功的阻止了<code>#outer</code>和<code>#root</code>上面的单击事件，说明在全部都用<code>on</code>的情况下是可以实现阻止冒泡的功能。这个貌似跟事件委托的原理有点违背的感觉。看看jQuery的源码是怎么实现的。</p>
            <p>观察1.7的源码发现，<code>on</code>对于选中的元素进行事件绑定的数据是用内部的<code>_data</code>方法存在DOM里面的。所有事件都会绑定到内部的<code>dispatch</code>方法，由这个方法分发具体的事件，进而触发具体的事件处理程序。其中有这么一段代码：</p> <pre><code>if ( selector ) {
    handlers.splice( handlers.delegateCount++, 0, handleObj );
} else {
    handlers.push( handleObj );
}
</code></pre>
            <p>如果是事件委托，会放到处理程序队列的前端（但是还是按照委托的顺序进行存放），而事件绑定则是放到队列的最后。这样导致事件委托的处理程序会优先于事件绑定的处理程序执行。现在再来看看事件触发的时候jQuery是怎么处理的。</p>
            <p>触发事件时，先拿到当前事件处理程序的<code>elem</code>属性（即做事件委托时选中的“根”元素），然后以这个元素为事件处理程序的执行上下文（使用<code>apply</code>把<code>dispatch</code>方法里面的<code>this</code>变成该元素），并传入事件对象。<code>dispatch</code>方法先把事件对象封装一下，屏蔽浏览器差异（万恶的IE），然后从触发事件的<code>target</code>出发，遍历其父元素一直到“根”元素。在每一次循环里面，再遍历“根”元素这个事件上的<code>handler</code>队列（就是上文的<code>handlers</code>）中的事件委托部分，如果该事件委托的<code>selector</code>与当前这个元素匹配，则把该事件处理程序及其对应的元素放入最终的事件处理程序队列。事件委托遍历完成后，把剩余的事件绑定的处理程序及“根”元素一并放入最终队列中。到这个时候，就可以看出前面那个实验的结果是理所当然的。<strong>当为一个“根”元素中若干个子元素进行事件委托，<code>event.stopPropagation</code>是有效的。</strong></p>
            <p>经过以上的分析，问题2的答案也出来了。当全部都是使用<code>on</code>的事件委托模式去处理事件，是不会出现问题的。但是假如其中一个元素使用的是事件绑定的方式，则有可能会阻止事件委托的处理程序的执行，<a href="http://jsfiddle.net/rp3Wp/">参考这里</a>：</p> <pre><code>$(&quot;#root&quot;).on(&quot;click&quot;, function (evt) {
    alert(&quot;click on root&quot;);
});

$(&quot;#outer&quot;).on(&quot;click&quot;, function (evt) {
    alert(&quot;click on outer delegate, and i stop propagation!&quot;);
    evt.stopPropagation();
});

$(&quot;#root&quot;).on(&quot;click&quot;, &quot;#inner&quot;, function (evt) {
    alert(&quot;click on inner&quot;);
});
</code></pre>
            <p>单击<code>#inner</code>，有趣的事情发生了，<code>#outer</code>的事件处理程序执行，并阻止了事件冒泡，导致<code>#inner</code>的事件处理程序没有被执行，坑爹啊！</p>
            <p>血淋淋的事实告诉我们，要把<code>on</code>的事件委托进行到底到底到底到底……</p>
            <nav class="pager">
              <li><a href="/posts/2013/07/10/jquery-bind-live-on-delegate.html" title="简析jQuery几个绑定事件方法的优劣异同">上一篇</a></li>
              <li><a href="/posts/2013/07/12/http-header.html" title="HTTP协议之HTTP 头">下一篇</a></li>
            </nav>
          </div>
        </div>
      </div>
      <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
        <div class="sidebar-module">
          <h4>文章</h4>
          <ol class="list-unstyled">
            <li><a href="/posts/2014/02">2014年02月</a></li>
            <li><a href="/posts/2014/01">2014年01月</a></li>
            <li><a href="/posts/2013/12">2013年12月</a></li>
            <li><a href="/posts/2013/11">2013年11月</a></li>
            <li><a href="/posts/2013/10">2013年10月</a></li>
            <li><a href="/posts/2013/09">2013年09月</a></li>
            <li><a href="/posts/2013/08">2013年08月</a></li>
            <li><a href="/posts/2013/07">2013年07月</a></li>
            <li><a href="/posts/2013/01">2013年01月</a></li>
            <li><a href="/posts/2012/12">2012年12月</a></li>
          </ol>
        </div>
        <div class="sidebar-module">
          <h4>标签</h4>
          <ol class="list-unstyled">
            <li><a href="/tags/notes">notes(5)</a></li>
            <li><a href="/tags/css">css(23)</a></li>
            <li><a href="/tags/html">html(10)</a></li>
            <li><a href="/tags/JavaScript">JavaScript(106)</a></li>
            <li><a href="/tags/前端">前端(9)</a></li>
            <li><a href="/tags/jQuery">jQuery(29)</a></li>
            <li><a href="/tags/http">http(4)</a></li>
            <li><a href="/tags/node">node(3)</a></li>
            <li><a href="/tags/html5">html5(7)</a></li>
            <li><a href="/tags/Flash">Flash(30)</a></li>
          </ol>
        </div>
      </div>
    </div>
    <div class="container"></div>
    <footer class="blog-footer">
      <p>Powerby MaiZhiying</p>
    </footer>
  </body>

</html>