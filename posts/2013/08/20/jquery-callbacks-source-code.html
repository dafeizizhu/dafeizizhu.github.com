<!DOCTYPE html>
<html>

  <head>
    <title>jQuery源码解析之jQuery.Callbacks</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="/common/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/blog.css">
  </head>

  <body>
    <div class="blog-masthead">
      <div class="container">
        <nav class="blog-nav"><a href="/" class="blog-nav-item active">主页</a><a href="/posts" class="blog-nav-item">文章</a><a href="/tags" class="blog-nav-item">标签</a><a href="/projects" class="blog-nav-item">项目</a><a href="/about" class="blog-nav-item">关于</a></nav>
      </div>
    </div>
    <div class="container">
      <div class="blog-header">
        <h1 class="blog-title">小麦的二三事</h1>
        <p class="lead blog-description">他大舅他二舅，都是他舅</p>
      </div>
      <div class="col-sm-8 blog-main">
        <div class="row">
          <div class="blog-post">
            <h2 class="blog-post-title">jQuery源码解析之jQuery.Callbacks</h2>
            <p class="blog-post-meta">写于2013年08月20日 关于<a href="/tags/JavaScript">JavaScript</a>,<a href="/tags/jQuery">jQuery</a></p>
            <p>昨天介绍了<code>jQuery.Callbacks</code>方法，今天简单看一下它的源码。github上的代码链接<a href="https://github.com/jquery/jquery/blob/master/src/callbacks.js">在这里</a>。</p>
            <p>jQuery的主干已经是2.0版本了。几乎每个文件的开始都是按照以下的形式给出：</p> <pre><code>define([
  &quot;./core&quot;,
  &quot;./var/rnotwhite&quot;
], function( jQuery, rnotwhite ) {
</code></pre>
            <p>通过一个全局的<code>define</code>函数，实现类似于node的依赖管理。现在还没有看<code>define</code>的源码，可以猜测第一个参数就是这个js文件（模块）的依赖，而这个模块的逻辑都被封装在第二个匿名函数的闭包里面。</p>
            <p>首先是一个工具方法，解析<code>jQuery.Callbacks</code>方法传入的参数，即各种flag。这里有一个性能优化点，<code>Callbacks</code>方法会以每次调用的字符串参数作为key，解析的结果作为value缓存起来，下次使用同样的字符串调用<code>jQuery.Callbacks</code>就可以省去解析参数的过程了。</p>
            <p>这个方法的核心就是返回的对象，这个对象的核心就是<code>fire</code>、<code>add</code>和<code>remove</code>等方法。</p>
            <p>首先来看一个工具函数<code>fire</code>，<code>Callbacks</code>对象上的<code>fire</code>跟<code>fireWidth</code>这两个方法都是基于这个工具函数的。这个工具函数会递归调用自己，并每次更改<code>fire</code>的索引来遍历整个回调列表。这里关注一下递归的结束条件：</p> <pre><code>if ( stack ) {
  if ( stack.length ) {
    fire( stack.shift() );
  }
} else if ( memory ) {
  list = [];
} else {
  self.disable();
}
</code></pre>
            <p><code>stack</code>这个变量很有意思。当<code>once</code>标志生效时，这个<code>stack</code>永远都为<code>false</code>。如果<code>once</code>标志不生效，这个<code>stack</code>就是作为在<code>fire</code>的过程中，再调用<code>fire</code>时的一个类似于消息队列的东西。第一个逻辑是判断是否有消息队列，如果有则从消息队列中取出一个消息递归调用<code>fire</code>本身。如果没有消息队列，说明<code>stack</code>为<code>false</code>，这时也有两种情况。</p>
            <ol>
              <li><code>memory</code>标志生效，则把<code>list</code>重置为空数组，接受下一次的<code>add</code>操作。</li>
              <li><code>memory</code>标志不生效，则说明个只有<code>once</code>标志生效，禁用这个<code>Callbacks</code>对象。</li>
            </ol>
            <p>第二个要关注的方法就是<code>add</code>，负责添加回调到<code>Callbacks</code>对象上面。这个方法支持传入参数的方式有很多种：可以是简单的一个方法，也可以是一个方法的数组，也可以是前两者的混搭，例如：</p> <pre><code>var cbs = $.Callbacks();
cbs.add(fn);
cbs.add([fn1, fn2, fn3]);
cbs.add(fn, fn1, [fn2, fn3, fn4]);
</code></pre>
            <p>要实现这种机制，需要一个递归去遍历<code>arguments</code>。判断<code>arguments</code>中的每个参数的类型：</p>
            <ol>
              <li>如果是方法，直接加到回调列表<code>list</code>中。</li>
              <li>如果是一个类似数组的东西，递归调用<code>add</code>（实现中是一个内部的匿名函数）。</li>
            </ol>
            <p>通过这个机制就可以把上面三种类型的参数传入方式都解析出来，提取对应的回调，并添加到回调列表里面。再关注一下最后的几行代码：</p> <pre><code>// Do we need to add the callbacks to the
// current firing batch?
if ( firing ) {
  firingLength = list.length;
// With memory, if we&#39;re not firing then
// we should call right away
} else if ( memory ) {
  firingStart = start;
  fire( memory );
}
</code></pre>
            <p>注意，<code>fire</code>的时候也可以调用<code>add</code>。如果正处在<code>fire</code>的过程中（<code>firing === true</code>），需要把要遍历的回调列表长度调整到调用<code>add</code>之后的长度。如果不在<code>fire</code>过程中，则要判断<code>memory</code>标志是否生效，生效则需要重新触发<code>fire</code>，保证刚增加的回调函数能顺利执行。</p>
            <p>最后再关注一下<code>remove</code>方法，这里值得注意的也是<code>fire</code>过程中的<code>remove</code>。需要判断当前删除的回调是否已经执行，代码片段如下：</p> <pre><code>// Handle firing indexes
if ( firing ) {
  if ( index &lt;= firingLength ) {
    firingLength--;
  }
  if ( index &lt;= firingIndex ) {
    firingIndex--;
  }
}
</code></pre>
            <p><code>Callbacks</code>对象还有其他方法，例如<code>has</code>、<code>empty</code>、<code>disable</code>、<code>lock</code>，还有几个获取状态的方法，这里就不详细展开了，有兴趣的同鞋可以参考上面的github上的链接看其他的源码。不得不佩服jQuery为了满足各种各样的场景而写出这样完备的代码，在日常工作中，我个人还是觉得应该根据具体的应用场景去考虑代码的健壮性，如果每一个功能、每一段代码都得像jQuery那样严谨完备，的确是件十分美妙的事情，工作往往是更现实的事情，各种无奈就不多展开了啊！</p>
            <nav class="pager">
              <li><a href="/posts/2013/08/19/jquery-callbacks.html" title="jQuery.Callbacks">上一篇</a></li>
              <li><a href="/posts/2013/08/21/document-write.html" title="document.write">下一篇</a></li>
            </nav>
          </div>
        </div>
      </div>
      <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
        <div class="sidebar-module">
          <h4>文章</h4>
          <ol class="list-unstyled">
            <li><a href="/posts/2014/02">2014年02月</a></li>
            <li><a href="/posts/2014/01">2014年01月</a></li>
            <li><a href="/posts/2013/12">2013年12月</a></li>
            <li><a href="/posts/2013/11">2013年11月</a></li>
            <li><a href="/posts/2013/10">2013年10月</a></li>
            <li><a href="/posts/2013/09">2013年09月</a></li>
            <li><a href="/posts/2013/08">2013年08月</a></li>
            <li><a href="/posts/2013/07">2013年07月</a></li>
            <li><a href="/posts/2013/01">2013年01月</a></li>
            <li><a href="/posts/2012/12">2012年12月</a></li>
          </ol>
        </div>
        <div class="sidebar-module">
          <h4>标签</h4>
          <ol class="list-unstyled">
            <li><a href="/tags/notes">notes(5)</a></li>
            <li><a href="/tags/css">css(23)</a></li>
            <li><a href="/tags/html">html(10)</a></li>
            <li><a href="/tags/JavaScript">JavaScript(106)</a></li>
            <li><a href="/tags/前端">前端(9)</a></li>
            <li><a href="/tags/jQuery">jQuery(29)</a></li>
            <li><a href="/tags/http">http(4)</a></li>
            <li><a href="/tags/node">node(3)</a></li>
            <li><a href="/tags/html5">html5(7)</a></li>
            <li><a href="/tags/Flash">Flash(30)</a></li>
          </ol>
        </div>
      </div>
    </div>
    <div class="container"></div>
    <footer class="blog-footer">
      <p>Powerby MaiZhiying</p>
    </footer>
  </body>

</html>