<!DOCTYPE html>
<html>

  <head>
    <title>Secrets of the JavaScript Ninja 读书笔记之 纯JavaScript实现的CSS选择器引擎</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="/common/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/blog.css">
  </head>

  <body>
    <div class="blog-masthead">
      <div class="container">
        <nav class="blog-nav"><a href="/" class="blog-nav-item active">主页</a><a href="/posts" class="blog-nav-item">文章</a><a href="/tags" class="blog-nav-item">标签</a><a href="/projects" class="blog-nav-item">项目</a><a href="/about" class="blog-nav-item">关于</a></nav>
      </div>
    </div>
    <div class="container">
      <div class="blog-header">
        <h1 class="blog-title">小麦的二三事</h1>
        <p class="lead blog-description">他大舅他二舅，都是他舅</p>
      </div>
      <div class="col-sm-8 blog-main">
        <div class="row">
          <div class="blog-post">
            <h2 class="blog-post-title">Secrets of the JavaScript Ninja 读书笔记之 纯JavaScript实现的CSS选择器引擎</h2>
            <p class="blog-post-meta">写于2013年10月27日 关于<a href="/tags/JavaScript">JavaScript</a></p>
            <p>一个CSS选择器引擎的核心其实是纯JavaScript实现的这个部分。最主要的功能就是把CSS选择器映射到一系列浏览器原生提供的API（例如<code>getElementById</code>或者<code>getElementsByTagName</code>等）的调用序列，通过这些原生的API去寻找我们想要定位到的元素。</p>
            <p>为什么还需要一个纯JavaScript实现的CSS选择器引擎？</p>
            <ol>
              <li>a因为IE6和IE7不支持原生的CSS选择器、也不支持使用XPath。</li>
              <li>a因为我们的站点可能需要向前兼容这些古董浏览器。</li>
              <li>a因为效率，某些CSS选择器使用原生的API速度更快（例如<code>id</code>选择器）。</li>
              <li>a因为CSS选择器的覆盖率，由于不是所有支持原生CSS选择器的浏览器都支持所有CSS选择器，所以当某个选择器在某个浏览器里面不支持就要退化到纯JavaScript的实现。</li>
            </ol>
            <p>通常我们会从左到右分析一个CSS选择器，然后顺着<code>root</code>往下找，例如以下的选择器：</p> <pre><code>div.ninja a span
</code></pre>
            <p>按照一般的逻辑，我们会找<code>class</code>是<code>ninja</code>的<code>div</code>，在它的子元素中找<code>a</code>，在<code>a</code>的子元素中找<code>span</code>。这里要注意两个问题：</p>
            <ol>
              <li>a返回的结果可能有多个，它们的顺序要跟定义的顺序一致。</li>
              <li>a返回的结果中不能有重复的DOM。</li>
            </ol>
            <p>由于这两个问题，使用从上到下分析DOM文档树的方法可能需要一些额外的工作量，所以就有了从下到上分析DOM文档树的方法去解析CSS选择器。原理就是先找出文档树中匹配最右边的选择器的元素，再去匹配它的祖先元素是否满足左侧的CSS选择器：</p> <pre><code>function find(selector, root) {
  root  = root || document;
  var parts = selector.split(&quot; &quot;),
      query = parts[0],
      rest = parts.slice(1).join(&quot; &quot;),
      elems = root.getElementsByTagName(query),
      results = [];

  for (var i = 0; i &lt; elems.length; i++) {
    if (rest) {
      results = results.concat(find(rest, elems[i]));
    } else {
      results.push(elems[i]);
    }
  }
  return results;
}
</code></pre>
            <p>这里通过一个递归，从最底层的DOM元素开始，顺着文档树往上找就能找到所有匹配这个选择器的元素了，十分简单的逻辑。也是因为逻辑简单，所以效率没有从上往下实现的CSS选择器引擎要高，这就看大家的取舍了。</p>
            <nav class="pager">
              <li><a href="/posts/2013/10/25/jquery-val.html" title="jQuery扫盲之val">上一篇</a></li>
              <li><a href="/posts/2013/10/28/jquery-callbacks-add.html" title="jQuery扫盲之Callbacks">下一篇</a></li>
            </nav>
          </div>
        </div>
      </div>
      <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
        <div class="sidebar-module">
          <h4>文章</h4>
          <ol class="list-unstyled">
            <li><a href="/posts/2014/02">2014年02月</a></li>
            <li><a href="/posts/2014/01">2014年01月</a></li>
            <li><a href="/posts/2013/12">2013年12月</a></li>
            <li><a href="/posts/2013/11">2013年11月</a></li>
            <li><a href="/posts/2013/10">2013年10月</a></li>
            <li><a href="/posts/2013/09">2013年09月</a></li>
            <li><a href="/posts/2013/08">2013年08月</a></li>
            <li><a href="/posts/2013/07">2013年07月</a></li>
            <li><a href="/posts/2013/01">2013年01月</a></li>
            <li><a href="/posts/2012/12">2012年12月</a></li>
          </ol>
        </div>
        <div class="sidebar-module">
          <h4>标签</h4>
          <ol class="list-unstyled">
            <li><a href="/tags/notes">notes(5)</a></li>
            <li><a href="/tags/css">css(23)</a></li>
            <li><a href="/tags/html">html(10)</a></li>
            <li><a href="/tags/JavaScript">JavaScript(106)</a></li>
            <li><a href="/tags/前端">前端(9)</a></li>
            <li><a href="/tags/jQuery">jQuery(29)</a></li>
            <li><a href="/tags/http">http(4)</a></li>
            <li><a href="/tags/node">node(3)</a></li>
            <li><a href="/tags/html5">html5(7)</a></li>
            <li><a href="/tags/Flash">Flash(30)</a></li>
          </ol>
        </div>
      </div>
    </div>
    <div class="container"></div>
    <footer class="blog-footer">
      <p>Powerby MaiZhiying</p>
    </footer>
  </body>

</html>