---
layout: post
title: "神奇的负边距"
description: ""
category: 
tags: [css]
---
{% include JB/setup %}

之前写过一篇[《经典三列布局之如何让中间的列先显示出来》](/posts/2013/07/08/three-column-layout-middle-first.html)，里面讲的就是使用浮动、相对定位和负边距来做的一套布局。写那篇文章的时候还没太搞懂负边距是怎么回事，今天简单分析一下对不同元素（正常、浮动、绝对定位等）的负边距是如何起作用的。

首先明确几点：

1. 负边距是完全合法的CSS写法，W3允许边距的值是负值。
2. 负边距不属于CSS hack。
3. 负边距不会使元素脱离文档流。
4. 所有现代浏览器都支持负边距（IE6也部分支持，太棒了！）。

简单看看负边距的工作原理：

1. 在`top`和`left`方向上应用负边距，该元素会向指定的方向移动，随后的元素也会跟着一起移动。
2. 在`bottom`和`right`方向上应用负边距，该元素的位置不会发生任何移动，但是随后的元素会挤压过来，看上去的效果就是该元素占的空间变小了。
3. 当该元素没有应用宽度（`width: auto`也算），为该元素设置`left`和`right`方向上的负边距会让元素的宽度边大。

负边距有什么用呢？其中最重要的一个作用我认为是把DOM树中较后出现的元素显示在页面较前的位置。我们知道HTML解析DOM树的时候是根据书写的顺序解析的。而文档的解析顺序是从上到下，从左到右（当然方向是`ltr`）的，那么正常书写的N列布局肯定是第一列写在最前边，但是可能我们需要中间第n列先解析，这时候就要把第n列的内容书写在前边，通过负边距调整位置，达到理想的效果。

现在分析一下之前写过的那篇文章中，左列的CSS究竟是如何达到最后的效果的。现来看看左列的CSS代码。

    #left {
        position: relative; // 1
        left: -100px;       // 2
        float: left;        // 3
        margin-left: -100%; // 4   
    }

这个元素分别使用了浮动、相对定位和负边距三种方式进行布局。现在按负边距、浮动、相对定位的顺序加上CSS，效果为：

1. 加上负边距，该元素向左移动，移动的距离跟父元素的宽度一致。注意，这里的宽度是指**内容宽度**，即不算`padding`、`border`和`margin`的宽度。
2. 加上浮动，该元素与`middle`两个元素都变成浮动元素，负边距使得该元素沿着浮动方向位移了父元素的宽度，效果是该元素的左边界与`middle`的左边界重合。
3. 最后加上相对定位，让该元素相对于其现有位置再向左移动与其宽度相等的距离。最后的效果就是该元素移动到`middle`元素的左侧。

利用负边距，还能做出很多有趣的效果，例如一些层叠效果，如标签页、印章等。与其他CSS样式结合起来更是有趣。

今天在工作中也利用了之前写的三列布局的知识。用心沉淀，再返回到实践中，这种感觉真好。
