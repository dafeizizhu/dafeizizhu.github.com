---
layout: post
title: "《JavaScript设计模式与开发实践》读书笔记之一"
description: ""
category: 
tags: [JavaScript, 读书笔记]
---

### 前言

设计模式是在某种场合下对某个问题的一种解决方案。编程的过程中不断学到一些名词和原理，虽然这些名词和原理他不知道，但事实上在编程的过程中多年以来一直在使用，这些就是设计模式。设计模式的名字只是方便程序猿之间的交流。

#### 学习模式的作用

模式时一些经过了大量实际项目验证的优秀解决方案。对某些模式的理解形成条件反射，当合适的场景出现时，我们很快可以找到某种模式作为解决方案。

#### 模式在不同语言之间的区别

设计模式仅仅是就面向对象的语言而言的。但是，在函数式或者其他变成范型的语言中，设计模式依然存在。例如命令模式在Lisp或者JavaScript中就成为了一种隐形模式（函数可以被当成对象一样四处传递）。

#### 设计模式的适用性

设计模式确实有可能带来代码量的增加，或许也会把系统的逻辑搞得更复杂。设计模式的作用是让人们写出可复用和可维护性高的程序。所有设计模式的实现都遵循一条原则，**“找出程序中变化的地方，并将变化封装起来”**。但是，模式应该用在正确的地方，需要结合项目的实际场景。

### 第1章 面向对象的JavaScript

JavaScript没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。

#### 1.1 动态类型语言和鸭子类型

静态类型语言的优点：

1. 在编译时就能发现类型不匹配的错误。
2. 针对数据类型等信息优化程序，提高程序运行速度。

静态类型语言的缺点：

1. 每个变量规定数据类型归根结底只是辅助我们编写可靠性高程序的一种手段，而不是编写程序的目的。
2. 类型等其他细节让程序猿的精力从思考业务逻辑上分散开来。

动态语言的优点：

1. 编写的代码更少，更简洁，更专注于逻辑表达，对阅读程序有帮助。

动态语言的缺点：

1. 无法保证变量的类型，从而在程序的运行期有可能发生类型相关的错误。

动态语言给实际编码带来了很大的灵活性，我们可以尝试调用任何对象的任何方法，而无需考虑它原本是否被设计为拥有该方法。动态语言更关注的是`HAS-A`，而不是`IS-A`。

在动态语言中，更容易实现一个原则：**面向接口编程，而不是面向实现编程**。

#### 1.2 多态

多态的实际含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。

##### 1.2.1 一段“多态”的JavaScript代码

修改代码总是危险的，修改的地方越多，程序出错的可能性就越大（针对各种`if`、`else`和`switch`）。

多态背后的思想是将“不变的事物”和“可能改变的事物”分离开来。

##### 1.2.2 对象的多态性

面向接口编程。

##### 1.2.3 类型检查和多态

在享用静态语言类型检查带来的安全性同时，我们亦会感觉被捆住了手脚。静态类型的面向对象语言通常被设计为可以**向上转型**：当给一个变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类。

##### 1.2.4 使用继承得到多态效果

##### 1.2.5 JavaScript的多态

归根结底先要消除类型之间的耦合关系。在JavaScript中，并不需要诸如向上转型之类的技术来得到多态效果（能力检测）。

##### 1.2.6 多态在面向对象程序设计中的作用

多态最根本的作用就是通过把过程化的条件分支语句转化成对象的多态性，从而消除这些条件分支语句。将行为分布在各个对象中，并让这些对象各自负责自己的行为，这正是面向对象设计的优点。

##### 1.2.7 设计模式与多态

在JavaScript中，函数本身也是对象，函数涌来封装行为且能被四处传递，很多设计模式在JavaScript中可以用高阶函数来代替实现的原因。

#### 1.3 封装

我们讨论的封装是封装数据和封装实现，还包括封装类型和封装变化。

##### 1.3.1 封装数据

在JavaScript中职能依赖变量的作用域来实现封装特性（`private`、`public`），而且只能模拟出`public`和`private`这两种封装性。

##### 1.3.2 封装实现

封装不仅隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。封装使得对象之间的耦合变得松散，对象之间只通过暴露的API接口来通讯，可以随意修改对象的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。

##### 1.3.3 封装类型

把对象的真正类型隐藏在抽象类和接口之后，对比对象的类型，客户更关心对象的行为。而在JavaScript中，并没有对抽象类和接口的支持，不过，不区分类型是一种失色，也可以说是一种解脱。

##### 1.3.4 封装变化

使用设计模式的意义在于你怎样才能在不重新设计的情况下进行改变。

从意图上分，这23种设计模式分别被划分为：

1. 创建型模式，封装的是创建对象的变化。
2. 结构型模式，封装的是对象之间的组合关系。
3. 行为型模式，封装的是对象的行为变化。

#### 1.4 原型模式和基于原型继承的JavaScript对象系统

一开始没有打算在JavaScript中加入类的概念。

在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。

##### 1.4.1 使用克隆的原型模式

ECMAScript 5提供了`Object.create`方法来克隆对象：

    var clonePlane = Objcet.create(plane)

模拟`Object.create`：

    Object.create = Object.create || function (obj) {
      var F = function () {}
      F.prototype = obj
      return new F()
    }

##### 1.4.2 克隆是创建对象的手段

原型模式的真正目的并非在于需要得到一个一模一样的对象，而是提供了一种便捷的方式去创建某个类型的对象，克隆只是创建对象的过程和手段。通过克隆对象，我们就不用关心对象的具体类型名字。

##### 1.4.3 体验Io语言

JavaScript就是使用原型模式来搭建整个面向对象系统的。

##### 1.4.4 原型编程范例的一些规则

Io语言中最初只有一个根对象`Object`，其他所有的对象都克隆自另外一个对象。

原型编程的一个重要特性：当某个对象无法响应某个请求时，会把该请求委托给它自己的原型。

##### 1.4.5 JavaScript中的原型继承

###### 1. 所有数据都是对象

JavaScript引入了两套类型机制：基本类型和对象类型。我们不能说在JavaScript中所有的数据都是对象，但可以说绝大部分数据都是对象。我们在JavaScript遇到的每个对象，实际上都是从`Object.prototype`对象克隆而来的。

###### 2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它

我们只需要显式调用`var obj = new Object()`或者`var obj = {}`，就会从`Object.prototype`上面克隆一个对象出来。

用`new`运算符来创建对象的过程，实际上也只是先克隆`Object.prototype`对象，再进行一些其他额外操作的过程。

###### 3. 对象会记住它的原型

某个对象的`__proto__`属性默认会向它的构造器的原型对象，即`{Constructor}.prototype`。

###### 4. 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型

对象的构造器的原型并不仅限于`Object.prototype`，而是可以动态指向其他对象，可以形成原型链。当在｀Object.prototype`上都无法响应该请求的时候会返回`undefined`。

##### 1.4.6 原型继承的未来

**如果要使用设计模式，不如去找一门更好的语言**。

通过`Object.create`来创建对象的效率并不高，通常比通过构造函数创建对象要慢。除了根对象`Object.prototype`本身之外，任何对象都会有一个原型。

ECMAScript 6带来的`Class`语法的背后仍是通过原型模式来创建对象：

    class Animal {
      constructor(name) {
        this.name = name
      }
      getName() {
        return this.name
      }
    }

    Class Dog extends Animal {
      construcotr(name) {
        super(name)
      }
      speak() {
        return 'woof'
      }
    }

    var dog = new Dog('Scamp')
    console.log(dog.getName() + ' says ' + dog.speak())
