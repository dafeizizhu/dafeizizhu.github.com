<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>dafeizizhu</title>
 <link href="http://username.github.com/atom.xml" rel="self"/>
 <link href="http://username.github.com"/>
 <updated>2013-08-22T20:35:17+08:00</updated>
 <id>http://username.github.com</id>
 <author>
   <name>Zhiying.Mai</name>
   <email>Zhiying.Mai@gmail.com</email>
 </author>

 
 <entry>
   <title>document write</title>
   <link href="http://username.github.com/2013/08/21/document-write"/>
   <updated>2013-08-21T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/21/document-write</id>
   <content type="html"></content>
 </entry>
 
 <entry>
   <title>jQuery源码解析之jQuery.Callbacks</title>
   <link href="http://username.github.com/2013/08/20/jquery-callbacks-source-code"/>
   <updated>2013-08-20T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/20/jquery-callbacks-source-code</id>
   <content type="html">&lt;p&gt;昨天介绍了&lt;code&gt;jQuery.Callbacks&lt;/code&gt;方法，今天简单看一下它的源码。github上的代码链接&lt;a href='https://github.com/jquery/jquery/blob/master/src/callbacks.js'&gt;在这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;jQuery的主干已经是2.0版本了。几乎每个文件的开始都是按照以下的形式给出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([
  &amp;quot;./core&amp;quot;,
  &amp;quot;./var/rnotwhite&amp;quot;
], function( jQuery, rnotwhite ) {&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过一个全局的&lt;code&gt;define&lt;/code&gt;函数，实现类似于node的依赖管理。现在还没有看&lt;code&gt;define&lt;/code&gt;的源码，可以猜测第一个参数就是这个js文件（模块）的依赖，而这个模块的逻辑都被封装在第二个匿名函数的闭包里面。&lt;/p&gt;

&lt;p&gt;首先是一个工具方法，解析&lt;code&gt;jQuery.Callbacks&lt;/code&gt;方法传入的参数，即各种flag。这里有一个性能优化点，&lt;code&gt;Callbacks&lt;/code&gt;方法会以每次调用的字符串参数作为key，解析的结果作为value缓存起来，下次使用同样的字符串调用&lt;code&gt;jQuery.Callbacks&lt;/code&gt;就可以省去解析参数的过程了。&lt;/p&gt;

&lt;p&gt;这个方法的核心就是返回的对象，这个对象的核心就是&lt;code&gt;fire&lt;/code&gt;、&lt;code&gt;add&lt;/code&gt;和&lt;code&gt;remove&lt;/code&gt;等方法。&lt;/p&gt;

&lt;p&gt;首先来看一个工具函数&lt;code&gt;fire&lt;/code&gt;，&lt;code&gt;Callbacks&lt;/code&gt;对象上的&lt;code&gt;fire&lt;/code&gt;跟&lt;code&gt;fireWidth&lt;/code&gt;这两个方法都是基于这个工具函数的。这个工具函数会递归调用自己，并每次更改&lt;code&gt;fire&lt;/code&gt;的索引来遍历整个回调列表。这里关注一下递归的结束条件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( stack ) {
  if ( stack.length ) {
    fire( stack.shift() );
  }
} else if ( memory ) {
  list = [];
} else {
  self.disable();
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;stack&lt;/code&gt;这个变量很有意思。当&lt;code&gt;once&lt;/code&gt;标志生效时，这个&lt;code&gt;stack&lt;/code&gt;永远都为&lt;code&gt;false&lt;/code&gt;。如果&lt;code&gt;once&lt;/code&gt;标志不生效，这个&lt;code&gt;stack&lt;/code&gt;就是作为在&lt;code&gt;fire&lt;/code&gt;的过程中，再调用&lt;code&gt;fire&lt;/code&gt;时的一个类似于消息队列的东西。第一个逻辑是判断是否有消息队列，如果有则从消息队列中取出一个消息递归调用&lt;code&gt;fire&lt;/code&gt;本身。如果没有消息队列，说明&lt;code&gt;stack&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;，这时也有两种情况。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;memory&lt;/code&gt;标志生效，则把&lt;code&gt;list&lt;/code&gt;重置为空数组，接受下一次的&lt;code&gt;add&lt;/code&gt;操作。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;memory&lt;/code&gt;标志不生效，则说明个只有&lt;code&gt;once&lt;/code&gt;标志生效，禁用这个&lt;code&gt;Callbacks&lt;/code&gt;对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第二个要关注的方法就是&lt;code&gt;add&lt;/code&gt;，负责添加回调到&lt;code&gt;Callbacks&lt;/code&gt;对象上面。这个方法支持传入参数的方式有很多种：可以是简单的一个方法，也可以是一个方法的数组，也可以是前两者的混搭，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var cbs = $.Callbacks();
cbs.add(fn);
cbs.add([fn1, fn2, fn3]);
cbs.add(fn, fn1, [fn2, fn3, fn4]);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要实现这种机制，需要一个递归去遍历&lt;code&gt;arguments&lt;/code&gt;。判断&lt;code&gt;arguments&lt;/code&gt;中的每个参数的类型：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果是方法，直接加到回调列表&lt;code&gt;list&lt;/code&gt;中。&lt;/li&gt;

&lt;li&gt;如果是一个类似数组的东西，递归调用&lt;code&gt;add&lt;/code&gt;（实现中是一个内部的匿名函数）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过这个机制就可以把上面三种类型的参数传入方式都解析出来，提取对应的回调，并添加到回调列表里面。再关注一下最后的几行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Do we need to add the callbacks to the
// current firing batch?
if ( firing ) {
  firingLength = list.length;
// With memory, if we&amp;#39;re not firing then
// we should call right away
} else if ( memory ) {
  firingStart = start;
  fire( memory );
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，&lt;code&gt;fire&lt;/code&gt;的时候也可以调用&lt;code&gt;add&lt;/code&gt;。如果正处在&lt;code&gt;fire&lt;/code&gt;的过程中（&lt;code&gt;firing === true&lt;/code&gt;），需要把要遍历的回调列表长度调整到调用&lt;code&gt;add&lt;/code&gt;之后的长度。如果不在&lt;code&gt;fire&lt;/code&gt;过程中，则要判断&lt;code&gt;memory&lt;/code&gt;标志是否生效，生效则需要重新触发&lt;code&gt;fire&lt;/code&gt;，保证刚增加的回调函数能顺利执行。&lt;/p&gt;

&lt;p&gt;最后再关注一下&lt;code&gt;remove&lt;/code&gt;方法，这里值得注意的也是&lt;code&gt;fire&lt;/code&gt;过程中的&lt;code&gt;remove&lt;/code&gt;。需要判断当前删除的回调是否已经执行，代码片段如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Handle firing indexes
if ( firing ) {
  if ( index &amp;lt;= firingLength ) {
    firingLength--;
  }
  if ( index &amp;lt;= firingIndex ) {
    firingIndex--;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Callbacks&lt;/code&gt;对象还有其他方法，例如&lt;code&gt;has&lt;/code&gt;、&lt;code&gt;empty&lt;/code&gt;、&lt;code&gt;disable&lt;/code&gt;、&lt;code&gt;lock&lt;/code&gt;，还有几个获取状态的方法，这里就不详细展开了，有兴趣的同鞋可以参考上面的github上的链接看其他的源码。不得不佩服jQuery为了满足各种各样的场景而写出这样完备的代码，在日常工作中，我个人还是觉得应该根据具体的应用场景去考虑代码的健壮性，如果每一个功能、每一段代码都得像jQuery那样严谨完备，的确是件十分美妙的事情，工作往往是更现实的事情，各种无奈就不多展开了啊！&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>jQuery.Callbacks</title>
   <link href="http://username.github.com/2013/08/19/jquery-callbacks"/>
   <updated>2013-08-19T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/19/jquery-callbacks</id>
   <content type="html">&lt;p&gt;今天第一天入职，就听到&lt;code&gt;jQuery.Callbacks&lt;/code&gt;这个方法。使用这个方法可以实现功能强大的观察者模式。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A multi-purpose callbacks list object that provides a powerful way to manage callback lists.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个方法是&lt;code&gt;jQuery.ajax&lt;/code&gt;和&lt;code&gt;jQuery.Deffered&lt;/code&gt;的内部实现呢。今天先不看代码，先简单看看这个方法是怎么使用的。这个方法接受一个参数&lt;code&gt;flag&lt;/code&gt;，可选的值有以下几个或者这几个的组合（之间用空格隔开）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;once&lt;/code&gt;，保证相关的绑定的回调只会调用一次。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;memory&lt;/code&gt;，这个是一个相当有趣的标志。当先触发，再绑定的情况下绑定的回调照样会执行！&lt;/li&gt;

&lt;li&gt;&lt;code&gt;unique&lt;/code&gt;，保证每个回调函数只能被绑定一次。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;stopOnFalse&lt;/code&gt;，当任何一个回调函数返回&lt;code&gt;false&lt;/code&gt;的时候停止其他回调函数的执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;执行这个方法后会返回一个&lt;code&gt;Callbacks&lt;/code&gt;类型的对象。该对象有几个比较重要的方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;add&lt;/code&gt;，绑定回调，可以绑定单个函数或者绑定一个函数的数组。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;remove&lt;/code&gt;，解除绑定，接受的参数与&lt;code&gt;add&lt;/code&gt;一致。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;fire&lt;/code&gt;，触发回调，传入的参数也会传入到每一个回调函数里面。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;disable&lt;/code&gt;，不接受参数，禁用该对象，&lt;code&gt;fire&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt;等都被禁用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用&lt;code&gt;jQuery.Callbacks&lt;/code&gt;可以实现一个观察者模式。下面是jQuery文档里面的一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var topics = {};

jQuery.Topic = function( id ) {
  var callbacks,
    method,
    topic = id &amp;amp;&amp;amp; topics[ id ];
  
  if ( !topic ) {
    callbacks = jQuery.Callbacks();
    topic = {
      publish: callbacks.fire,
      subscribe: callbacks.add,
      unsubscribe: callbacks.remove
    };
    if ( id ) {
      topics[ id ] = topic;
    }
  }
  return topic;
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方法为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Subscribers
$.Topic( &amp;quot;mailArrived&amp;quot; ).subscribe( fn1 );
$.Topic( &amp;quot;mailArrived&amp;quot; ).subscribe( fn2 );
$.Topic( &amp;quot;mailSent&amp;quot; ).subscribe( fn1 );

// Publisher
$.Topic( &amp;quot;mailArrived&amp;quot; ).publish( &amp;quot;hello world!&amp;quot; );
$.Topic( &amp;quot;mailSent&amp;quot; ).publish( &amp;quot;woo! mail!&amp;quot; );&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;a href='http://jsfiddle.net/x5NNQ/'&gt;参考这里&lt;/a&gt;。明天继续围观相关jQuery的源码！&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Secrets of the JavaScript Ninja 读书笔记之 使用定时器</title>
   <link href="http://username.github.com/2013/08/18/javascript-timer-usage"/>
   <updated>2013-08-18T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/18/javascript-timer-usage</id>
   <content type="html">&lt;p&gt;继续周末读书时间。昨天讨论了定时器的基本原理，今天来看看定时器在实际使用中能做些什么有趣的事情。&lt;/p&gt;

&lt;h3 id='id38'&gt;连续执行耗时任务&lt;/h3&gt;

&lt;p&gt;在某些应用场景中，需要对一大堆数据进行处理（例如根据数据渲染表格，数据量超过1000+条）。如果仅仅用一个&lt;code&gt;for&lt;/code&gt;循环对每一个数据项进行处理，由于整个处理的过程都是同步的，而JavaScript的处理线程（包括浏览器渲染、事件处理等）是单线程的，这样连续的同步操作会导致浏览器没有办法对用户的操作进行响应，某些浏览器（例如FireFox），在超过特定的时间内执行的JavaScript代码，会弹出提示框提示用户是否继续执行这些操作。这样的用户体验是相当糟糕的。那么如何在处理这一大堆数据的同时，也不让浏览器弹出类似的提示框呢？&lt;/p&gt;

&lt;p&gt;我们可以利用定时器把这一系列的同步操作分割成多个异步操作连续执行，在每个异步操作执行的间隔，把JavaScript线程空闲出来处理浏览器另外的事务。可以抽象出这样一个方法，对大数据（一般是&lt;code&gt;length&lt;/code&gt;相当长的数组）进行分段操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function asyncProcess(data, fn, complete, blockSize, timeout, context) {
  data = data || [];
  fn = fn || function () {};
  blockSize = blockSize || data.length;
  timeout = timeout || 200;
  complete = complete || function () {};

  var index = tId = 0;

  function process() {
    var block = data.slice(index, index + blockSize);
    for (var i = 0; i &amp;lt; block.length; i++) {
      fn.call(context, block[i]);
    }
    if (index + blockSize &amp;gt; data.length) {
      complete.call(context);
      clearTimeout(tId);
    } else {
      index = index + blockSize;
      tId = setTimeout(process, timeout);
    }
  }

  tId = setTimeout(process, timeout);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在处理好每次分段处理的数据量之后，再也不会担心浏览器弹出那些讨厌的对话框了！例子&lt;a href='http://jsfiddle.net/bVjxX/1/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id='id39'&gt;统一控制的定时器&lt;/h3&gt;

&lt;p&gt;当一个功能比较简单的时候，可能仅仅需要一个或者两个定时器就能完成对应的功能。但是，随着需求的增加，可能会不断地往页面中添加定时器。当定时器的数量不断增多的时候，整个页面的定时器就越来越难管理起来。更多的定时器也意味着要处理更多相关的撤销代码、内存问题等。&lt;/p&gt;

&lt;p&gt;应该尽量减少定时器的数量。能否用一个定时器，通过增加、删除对应的处理逻辑来实现相关的增加、撤销定时器的功能？统一控制的定时器就是为了解决这个问题。统一控制的定时器有下列特点：&lt;/p&gt;

&lt;p&gt;1. 只有一个定时器实例。 2. 可以随时启停定时器。 3. 简化删除一个“定时器”的逻辑。&lt;/p&gt;

&lt;p&gt;以下是实现这个定时器的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var timers = {                               
  timerID: 0,                                           
  timers: [],                                           
  add: function(fn) {                            
    this.timers.push(fn);
  },
  start: function() {                             
    if (this.timerID) return;
    (function runNext() {
      if (timers.timers.length &amp;gt; 0) {
        for (var i = 0; i &amp;lt; timers.timers.length; i++) {
          if (timers.timers[i]() === false) {
            timers.timers.splice(i,1);
            i--;
          }
        }
        timers.timerID = setTimeout(runNext, 0);
      }
    })();
  },
  stop: function() {                                  
    clearTimeout(this.timerID);
    this.timerID = 0;
  }
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过对应的&lt;code&gt;start&lt;/code&gt;和&lt;code&gt;stop&lt;/code&gt;来实现定时器的启停。通过&lt;code&gt;add&lt;/code&gt;增加一个“定时器”。通过在“定时器”逻辑中返回&lt;code&gt;false&lt;/code&gt;来删除这个“定时器”。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Secrets of the JavaScript Ninja 读书笔记之 定时器是怎么运作的</title>
   <link href="http://username.github.com/2013/08/17/javascript-timer"/>
   <updated>2013-08-17T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/17/javascript-timer</id>
   <content type="html">&lt;p&gt;又到周末读书的时间啦！今天分享一下书中关于定时器的一些简单的原理。&lt;/p&gt;

&lt;h3 id='id36'&gt;创建、撤销定时器&lt;/h3&gt;

&lt;p&gt;在JavaScript中，定时器有两种。一种是Timeout，只会在设置的时间之后执行一次。另一种是Interval，会以设置的时间为周期反复执行。有两个创建定时器的方法与之对应：&lt;code&gt;setTimeout&lt;/code&gt;和&lt;code&gt;setInterval&lt;/code&gt;。这两个方法都接受两个参数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;执行的代码，这个参数可以是一个匿名函数、一个函数的引用，甚至是一段以字符串形式表示的JavaScript代码。 2. 设置的时间。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个参数都会返回一个&lt;code&gt;id&lt;/code&gt;，通过这个&lt;code&gt;id&lt;/code&gt;可以调用对应的&lt;code&gt;clearTimeout&lt;/code&gt;和&lt;code&gt;clearInterval&lt;/code&gt;撤销对应的定时器。撤销之后（Timeout必须在设置事件之前撤销）指定的代码将不会被执行。虽然有些浏览器可以用&lt;code&gt;clearTimeout&lt;/code&gt;去撤销&lt;code&gt;setInterval&lt;/code&gt;或者用&lt;code&gt;clearInterval&lt;/code&gt;去撤销&lt;code&gt;setTimeout&lt;/code&gt;，但是&lt;strong&gt;强烈建议创建跟撤销的方法配对使用&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id='id37'&gt;定时器执行&lt;/h3&gt;

&lt;p&gt;记住一点，&lt;strong&gt;在定时器中设置的时间并不是精确的&lt;/strong&gt;。例如以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setTimeout(fn, 10);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fn&lt;/code&gt;并不一定在10毫秒之后被调用。这个是跟JavaScript是单线程处理有关。每一个时刻只有一段JavaScript代码被执行。在设置完定时器之后，可能有一段耗时超过10毫秒的代码一直在执行，也可能用户在这10毫秒之内频繁与浏览器进行交互，导致对应的事件处理程序不断被触发等。所以，尤其是Interval，这个时间并不是精确的。&lt;/p&gt;

&lt;h3 id='timeoutinterval'&gt;Timeout跟Interval的区别&lt;/h3&gt;

&lt;p&gt;最大的区别肯定是Timeout只执行一次，而Interval则会周期执行，一个Interval可以看作是一个不断Timouet不断地重复。其实它们之间还有很多不一样的地方，当设置时间到达之后还有代码在执行导致定时器发生延时：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Timeout会一直延迟直到JavaScript线程空闲的时候立即执行。这个行为导致&lt;code&gt;setTimeout&lt;/code&gt;代码执行的间隔时间只会比设置的事件要长，而不可能会短。&lt;/li&gt;

&lt;li&gt;Interval先会查找执行队列中有没有要执行代码的实例，如果没有，则会在执行队列中对应的位置插入要执行的代码。如果已经存在了，则不会再次插入要执行代码的实例。所以，当执行被延时，队列中只会存在一份要执行代码的实例。当JavaScript线程空闲的时候，代码从队列中出队，当设置的时间又到的时候，又会在执行队列中插入对应的代码实例。由于这种机制，如果在代码出队之后，设置周期又到了，这之间的时间可能会比设置时间要短，这时Interval真正执行的周期就比设置的时间要短。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面说的这么多，可能没说清楚……但是只要记住一个点就可以了，就是&lt;strong&gt;Timeout执行的延迟永远只能更长，而Interval执行的周期则有可能比设置的时间更短&lt;/strong&gt;。使用&lt;code&gt;setTimeout&lt;/code&gt;多次重复调用来模拟&lt;code&gt;setInterval&lt;/code&gt;的效果可以避免在一个周期内重复调用对应的代码超过一次，当执行的周期不是要求十分精确的时候（虽然&lt;code&gt;setInterval&lt;/code&gt;也不能保证太精确，但是周期肯定会比反复调用&lt;code&gt;setTimeout&lt;/code&gt;要稳定，如果代码能在设置的时间之内执行完），可以考虑使用反复调用&lt;code&gt;setTimeout&lt;/code&gt;来代替&lt;code&gt;setInterval&lt;/code&gt;进行周期性的任务。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>响应式设计入门之media query</title>
   <link href="http://username.github.com/2013/08/16/css-media-query"/>
   <updated>2013-08-16T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/16/css-media-query</id>
   <content type="html">&lt;p&gt;今天再简单介绍一下响应式设计中的另外一个比较重要的技术，媒体查询media query。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A media query consists of a media type and at least one expression that limits the style sheets&amp;#8217; scope by using media features, such as width, height, and color. Media queries, added in CSS3, let the presentation of content be tailored to a specific range of output devices without having to change the content itself.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;相比HTML4和CSS2中，只能根据特定的媒体类型（例如屏幕、打印机等）选择应用不同的样式，在CSS3中，可以利用更多的属性进行判断，例如宽度、高度还有颜色等。因此，可以根据当前设备的分辨率等要素，决定整个页面的布局以及应用特定的样式，从而让页面能够适应不同的设备以及不同的分辨率。&lt;/p&gt;

&lt;p&gt;CSS3中的媒体查询跟CSS2中的使用方式一样，有以下两种方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; media=&amp;quot;(max-width: 800px)&amp;quot; href=&amp;quot;example.css&amp;quot; /&amp;gt; // 在link标签上声明媒体查询&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者在样式文件或者内联的style标签中声明媒体查询：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
@media (max-width: 600px) {
  .facet_sidebar {
    display: none;
  }
}
&amp;lt;/style&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;媒体查询表达式由属性还有其可选的值组成，属性与值之间用&lt;code&gt;:&lt;/code&gt;分隔。日常使用中常用的属性有下列几个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;width&lt;/code&gt;和&lt;code&gt;device-width&lt;/code&gt;，分别代表页面渲染的宽度和设备宽度。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;height&lt;/code&gt;和&lt;code&gt;device-height&lt;/code&gt;，分别代表页面渲染的宽度和设备宽度。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;resolution&lt;/code&gt;，设备的分辨率。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;device-aspect-ratio&lt;/code&gt;，设备的宽高比。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;orientation&lt;/code&gt;，设备当前是横屏模式还是竖屏模式，分别对应常量&lt;code&gt;portrait&lt;/code&gt;和&lt;code&gt;landscape&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体的属性列表可以&lt;a href='https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Media_queries#Media_features'&gt;参考这里&lt;/a&gt;。上面的高度、宽度、分辨率等大部分基于像素的属性都可以通过&lt;code&gt;min-&lt;/code&gt;或者&lt;code&gt;max-&lt;/code&gt;前缀来声明一个范围。例如声明设别的最大宽度为1024像素的媒体查询表达式为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;max-width: 1024px&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多个媒体查询的表达式可以进行逻辑运算，分别使用&lt;code&gt;and&lt;/code&gt;，逗号分隔列表和&lt;code&gt;not&lt;/code&gt;进行与、或、非三个逻辑运算。例如以下媒体查询：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@media tv and (min-width: 700px) and (orientation: landscape) &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当设备类型为&lt;code&gt;tv&lt;/code&gt;，设备最小宽度为700像素并且屏幕方向是竖向时生效。&lt;/p&gt;

&lt;p&gt;IE9以下不支持CSS3媒体查询。不过幸好要使用媒体查询的场景多是在移动终端上使用，而这些设备上的浏览器（iOS的Safari、Andriod的webkit核心）一般都支持CSS3媒体查询，所以在响应式设计中大胆地使用它吧！&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href='http://www.w3.org/TR/css3-mediaqueries/'&gt;Media Queries&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Media_queries'&gt;CSS media queries&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.qianduan.net/media-type-and-media-query.html'&gt;media type与media query&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content>
 </entry>
 
 <entry>
   <title>IE条件注释</title>
   <link href="http://username.github.com/2013/08/15/ie-conditional-comment"/>
   <updated>2013-08-15T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/15/ie-conditional-comment</id>
   <content type="html">&lt;p&gt;IE条件注释提供了一个浏览器端的手段，去做浏览器检测。这个手段不需要去判断&lt;code&gt;window.navigator&lt;/code&gt;，所以不用担心各种&lt;code&gt;navigator&lt;/code&gt;的篡改。但是这个手段目前只能用在IE上，但是，这不就已经够了吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意，IE10已经不支持条件注释了&lt;/strong&gt;。但是貌似IE10已经向W3的规范靠拢了，影响应该不大。&lt;/p&gt;

&lt;p&gt;IE的条件注释原来有两种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不支持条件注释的浏览器不显示：&lt;code&gt;&amp;lt;!--[if IE 8]&amp;gt;...&amp;lt;![endif]--&amp;gt;&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;不支持条件注释的浏览器显示：&lt;code&gt;&amp;lt;![if IE 8]&amp;gt;...&amp;lt;![endif]&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原理很简单，由于前者跟HTML的注释要求的格式是一样的，所以在不支持条件注释的浏览器会认为这个是一个HTML的注释，不会解析里面的HTML片段。而后者则是被认为是一个HTML标签（虽然明显不符合XML的规范……），就会解析里面的HTML片段。&lt;/p&gt;

&lt;p&gt;前者可以为判断IE的版本决定是否需要加入额外的HTML、CSS、JavaScript来提供完整的功能，如在IE9以下的版本使用&lt;code&gt;canvas&lt;/code&gt;，增加&lt;code&gt;exCanvas&lt;/code&gt;的引用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--[if lt IE 9]&amp;gt;&amp;lt;script language=&amp;quot;javascript&amp;quot; type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;excanvas.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;![endif]--&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后者可以提示一些非特定版本IE的用户使用特定版本IE，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;![if lt IE 8]&amp;gt;
&amp;lt;p&amp;gt;Please upgrade to Internet Explorer version 8.&amp;lt;/p&amp;gt;
&amp;lt;![endif]&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再来看看条件注释里面的表达式，由&lt;code&gt;if&lt;/code&gt;以及后面的条件表达式组成。条件表达式有三种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;IE&lt;/code&gt;，判断IE的版本，主版本使用整数表示，如果包含小版本则使用浮点数表示，如：&lt;code&gt;IE 5.5000&lt;/code&gt;表示IE 5.5。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;WindowsEdition&lt;/code&gt;，判断浏览器运行的Windows的版本。对应的值&lt;a href='http://msdn.microsoft.com/en-us/library/ms724358(v=vs.85).aspx'&gt;参考这里&lt;/a&gt;。&lt;/li&gt;

&lt;li&gt;布尔值，&lt;code&gt;true&lt;/code&gt;或者&lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;判断版本的时候可以使用以下几个操作符：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;lt&lt;/code&gt;或者&lt;code&gt;lte&lt;/code&gt;，判断是否小于或者小于等于特定版本。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;gt&lt;/code&gt;或者&lt;code&gt;gte&lt;/code&gt;，判断是否大于或者大于等于特定版本。 3. 条件以及条件之间可以通过运算符&lt;code&gt;!&lt;/code&gt;、&lt;code&gt;|&lt;/code&gt;、&lt;code&gt;&amp;amp;&lt;/code&gt;进行逻辑运算。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一个比较有趣的就是可以在IE的插件里面判断当前插件的版本！在安装插件的时候为注册表增加以下的键值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HKEY_LOCAL_MACHINE
  Software
    Microsoft
      Internet Explorer
        Version Vector
          Contoso = 0.9&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在插件里面可以通过以下条件注释来判断当前插件的版本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--[if lt Contoso 2]&amp;gt;
&amp;lt;p&amp;gt;Your version of the Contoso control is out of date; Please update to the latest.&amp;lt;/p&amp;gt;
&amp;lt;![endif]--&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;严格来说，使用IE条件注释也算是CSS hack的一种。相对于其他CSS hack是使用浏览器的bug实现的，这个方式算是比较靠谱的一个方式，毕竟这个不是浏览器的bug，而是浏览器提供的一种做浏览器检测的手段。如果涉及的兼容性问题只出现在各种不同版本的IE里面，为了提高代码的可读性，可以把各种fixed的代码抽取到一个外部样式表中，再使用条件注释，指示特定版本的IE加载该外部样式表。如果涉及的问题还出现在FireFox、Chrome、Safari等浏览器中，那还得考虑除了条件注释之外的css hack。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>DOM 的removeAttribute方法</title>
   <link href="http://username.github.com/2013/08/14/dom-removeattribute"/>
   <updated>2013-08-14T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/14/dom-removeattribute</id>
   <content type="html">&lt;p&gt;今天是Attribute系列的最后一篇。前面两篇讨论了如何获取、增加、修改一个DOM元素的特性。今天轻松一下，把删除讨论完。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;removeAttribute removes an attribute from the specified element.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;removeAttribute&lt;/code&gt;的功能很简单，就是删除指定名称的特性。该方法只接受一个参数，就是指定特性名称的字符串。以下是一个使用的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.getElementById(&amp;quot;div1&amp;quot;).removeAttribute(&amp;quot;align&amp;quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;昨天也讨论过类似的例子，就是如果需要删除一个特性的话，使用&lt;code&gt;removeAttribute&lt;/code&gt;比使用&lt;code&gt;setAttribute&lt;/code&gt;把该特性置成&lt;code&gt;null&lt;/code&gt;或者空字符串要好。尝试删除一个不存在的特性不会抛出任何异常。&lt;/p&gt;

&lt;p&gt;既然用&lt;code&gt;setAttribute&lt;/code&gt;可以为一个DOM元素绑定事件处理程序，那么对应使用&lt;code&gt;removeAttribute&lt;/code&gt;也可以解除事件绑定，如以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;test&amp;quot; onclick=&amp;quot;alert(1);&amp;quot;&amp;gt;Test&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.getElementById(&amp;quot;test&amp;quot;).removeAttribute(&amp;quot;onclick&amp;quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单击该&lt;code&gt;div&lt;/code&gt;元素不会弹出消息框。可惜IE7又再一次华丽地失败了。例子&lt;a href='http://jsfiddle.net/PnKh6/show/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;最后一个要注意的点是，如果删除的特性有默认值，则调用&lt;code&gt;removeAttribute&lt;/code&gt;删除该特性之后会把该特性重置成该特性的默认值，如以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input id=&amp;quot;test&amp;quot; type=&amp;quot;radio&amp;quot; value=&amp;quot;hello&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var test = document.getElementById(&amp;quot;test&amp;quot;);
test.removeAttribute(&amp;quot;type&amp;quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Chrome上，执行完以上的代码，该&lt;code&gt;input&lt;/code&gt;会变成一个输入框，并有默认值&lt;code&gt;hello&lt;/code&gt;显示在里面。该例子在IE7、IE8上执行失败，仍然是一个&lt;code&gt;radio&lt;/code&gt;，而在IE9上，虽然变成了输入框，但是默认值&lt;code&gt;hello&lt;/code&gt;没有显示在里面。P.S. 我们日常也不会这么用，这里当作一个小偏门知识介绍给大家吧。&lt;/p&gt;

&lt;p&gt;关于Attribute，我们日常还是会依赖于jQuery去做相关的操作，包括&lt;code&gt;attr&lt;/code&gt;、&lt;code&gt;prop&lt;/code&gt;、&lt;code&gt;data&lt;/code&gt;等，看来一篇jQuery源码分析又要来啦！&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>DOM的setAttribute方法</title>
   <link href="http://username.github.com/2013/08/13/dom-setattribute"/>
   <updated>2013-08-13T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/13/dom-setattribute</id>
   <content type="html">&lt;p&gt;昨天讨论了&lt;code&gt;getAttribute&lt;/code&gt;，今天继续讨论&lt;code&gt;setAttribute&lt;/code&gt;的使用方法。&lt;/p&gt;

&lt;h3 id='id35'&gt;标准&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Adds a new attribute or changes the value of an existing attribute on the specified element.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;setAttribute&lt;/code&gt;这个方法就是用来增加或者修改一个DOM元素上的特性（Attribute）。当指定名称的特性不存在，则会新增一个该名称的特性；如果该特性已经存在，则会修改现有特性的值。这个方法接受两个参数：&lt;/p&gt;

&lt;p&gt;1. 表示特性名称的字符串。 2. 这个特性的新的值。当传入的参数不是字符串的时候会隐式调用参数的&lt;code&gt;toString&lt;/code&gt;方法。例子&lt;a href='http://jsfiddle.net/7Tenq/'&gt;参考这里&lt;/a&gt;。IE7貌似有不一样的行为，下面会提到。&lt;/p&gt;

&lt;p&gt;使用的例子如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var d = document.getElementById(&amp;quot;d1&amp;quot;); 
d.setAttribute(&amp;quot;align&amp;quot;, &amp;quot;center&amp;quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与&lt;code&gt;getAttribute&lt;/code&gt;类似，在HTML DOM里面&lt;code&gt;setAttribute&lt;/code&gt;也是大小写不敏感的。当需要删除一个特性的时候不应该使用&lt;code&gt;setAttribute(&amp;quot;someAttr&amp;quot;, null)&lt;/code&gt;，而是应该使用&lt;code&gt;removeAttribute&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id='ie'&gt;又是IE&lt;/h3&gt;

&lt;p&gt;与&lt;code&gt;getAttribute&lt;/code&gt;类似，IE7以及更早的版本有一套自己的实现。在比较早的IE的版本又可以传入第三个参数：&lt;code&gt;lflag&lt;/code&gt;，这个标志位接受以下两个值：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt;，默认值，对特性的名称大小写不敏感。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;1&lt;/code&gt;，对特性的名称是大小写敏感的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同样，在IE8之前的版本特性（Attribute）与属性（Property）的名称必须一致（例如&lt;code&gt;className&lt;/code&gt;等）、在IE8以及更高版本的IE上第三个参数已经不支持了，不要使用。这个方法甚至可以绑定事件处理程序，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.getElementById(&amp;quot;test&amp;quot;).setAttribute(&amp;#39;onclick&amp;#39;, &amp;#39;alert(1)&amp;#39;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经测试，IE7不支持，例子&lt;a href='http://jsfiddle.net/M3PLw/2/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;有一个比较有趣的现象，就是第二个参数&lt;code&gt;val&lt;/code&gt;的取值类型。标准里面应该是传入字符串的，会隐式调用这个参数的&lt;code&gt;toString&lt;/code&gt;方法。但是，在IE7，通过&lt;code&gt;getAttribute&lt;/code&gt;返回的特性值与标准实现是不一样的，如以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function test(attr, val) {
  var el = document.getElementById(&amp;quot;test&amp;quot;);
  el.setAttribute(attr, val);
  alert(&amp;quot;Set Attr: &amp;quot; + attr + 
    &amp;quot; value: &amp;quot; + el.getAttribute(attr) + 
    &amp;quot; valute type: &amp;quot; + typeof el.getAttribute(attr));
}

test(&amp;quot;a&amp;quot;, null); // null
test(&amp;quot;b&amp;quot;, undefined); // undefeined
test(&amp;quot;c&amp;quot;, {}); // object
test(&amp;quot;d&amp;quot;, [1, 2, 3]); // Array
test(&amp;quot;e&amp;quot;, /test/); // RegExp
test(&amp;quot;f&amp;quot;, 0); // Number
test(&amp;quot;g&amp;quot;, true); // Boolean&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在IE7上面，通过&lt;code&gt;getAttribute&lt;/code&gt;返回的值的类型竟然跟&lt;code&gt;setAttribute&lt;/code&gt;的第二个参数的类型一样的！而在高版本的IE或者Chrome等现代浏览器里面&lt;code&gt;getAttribute&lt;/code&gt;返回的都是字符串。说明在IE7上，&lt;code&gt;setAttribute&lt;/code&gt;并没有把第二个参数转化成字符串，而是把参数直接存在DOM上面了。例子&lt;a href='http://jsfiddle.net/7Tenq/show/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>DOM的getAttribute方法</title>
   <link href="http://username.github.com/2013/08/12/dom-getattribute"/>
   <updated>2013-08-12T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/12/dom-getattribute</id>
   <content type="html">&lt;p&gt;获取一个DOM元素的特性（Attribute），相信也是一个前端攻城师天天都要涉及的问题。虽然日常我们都被jQuery宠坏了，还是要了解一下原生的应该如何获取一个DOM元素的特性值的方法。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;getAttribute() returns the value of the named attribute on the specified element.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;getAttribute&lt;/code&gt;返回特定DOM元素上的特性的值。该方法接受一个参数，就是表示特性的名称的字符串。当该特性存在时返回该特性的字符串的值，否则返回&lt;code&gt;null&lt;/code&gt;或者空字符串。&lt;/p&gt;

&lt;h3 id='id34'&gt;标准&lt;/h3&gt;

&lt;p&gt;调用&lt;code&gt;getAttribute&lt;/code&gt;，传入的代表特性名称的字符串是大小写不敏感的，内部实现先会把参数转换成小写再进行操作。&lt;/p&gt;

&lt;p&gt;大部分浏览器在没有找到该特性值的时候会返回&lt;code&gt;null&lt;/code&gt;，例子&lt;a href='http://jsfiddle.net/GVT4E/'&gt;参考这里&lt;/a&gt;。但是，在DOM 3 Core的标准下应该返回的是&lt;strong&gt;空字符串&lt;/strong&gt;，而某些浏览器是按照标准去实现的。所以，当&lt;code&gt;getAttribute&lt;/code&gt;返回一个空字符串的时候，可能是该特性没有找到，也可能是该特性的值就是一个空字符串。此时，应该使用&lt;code&gt;hasAttribute&lt;/code&gt;去判断一个元素上的某个特性是否存在，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getAttr(test) {
  if (test.hasAttribute(&amp;quot;a&amp;quot;)) {
    alert(&amp;quot;has attribute a, value is &amp;quot; + test.getAttribute(&amp;quot;a&amp;quot;));
  } else {
    alert(&amp;quot;has not attribute a&amp;quot;);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;a href='http://jsfiddle.net/crctX/'&gt;参考这里&lt;/a&gt;。P.S. IE 7不支持&lt;code&gt;hasAttribute&lt;/code&gt;……&lt;/p&gt;

&lt;h3 id='ie'&gt;奇葩的IE&lt;/h3&gt;

&lt;p&gt;IE对&lt;code&gt;getAttribute&lt;/code&gt;有着自己一套实现（这太可怕了……）。在IE7以及之前的版本，&lt;code&gt;getAttribute&lt;/code&gt;接受两个参数：&lt;/p&gt;

&lt;p&gt;1. 需要获取的特性名字的字符串。 2. 一个标志位，规定返回特性值的方式。&lt;/p&gt;

&lt;p&gt;该标志位接受4个值：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt;，默认值，特性名称大小写不敏感，并根据需要转化特性值（例如把&lt;code&gt;href&lt;/code&gt;转成完整的URL）。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;1&lt;/code&gt;，特性名称大小写敏感。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;2&lt;/code&gt;，返回特性值的字符串值，即不做任何转换。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;4&lt;/code&gt;，返回完整的URL对象，仅针对返回URL的特性，如&lt;code&gt;href&lt;/code&gt;、&lt;code&gt;background&lt;/code&gt;等。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一些需要注意的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在IE8之前的版本，特性（Attribute）的名称必须与元素对应的属性（Property）对应。&lt;/li&gt;

&lt;li&gt;在IE8及其之后的版本，第二个参数已经没用了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在IE中，还有一些跟别的浏览器（甚至IE高版本和低版本之间）的区别。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input id=&amp;quot;test&amp;quot; readonly=&amp;quot;readonly&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alert(document.getElementById(&amp;quot;test&amp;quot;).getAttribute(&amp;quot;readonly&amp;quot;));&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上的代码，在IE7以及之前的IE版本返回的是&lt;code&gt;true&lt;/code&gt;，而IE8、IE9、Chrome、Firefox返回的是&lt;code&gt;readonly&lt;/code&gt;这个字符串。例子&lt;a href='http://jsfiddle.net/rSDhp/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;由于IE的特殊实现，导致&lt;code&gt;getAttribute&lt;/code&gt;在某些情况下返回的结果会不一致，例如获取一个&lt;code&gt;a&lt;/code&gt;的&lt;code&gt;href&lt;/code&gt;特性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var href = document.getElementById(&amp;quot;id&amp;quot;).getAttribute(&amp;quot;href&amp;quot;); // 123.html&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Chrome、Firefox、IE8、IE9返回的都是&lt;code&gt;href&lt;/code&gt;特性上面的字符串，而IE7返回的则是完整的URL（例如&lt;code&gt;http://host:port/path/to/123.html&lt;/code&gt;）。要避免这个问题，得在调用&lt;code&gt;getAttribute&lt;/code&gt;中加入第二个参数&lt;code&gt;2&lt;/code&gt;，保证&lt;code&gt;getAttribute&lt;/code&gt;返回的是原始的字符串。例子&lt;a href='http://jsfiddle.net/xEA3B/2/'&gt;参考这里&lt;/a&gt;。P.S. 据说加入第二个参数Opera会崩溃，暂时无法验证……&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Secrets of the JavaScript Ninja 读书笔记之 执行字符串形式的表达式</title>
   <link href="http://username.github.com/2013/08/11/javascript-code-evaluate"/>
   <updated>2013-08-11T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/11/javascript-code-evaluate</id>
   <content type="html">&lt;p&gt;周末还是继续读书笔记。今天讨论的是JavaScript中执行字符串形式的表达式的几种方式。&lt;/p&gt;

&lt;h3 id='eval'&gt;eval&lt;/h3&gt;

&lt;p&gt;这个应该是最简单的执行字符串表达式的方法了。&lt;code&gt;eval&lt;/code&gt;接受一个参数，就是字符串形式的表达式，并返回最后一条语句的返回结果。比较常见的用法就是把JSON格式的字符串转换成JavaScript的对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var o = eval(&amp;#39;({ninja: 1})&amp;#39;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果把圆括号省略，&lt;code&gt;o&lt;/code&gt;的值是&lt;code&gt;undefined&lt;/code&gt;，因为参数语句执行时没有返回任何东西。加上圆括号之后，执行该语句会返回这个对象的值，&lt;code&gt;o&lt;/code&gt;才能正确赋值。&lt;/p&gt;

&lt;p&gt;还有一点需要注意的是&lt;code&gt;eval&lt;/code&gt;中的语句执行的作用域与上下文与调用&lt;code&gt;eval&lt;/code&gt;所在的作用域和上下文一致。&lt;/p&gt;

&lt;h3 id='function'&gt;Function构造器&lt;/h3&gt;

&lt;p&gt;Function构造器的参数列表是可变的。其中最后一个参数是字符串形式的函数逻辑，前面所有参数声明了构造的函数接受哪些参数，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var add = new Function(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;return a + b;&amp;quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与&lt;code&gt;eval&lt;/code&gt;不一样的是，使用Function构造器创建的函数&lt;strong&gt;不会产生闭包&lt;/strong&gt;，即不能访问外部函数的变量，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function () {
  var a = &amp;quot;outter&amp;quot;;
  var test = new Function(&amp;quot;alert(a);&amp;quot;);
  test();
})();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果&lt;a href='http://jsfiddle.net/hdLmt/show/'&gt;参考这里&lt;/a&gt;。运行的时候抛出异常&lt;code&gt;a is not defined&lt;/code&gt;，因为没有创建闭包，导致&lt;code&gt;test&lt;/code&gt;内部无法访问外部函数的变量&lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id='timer'&gt;Timer&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;setTimeout&lt;/code&gt;和&lt;code&gt;setInterval&lt;/code&gt;的第一个参数除了可以是函数（无论是函数的引用或者是匿名函数），也可以是一个字符串，表示timer触发时执行的逻辑，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var tick = window.setTimeout(&amp;#39;alert(&amp;quot;Hi!&amp;quot;)&amp;#39;,100);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了十分特殊的需求，一般都不需要这么使用timer。就算是需要运行时动态执行的逻辑，也可以通过以上两种方式创建函数的引用，在把它传入到&lt;code&gt;setTimeout&lt;/code&gt;或者&lt;code&gt;setInterval&lt;/code&gt;中。&lt;/p&gt;

&lt;h3 id='id32'&gt;在全局作用域中执行&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;eval&lt;/code&gt;执行的代码跟执行&lt;code&gt;eval&lt;/code&gt;所在的作用域是一致的。而有一些时候需要&lt;code&gt;eval&lt;/code&gt;在全局作用域中执行。使用动态script标签可以解决以上的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var head = document.getElementsByTagName(&amp;quot;head&amp;quot;)[0] ||
             document.documentElement,
    script = document.createElement(&amp;quot;script&amp;quot;); 
script.type = &amp;quot;text/javascript&amp;quot;;
script.text = data;
head.appendChild(script);               
head.removeChild(script); &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;head&lt;/code&gt;中插入一个&lt;code&gt;script&lt;/code&gt;元素，设置&lt;code&gt;type&lt;/code&gt;为JavaScript脚本，把&lt;code&gt;text&lt;/code&gt;设置成需要执行的字符串形式的代码，然后插入到&lt;code&gt;head&lt;/code&gt;中，再把它删除。这样，&lt;code&gt;text&lt;/code&gt;中的代码就会放到全局作用域中执行。&lt;/p&gt;

&lt;h3 id='id33'&gt;安全执行&lt;/h3&gt;

&lt;p&gt;在运行时环境中执行字符串形式的代码通常都会带来安全性的问题。代码的来源是我们最关心的问题，它是否可信？它是否包含高危的代码，把整个页面弄挂，甚至对后台服务器发起攻击？我们需要一种机制去过滤动态执行的代码，Google的Caja是其中一个方式，让代码安全的执行。其思路大概就是把一段动态的代码编译成另外一段更复杂，更难看的代码，实现相同的功能，又能防止该代码执行一些对页面可能有危害的行为。关于Caja，后面会专门写一篇讲述其原理及其使用方法。&lt;/p&gt;

&lt;p&gt;在日常工作中，需要使用动态执行字符串形式的代码场景有限（想必应该是十分高雅的实现……）。但是一旦要使用，记得注意采用哪种方式去执行动态代码，注意作用域以及上下文等细节问题哦亲。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Secrets of the JavaScript Ninja 读书笔记之 面向对象陷阱</title>
   <link href="http://username.github.com/2013/08/10/javascript-oo-gotchas"/>
   <updated>2013-08-10T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/10/javascript-oo-gotchas</id>
   <content type="html">&lt;p&gt;又到了周末读书的时间了。今天跟大家分享一下书中关于原型、实例化和继承的一些陷阱。&lt;/p&gt;

&lt;h3 id='id28'&gt;扩展&lt;code&gt;Object&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;先来看看扩展&lt;code&gt;Object.prototype&lt;/code&gt;可能会发生什么潜在的问题。假如我们为&lt;code&gt;Object&lt;/code&gt;的原型增加一个获取对象上键值的个数，可能会这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object.prototype.keys = function() {      
  var keys = [];
  for (var p in this) keys.push(p);
  return keys;
};
var obj = { a: 1, b: 2, c: 3 };              
alert(obj.keys());&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果返回了&lt;code&gt;[a, b, c, keys]&lt;/code&gt;。这种遍历方式甚至把我们刚才扩展&lt;code&gt;Object.prototype&lt;/code&gt;的那个&lt;code&gt;keys&lt;/code&gt;方法都遍历出来了！一般情况下，我们对一个对象进行遍历，是不需要把对象上的方法遍历出来的。解决上面的问题，一种方案是判断遍历的值是否是方法，另一种方案就是使用&lt;code&gt;hasOwnProperty&lt;/code&gt;来判断对象是否拥有这个属性，过滤掉原型链中的其他属性。&lt;/p&gt;

&lt;h3 id='id29'&gt;扩展&lt;code&gt;Number&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;为&lt;code&gt;Number.prototype&lt;/code&gt;做扩展要注意的是，在其文档中要说明如何使用这个扩展。假设我们为&lt;code&gt;Number.prototype&lt;/code&gt;增加了一个&lt;code&gt;add&lt;/code&gt;方法，那只能按以下的方式调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var n = 5;
n.add(2);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(5).add(2);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而不能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;5.add(2);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一行代码有语法错误，会导致JavaScript脚本无法顺利执行。所以最好的解决方案是&lt;strong&gt;不要对&lt;code&gt;Number.prototype&lt;/code&gt;进行扩展&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id='id30'&gt;派生内置“类”&lt;/h3&gt;

&lt;p&gt;假如我们需要数组的功能，例如&lt;code&gt;push&lt;/code&gt;、&lt;code&gt;pop&lt;/code&gt;等，又想在不增加原来&lt;code&gt;Array&lt;/code&gt;的功能，那我们可以使用以下的代码，继承&lt;code&gt;Array&lt;/code&gt;，派生一个自定义的“类”：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function MyArray() {}
MyArray.prototype = new Array();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码在FireFox和Chrome上都是好使的，但在IE下就会有问题，因为IE对数组的&lt;code&gt;length&lt;/code&gt;的处理是不同的。这种场景对应的解决方案是使用拷贝数组中有用的功能，重新构造一个“类”。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：测试发现IE7、8、9中以上的代码都是没问题的，不知道问题是否只存在于IE6……例子可以&lt;a href='http://jsfiddle.net/ERcFg/3/'&gt;参考这里&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id='id31'&gt;实例化&lt;/h3&gt;

&lt;p&gt;假如有以下一个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function User(first, last){
  this.name = first + &amp;quot; &amp;quot; + last;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个明显是一个构造函数，正确的调用方法应该是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var user = new User(&amp;quot;Ichigo&amp;quot;, &amp;quot;Kurosaki&amp;quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是值得注意的是这个函数也可以像普通函数那样直接执行（即省略&lt;code&gt;new&lt;/code&gt;）。当省略&lt;code&gt;new&lt;/code&gt;之后，不仅&lt;code&gt;user&lt;/code&gt;会是&lt;code&gt;undefined&lt;/code&gt;，更严重的影响可能是在全局作用域中增加了一个&lt;code&gt;name&lt;/code&gt;属性（&lt;code&gt;this&lt;/code&gt; === &lt;code&gt;window&lt;/code&gt;）。虽然这种调用我们可以通过文档来说明调用的方式，但是还有更健壮的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function User(first, last) {
  if (!(this instanceof arguments.callee)) { 
    return new User(first,last);                  
  }                                                
  this.name = first + &amp;quot; &amp;quot; + last;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里先使用&lt;code&gt;instanceof&lt;/code&gt;来判断&lt;code&gt;this&lt;/code&gt;是否这个“类”的实例，如果不是则自动以构造函数的方式再调用一次。这种实现的好处无疑是增加了健壮性，无论用户如何调用这个方法，都会返回一个&lt;code&gt;User&lt;/code&gt;的实例。但是使用这个实现的时候还需要考虑以下几点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;arguments.callee&lt;/code&gt;在往后的JavaScript标准中已经被废弃了，而且在严格模式下使用这个属性是会报错的。可以硬编码成&lt;code&gt;User&lt;/code&gt;，牺牲少许灵活性。&lt;/li&gt;

&lt;li&gt;这样做导致一个功能有两种调用形式，这对API的一致性是不利的。&lt;/li&gt;

&lt;li&gt;a这样做也限制了用户把这个函数当成普通函数执行的权力。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于JavaScript OO的各种陷阱还有很多，日常编码的时候一定要注意多在不同的设备、不同的平台、不同的浏览器进行测试。在考虑实现的时候也要想想这个功能是否真需要用OO来实现，毕竟JavaScript只是一个基于对象的语言，而不是一个完整的面向对象的语言。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>jQuery源码解析之jQuery.each</title>
   <link href="http://username.github.com/2013/08/09/jquery-each"/>
   <updated>2013-08-09T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/09/jquery-each</id>
   <content type="html">&lt;p&gt;昨天讨论了&lt;code&gt;for...in&lt;/code&gt;的用法，今天来看一个可能我们日常使用频率更高另外一个遍历的方法：&lt;code&gt;jQuery.each&lt;/code&gt;。先来看看jQuery对&lt;code&gt;each&lt;/code&gt;的描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A generic iterator function, which can be used to seamlessly iterate over both objects and arrays. Arrays and array-like objects with a length property (such as a function&amp;#8217;s arguments object) are iterated by numeric index, from 0 to length-1. Other objects are iterated via their named properties.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从描述中可以看出来，&lt;code&gt;jQuery.each&lt;/code&gt;即可以遍历数组（包括&lt;code&gt;arguments&lt;/code&gt;对象），也可以遍历一个对象上的属性。该方法接受两个参数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;collection&lt;/code&gt;，需要遍历的数组或者对象。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;callback&lt;/code&gt;，遍历时的回调函数，该函数接受两个参数，一个是这次遍历的下标（数组）或者键值（对象），另一个是这次遍历的迭代子的值。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;执行这个方法返回的是被遍历的对象，便于写出链式写法的代码。&lt;/p&gt;

&lt;p&gt;在每次遍历的回调中，我们可以通过&lt;code&gt;return false&lt;/code&gt;来实现&lt;code&gt;for&lt;/code&gt;循环中的&lt;code&gt;break&lt;/code&gt;功能，通过返回非&lt;code&gt;false&lt;/code&gt;的值来实现&lt;code&gt;continue&lt;/code&gt;的功能。如以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.each([1, 2, 3, 4], function(i, v) {
  if (v === 1) {
    return true;
  }
  if (v === 3) {
    return false;
  }
  console.log(v);
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果&lt;a href='http://jsfiddle.net/HWh6Y/show'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;再来看看最新的jQuery的&lt;code&gt;each&lt;/code&gt;的源码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// args is for internal usage only
each: function( obj, callback, args ) {&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先可以看到原来&lt;code&gt;each&lt;/code&gt;是接受三个参数的，第三个参数只能内部使用。首先使用&lt;code&gt;isArraylike&lt;/code&gt;来判断&lt;code&gt;obj&lt;/code&gt;是否一个类似数组的东西（如有&lt;code&gt;length&lt;/code&gt;属性，并可以通过下标访问等）。如果是，则用普通的&lt;code&gt;for&lt;/code&gt;循环来遍历这个数组；如果不是，则使用&lt;code&gt;for...in&lt;/code&gt;来遍历这个对象。这里分享一个小插曲，在&lt;code&gt;isArraylike&lt;/code&gt;函数里面有这么一句代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return type === &amp;quot;array&amp;quot; || type !== &amp;quot;function&amp;quot; &amp;amp;&amp;amp;
    ( length === 0 ||
    typeof length === &amp;quot;number&amp;quot; &amp;amp;&amp;amp; length &amp;gt; 0 &amp;amp;&amp;amp; ( length - 1 ) in obj );&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后那个&lt;code&gt;(length - 1) in obj&lt;/code&gt;是什么意思呢，为啥这样可以说明这个&lt;code&gt;obj&lt;/code&gt;是一个类似数组的东西？原来&lt;code&gt;[1, 2]&lt;/code&gt;的内部结构可以这么表述：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;0&amp;quot;: 1, &amp;quot;1&amp;quot;: 2}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以&lt;code&gt;length - 1&lt;/code&gt;这个键在类似数组的对象中是存在的，而其他对象如果键值没有显式声明成&lt;code&gt;1&lt;/code&gt;的话是不会符合这个规则的。所以这个也被用作是判断一个对象是否是一个类数组的条件之一。使用这个条件可以弥补只判断&lt;code&gt;length&lt;/code&gt;属性是否是数字的不足。&lt;/p&gt;

&lt;p&gt;当提供了第三个&lt;code&gt;args&lt;/code&gt;参数时，在调用回调的时候会使用&lt;code&gt;apply&lt;/code&gt;把&lt;code&gt;args&lt;/code&gt;当作参数传到回调中，否则会使用&lt;code&gt;call&lt;/code&gt;把下标或者键值、对应的值当作参数传到回调之中，后者也是我们日常使用的场景。回调函数执行的上下文&lt;code&gt;this&lt;/code&gt;都是当前遍历的值，也就是日常使用场景中的第二个参数。&lt;/p&gt;

&lt;p&gt;如果回调返回了&lt;code&gt;false&lt;/code&gt;则停止遍历。要注意，如果要使用&lt;code&gt;break&lt;/code&gt;的功能，一定要&lt;code&gt;return false&lt;/code&gt;，不能返回强制转换后是&lt;code&gt;false&lt;/code&gt;的值，例如&lt;code&gt;0&lt;/code&gt;或者空字符串等等。因为这里使用的是&lt;code&gt;===&lt;/code&gt;来判断：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;value = callback.call( obj[ i ], i, obj[ i ] );
if ( value === false ) {
  break;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遍历对象的时候是使用了普通的&lt;code&gt;for...in&lt;/code&gt;循环，并没有像昨天讨论的加上&lt;code&gt;hasOwnProperty&lt;/code&gt;的保护，所以使用&lt;code&gt;jQuery.each&lt;/code&gt;会遍历所有能被遍历的属性，包括原型链上的属性哦。&lt;/p&gt;

&lt;p&gt;最后就是一些小细节了，例如无论是下标或者键值都用同一个变量&lt;code&gt;i&lt;/code&gt;作为迭代计数、&lt;code&gt;for&lt;/code&gt;循环中连迭代计数的初始化&lt;code&gt;i = 0&lt;/code&gt;都省略了等。前者可以减少局部变量的数目，后者可以使代码压缩后体积更小（虽然效果有限……）。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>在JavaScript中遍历一个对象的所有属性</title>
   <link href="http://username.github.com/2013/08/08/javascript-iteract-an-object"/>
   <updated>2013-08-08T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/08/javascript-iteract-an-object</id>
   <content type="html">&lt;p&gt;在JavaScript中遍历一个对象的所有属性，相信这个一个前端开发人员几乎每天都要面对的事情。最简单的莫过于&lt;code&gt;for...in&lt;/code&gt;循环：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (variable in object) {
  ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;variable&lt;/code&gt;是这个对象里面的键值。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;object&lt;/code&gt;是要遍历的对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意：这个循环是不会去遍历那些被声明为不可遍历的属性（例如&lt;code&gt;Object.prototype&lt;/code&gt;或者&lt;code&gt;String.prototype&lt;/code&gt;上面的属性）。执行&lt;code&gt;for...in&lt;/code&gt;循环时，不仅会遍历这个对象上的所有属性，也会沿着这个对象的原型链遍历所有原型链上的属性，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function A () {
  this.b = &amp;quot;b&amp;quot;;
  this.a = &amp;quot;a&amp;quot;;
}

A.prototype.a = &amp;quot;prototype a&amp;quot;;
A.prototype.c = &amp;quot;prototype c&amp;quot;;

var a = new A();

for (var k in a) {
  console.log(k + &amp;quot;: &amp;quot; + a[k]);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果&lt;a href='http://jsfiddle.net/ej9Mm/1/'&gt;参考这里&lt;/a&gt;。值得注意的是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;遍历了原型上的属性&lt;code&gt;c&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;原型上的&lt;code&gt;a&lt;/code&gt;属性被对象上的&lt;code&gt;a&lt;/code&gt;属性覆盖了，导致原型上的&lt;code&gt;a&lt;/code&gt;没有被遍历出来。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Object&lt;/code&gt;的原型链上的属性没有被遍历出来，其属性被声明为不可遍历。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然在IE6+、Firfox 22、Chrome 27上验证的结果，遍历的顺序跟对象上的属性声明的顺序一致，但是&lt;strong&gt;原则上这种遍历是无序的，程序的逻辑不要依赖于这种遍历的顺序&lt;/strong&gt;。由于遍历的无序性，也不要使用&lt;code&gt;for...in&lt;/code&gt;去遍历一个数组。&lt;/p&gt;

&lt;p&gt;另外，最佳实践是，&lt;strong&gt;不要在遍历的过程中在遍历的对象上增加或者删除属性，也尽量不要修改不是这次遍历的属性，可能会造成不可预知的结果&lt;/strong&gt;，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (var k in a) {
  console.log(k + &amp;quot;: &amp;quot; + a[k]);
  a.d = &amp;quot;d&amp;quot;;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码在IE9、Firefox 22、Chrome上都没有把&lt;code&gt;d&lt;/code&gt;遍历出来，说明标准的实现应该是忽略遍历过程中增加的属性。但是IE7和IE8就把&lt;code&gt;d&lt;/code&gt;遍历出来了。运行结果&lt;a href='http://jsfiddle.net/gaGq4/2/show/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;根据遍历的需要，可以控制遍历时是否需要遍历原型链上的属性。可以通过以下几个方式，仅遍历这个对象拥有的属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (var k in a) {
  if (a.hasOwnProperty(k)) {
    log(k + &amp;quot;: &amp;quot; + a[k]);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var names = Object.getOwnPropertyNames(a);

for (var i = 0; i &amp;lt; names.length; i++) {
  console.log(names[i] + &amp;quot;: &amp;quot; + a[names[i]]);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前者使用了&lt;code&gt;hasOwnProperty&lt;/code&gt;方法判断对象是否拥有这个属性，如果属性是存在于原型链中，该方法会返回&lt;code&gt;false&lt;/code&gt;。后者使用一个&lt;code&gt;Object&lt;/code&gt;的方法&lt;code&gt;getOwnPropertyNames&lt;/code&gt;取出这个对象拥有属性的键值，然后再根据返回的键值进行遍历。看代码的话感觉后者比较优雅，但是可惜至少在IE7、IE8上不支持，而前者则是所有浏览器都支持。这也是jslint要求使用&lt;code&gt;for...in&lt;/code&gt;循环的时候加上&lt;code&gt;hasOwnProperty&lt;/code&gt;这个方法的调用，以防遍历出一些我们不希望遍历的属性（例如原型链上的方法等）。&lt;/p&gt;

&lt;p&gt;明天又到了jQuery的源码分享的时间了，将会带来&lt;code&gt;$.each&lt;/code&gt;的相关代码简析，敬请期待！&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>了解BFC</title>
   <link href="http://username.github.com/2013/08/07/css-bfc"/>
   <updated>2013-08-07T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/07/css-bfc</id>
   <content type="html">&lt;p&gt;BFC，Block Formatting Context，简单的说就是一个块元素布局上下文，MDN中是这么解释的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A block formatting context is a part of a visual CSS rendering of a Web page. It is the region in which the layout of block boxes occurs and in which floats interact with each other.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在触发了BFC的容器中，声明了内部浮动元素的布局规则。一个元素浮动或者清除浮动，不会影响另一个BFC的内部元素的布局。&lt;/p&gt;

&lt;p&gt;通过以下条件可以使一个元素生成BFC：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;aHTML文档的根节点。&lt;/li&gt;

&lt;li&gt;a浮动元素。&lt;/li&gt;

&lt;li&gt;a绝对定位的元素。&lt;/li&gt;

&lt;li&gt;a&lt;code&gt;display&lt;/code&gt;是&lt;code&gt;inline-block&lt;/code&gt;、&lt;code&gt;table-cell&lt;/code&gt;、&lt;code&gt;table-caption&lt;/code&gt;、&lt;code&gt;flex&lt;/code&gt;或者&lt;code&gt;inline-flex&lt;/code&gt;的元素。&lt;/li&gt;

&lt;li&gt;a&lt;code&gt;overflow&lt;/code&gt;不是&lt;code&gt;visible&lt;/code&gt;的元素。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当一个元素触发了BFC，会有以下几个布局规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;a不与浮动元素重叠。&lt;/li&gt;

&lt;li&gt;a清除元素内部的浮动。通过触发BFC，使元素内部的浮动元素造成布局的影响限制在触发BFC元素之内。&lt;/li&gt;

&lt;li&gt;a不让内外&lt;code&gt;margin&lt;/code&gt;合并。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看上去跟昨天介绍的&lt;code&gt;hasLayout&lt;/code&gt;造成的效果有点类似啊。所以才说在触发BFC的同时最好也同时触发&lt;code&gt;hasLayout&lt;/code&gt;，以保证不同浏览器中的显示效果一致。&lt;/p&gt;

&lt;p&gt;BFC跟&lt;code&gt;float&lt;/code&gt;和&lt;code&gt;clear&lt;/code&gt;对布局的影响也有关系，将继续讨论&lt;code&gt;float&lt;/code&gt;和&lt;code&gt;clear&lt;/code&gt;的具体用法以及要注意的地方&lt;em&gt;（看来要搞一个CSS专场了……）&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href='https://developer.mozilla.org/en-US/docs/Web/CSS/block_formatting_context'&gt;Block formatting context&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.w3ctech.com/p/1101'&gt;更加直观地了解hasLayout和BFC&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content>
 </entry>
 
 <entry>
   <title>IE的hasLayout</title>
   <link href="http://username.github.com/2013/08/06/css-ie-haslayout"/>
   <updated>2013-08-06T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/06/css-ie-haslayout</id>
   <content type="html">&lt;p&gt;只有在IE8之前版本的IE上才会有hasLayout这个纠结的东西。在这些版本的IE中，有两种类型的元素：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;a拥有布局的元素，可以控制自己的大小及其子元素的布局。&lt;/li&gt;

&lt;li&gt;a没有布局的元素，只能根据最近的拥有布局的祖先元素来确定自己的大小和布局。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;拥有布局的元素可以控制自己的大小，也可以控制其自身及其子元素的布局。一些没有特定声明宽度和高度的元素，但是有一些大小限制的元素，例如表单控件、图片等，通常也是拥有布局的元素。只有拥有布局的元素才能控制是否出现滚动条。&lt;/p&gt;

&lt;p&gt;拥有布局的元素意味着：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;a限制这个元素成为一个矩形（强制行内元素的布局行为变得像块元素一样）。&lt;/li&gt;

&lt;li&gt;a一些关于这个元素的大小位置等属性会被缓存起来，也会参与到大小位置改变的算法中，造成额外的内存于时间消耗。&lt;/li&gt;

&lt;li&gt;a不能根据子元素的内容进行自适应。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当一个元素拥有布局的时候，我们说这个元素触发了&lt;code&gt;hasLayout&lt;/code&gt;，也就是说这个元素有个内部属性为&lt;code&gt;hasLayout: true&lt;/code&gt;。注意，这个不是一个CSS的样式，某种特定的情况下一个元素就会拥有布局。&lt;/p&gt;

&lt;p&gt;首先是默认就拥有布局的元素：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;a图片&lt;/li&gt;

&lt;li&gt;a表格、表格行、单元格&lt;/li&gt;

&lt;li&gt;a表单控件&lt;/li&gt;

&lt;li&gt;a&lt;code&gt;frameset&lt;/code&gt;等框架元素&lt;/li&gt;

&lt;li&gt;a&lt;code&gt;object&lt;/code&gt;等嵌入元素&lt;/li&gt;

&lt;li&gt;a绝对定位元素&lt;/li&gt;

&lt;li&gt;a浮动元素&lt;/li&gt;

&lt;li&gt;a&lt;code&gt;inline-block&lt;/code&gt;元素&lt;/li&gt;

&lt;li&gt;a&lt;code&gt;filter&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;a&lt;code&gt;body&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当元素满足以下条件的时候也可以变成拥有布局的元素：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;a在严格模式下，声明了宽度和高度的块元素&lt;/li&gt;

&lt;li&gt;a在兼容模式下，任何声明了宽度和高度的元素&lt;/li&gt;

&lt;li&gt;a拥有&lt;code&gt;zoom&lt;/code&gt;的元素&lt;/li&gt;

&lt;li&gt;a处于编辑模式下的元素&lt;/li&gt;

&lt;li&gt;a阅读顺序与父元素不一样的元素&lt;/li&gt;

&lt;li&gt;a一个拥有&lt;code&gt;viewlink&lt;/code&gt;特性的元素&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最好是使用&lt;code&gt;zoom: 1&lt;/code&gt;来触发元素的&lt;code&gt;hasLayout&lt;/code&gt;，因为该CSS样式不会对元素造成任何可视的影响。&lt;/p&gt;

&lt;p&gt;个人感觉这个&lt;code&gt;hasLayout&lt;/code&gt;的最大用处就是在不支持&lt;code&gt;display: inline-block&lt;/code&gt;的浏览器（例如IE6）中模拟出对应的效果。由于触发了&lt;code&gt;hasLayout&lt;/code&gt;的元素可以拥有类似BFC（明天会讨论这个）的视觉效果，即可以让一个行内元素的布局行为变成类似于块元素的布局行为。所以，在IE8-的浏览器中，如果需要触发&lt;code&gt;hasLayout&lt;/code&gt;，最好也同时触发BFC，保证显示效果一致。例子&lt;a href='http://jsfiddle.net/rweLu/2/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href='http://msdn.microsoft.com/en-us/library/bb250481(v=vs.85).aspx'&gt;&quot;HasLayout&quot; Overview&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href='http://kayosite.com/internet-explorer-haslayout-in-detail.html'&gt;详说 IE hasLayout&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content>
 </entry>
 
 <entry>
   <title>JavaScript与Flash通信</title>
   <link href="http://username.github.com/2013/08/05/javascript-flash-comunication"/>
   <updated>2013-08-05T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/05/javascript-flash-comunication</id>
   <content type="html">&lt;p&gt;虽然说iOS不支持Flash，但是Flash在桌面端的使用量还是很大的。作为一个专业的前端开发人员，至少也要懂得如何使用JavaScript与Flash进行通信。&lt;/p&gt;

&lt;h3 id='javascript__flash'&gt;JavaScript =&amp;gt; Flash&lt;/h3&gt;

&lt;p&gt;使用JavaScript调用Flash内部的方法。假设有以下Flash片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;object type=&amp;quot;application/x-shockwave-flash&amp;quot; id=&amp;quot;myFlashID&amp;quot; width=&amp;quot;85&amp;quot; height=&amp;quot;85&amp;quot; data=&amp;quot;framejump.swf&amp;quot;&amp;gt;
  &amp;lt;param name=&amp;quot;allowScriptAccess&amp;quot; value=&amp;quot;sameDomain&amp;quot;&amp;gt;
  &amp;lt;param name=&amp;quot;movie&amp;quot; value=&amp;quot;framejump.swf&amp;quot;&amp;gt;
  &amp;lt;param name=&amp;quot;quality&amp;quot; value=&amp;quot;high&amp;quot;&amp;gt;
  &amp;lt;param name=&amp;quot;scale&amp;quot; value=&amp;quot;noscale&amp;quot;&amp;gt;
  &amp;lt;param name=&amp;quot;wmode&amp;quot; value=&amp;quot;transparent&amp;quot;&amp;gt;
&amp;lt;/object&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以通过JavaScript先获取该Flash影片的引用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getFlashMovieObject(movieName){
  if (window.document[movieName]){
    return window.document[movieName];
  }else if (navigator.appName.indexOf(&amp;quot;Microsoft&amp;quot;)==-1){
    if (document.embeds &amp;amp;&amp;amp; document.embeds[movieName])
      return document.embeds[movieName];
  }else{
    return document.getElementById(movieName);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取引用后，还需要Flash内部使用增加回调的方式暴露接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ExternalInterface.addCallback(&amp;quot;frameJump&amp;quot;, frameJump);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;frameJump&lt;/code&gt;的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function frameJump(whichFrame:String):void {
  gotoAndStop(whichFrame);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以在JavaScript中直接调用该引用上的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var flashObj = getFlashMovieObject(&amp;quot;movieName&amp;quot;);
flashObj.frameJump(5);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;a href='http://iviewsource.com/exercises/javascripttoflash/'&gt;参考这里&lt;/a&gt;。通过这个机制可以让JavaScript调用Flash中的方法。&lt;/p&gt;

&lt;h3 id='flash__javascript'&gt;Flash =&amp;gt; JavaScript&lt;/h3&gt;

&lt;p&gt;Flash调用JavaScript的方法是使用&lt;code&gt;ExternalInterface.call&lt;/code&gt;这个方法去调用外部的JavaScript方法，使用方法很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ExternalInterface.call(&amp;quot;alert&amp;quot;, &amp;quot;This alert comes from Flash&amp;quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中第一个参数是全局作用域中的函数名称，后面的参数是传给要调用的JavaScript方法的参数。例子&lt;a href='http://iviewsource.com/exercises/flashtojavascript/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href='http://iviewsource.com/codingtutorials/communication-between-javascript-and-flash/'&gt;Communication between JavaScript and Flash&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.imququ.com/post/39.html'&gt;Javascript与Flash通信全解析&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content>
 </entry>
 
 <entry>
   <title>High Performance JavaScript 读书笔记之 数据存取</title>
   <link href="http://username.github.com/2013/08/04/high-performance-javascript-read-note"/>
   <updated>2013-08-04T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/04/high-performance-javascript-read-note</id>
   <content type="html">&lt;p&gt;今天再来一篇有关提高性能的读书笔记。标题中的数据存储，说白了就是JavaScript中获取与设置数据的方式，例如局部变量、全局变量、对象属性、数组等。大家有没有想过函数或者方法中使用以上的不同方式存取数据对性能造成的影响也是不一样的呢？&lt;/p&gt;

&lt;h3 id='id26'&gt;变量&lt;/h3&gt;

&lt;p&gt;当数据存储在局部变量中，读取与写入的方式都是最快的。这是由于局部变量存放在作用域链的最顶层。当变量出现在特定的作用域链中，对作用域链的遍历就可以停止了，减少遍历作用域链的性能开销。与之相反的就是全局变量。全局变量放置在全局作用域中，这个作用域处于作用域链的最底层。当反复引用全局变量的时候，每次引用都要完整遍历整个作用域链（当然，某些现代浏览器会对代码进行解析型的编译优化如此问题，但是我们还是要兼容那些古老的浏览器，难道不是吗？），这样会造成额外的开销。&lt;/p&gt;

&lt;p&gt;还有一些语句会对作用域链做动态的修改。例如&lt;code&gt;with&lt;/code&gt;，会在作用域链的顶端加入一个临时的作用域，包含&lt;code&gt;with&lt;/code&gt;参数中的对象的所有属性。又如&lt;code&gt;try-catch&lt;/code&gt;中&lt;code&gt;catch&lt;/code&gt;字句，会在作用域链的顶端加入一个临时作用域，加入错误对象。这些语句都会造成作用域链的长度增加，也增加了遍历作用域链的性能开销。&lt;/p&gt;

&lt;p&gt;闭包也会对变量的读取和写入造成性能影响。当闭包的内部函数被执行的时候，它的作用域链是由内部函数的活动对象加上外部函数的作用域链合并而成。当闭包的嵌套层数很深，查找一个变量也会去遍历这个很深的作用域链，造成性能消耗。&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;with&lt;/code&gt;，尽量不使用。对于&lt;code&gt;try-catch&lt;/code&gt;，不要把它作为JavaScript的异常处理机制。更合理的做法是在代码中尽量避免抛出异常，手工处理异常分支，只把&lt;code&gt;try-catch&lt;/code&gt;当作最后的安全手段。&lt;/p&gt;

&lt;p&gt;对于访问和修改全局变量或者是闭包变量，所做的优化就是使用一个局部变量把相关的全局变量和闭包变量引入到函数的内部，当需要使用这些变量的时候使用局部变量的引用，减少遍历作用域链的次数。&lt;/p&gt;

&lt;p&gt;虽然以上的优化效果有限，但是当函数被频繁执行的时候效果就会很明显了。当然，这些优化可以交给以后的编译器或者部署工具（JavaScript压缩工具等），但是在没有这些工具、没有浏览器JavaScript引擎优化的情况下，在性能需求非常高的场景，我们也要注意这些细节。&lt;/p&gt;

&lt;h3 id='id27'&gt;属性&lt;/h3&gt;

&lt;p&gt;数据也可以作为一个对象的属性进行访问或者写入。我们知道，JavaScript中的对象是通过原型的方式来模拟OO中的继承关系。在一个对象中访问某个属性，需要遍历原型链去查找某个属性是否存在。这样意味着一个没有&lt;code&gt;toString&lt;/code&gt;方法的对象调用像&lt;code&gt;Object&lt;/code&gt;的&lt;code&gt;toString&lt;/code&gt;方法，需要遍历整个原型链才能找到这个方法，然后才能执行。当原型链很深的时候，调用原型上的方法需要更多次数的遍历，也会造成额外的性能开销。&lt;/p&gt;

&lt;p&gt;对于属性上的优化，思想跟变量是一致的：使用一个局部变量“缓存”这些方法的属性。这样能把相关属性提高到作用域链的最顶端，当访问的时候直接访问局部变量，就不需要再去原型链中查找了。&lt;strong&gt;注意，对象上的方法最好不要使用这中方式缓存，可能会造成执行上下文的改变，需要使用&lt;code&gt;call&lt;/code&gt;或者&lt;code&gt;apply&lt;/code&gt;去手工控制方法的执行上下文才能保证逻辑的正确性。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以上是书中的内容。其实我个人认为，包括之前写的Yahoo!的性能优化规则，不能为了遵守规则而遵守规则，更多需要考虑的是为什么要遵守这些规则，遵守了之后有是很么好处。而更理智的应该是使用数据说话，对比遵守前跟遵守后的性能数据，还有衡量遵守这些规则的代价（例如时间、维护性等），性价比高的规则才考虑落入，这样是比较理智的做法。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Yahoo!性能优化规则</title>
   <link href="http://username.github.com/2013/08/03/yahoo-performance-rules"/>
   <updated>2013-08-03T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/03/yahoo-performance-rules</id>
   <content type="html">&lt;p&gt;最近接二连三地被问到有做过什么性能优化的东西，感觉之前做了很多都没有仔细总结积累下来，到用的时候还得拼命去想这些规则。现在就先看看Yslow里面的性能优化规则吧，以作参考。&lt;/p&gt;

&lt;h3 id='http'&gt;减少HTTP请求&lt;/h3&gt;

&lt;p&gt;由于请求一个外部的JavaScript或者样式表需要发送一个HTTP请求，而建立HTTP请求、接收响应这个过程会带来一些性能的开销。应该尽量避免发送太多HTTP请求，减少建立请求时造成的不必要的开销。以下是几个减少HTTP请求的方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;合并JavaScript脚本和样式表。当页面应用的脚本跟样式表的个数比较多的时候会发送等量的HTTP请求或者这些文件的内容。可以在部署的时候静态打包出合并后的release文件，或者运行时状态下动态合并相关的脚本与样式表。&lt;/li&gt;

&lt;li&gt;CSS Sprites，结合&lt;code&gt;background-image&lt;/code&gt;和&lt;code&gt;background-position&lt;/code&gt;这两个CSS样式可以把一系列的小背景图（例如图标）全部合并到一个文件上面，减少不同样式获取背景图片的时候发送的HTTP请求。&lt;/li&gt;

&lt;li&gt;Image Map，把多个图片合并到一个图片中，使用&lt;code&gt;coords&lt;/code&gt;属性限制图片的显示区域，与CSS Sprites类似。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;data:URL&lt;/code&gt;，把一些小图片的内容直接通过这个属性内联到&lt;code&gt;img&lt;/code&gt;标签中，这样这个图片就不需要额外发送一个HTTP请求了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='cdn'&gt;使用CDN内容分发网络&lt;/h3&gt;

&lt;p&gt;超过80%的响应时间消耗在等待内容下载的阶段，例如外部JavaScript脚本、CSS样式表等。所以静态资源存放在哪也影响到网站响应的效率。CDN可以帮助用户从最效率的服务器（例如地理位置最近、网络延迟最少等）返回对应的静态资源，保证静态资源的下载效率最高。这个工作在网站上线之后是最容易操作的，但是也比较容易被忽略。&lt;/p&gt;

&lt;p&gt;这里吐槽一句，由于在我司做的项目都是基于内网用户的，所以这个没法使用CDN，相信使用了CDN之后还可能造成性能下降（囧）。&lt;/p&gt;

&lt;h3 id='id19'&gt;激活缓存机制&lt;/h3&gt;

&lt;p&gt;通过配置HTTP头&lt;code&gt;Expires&lt;/code&gt;或者&lt;code&gt;Cache-Controll&lt;/code&gt;可以激活缓存机制。由于静态资源已经被存放到缓存中，下次请求同样的资源的时候可以直接读取缓存的内容，减少多次重复请求的资源的下载量。&lt;/p&gt;

&lt;p&gt;这个工作可以在页面上增加对应的&lt;code&gt;meta&lt;/code&gt;或者在Web容器中配置对应的HTTP头去控制缓存的机制，包括过期时间等。&lt;/p&gt;

&lt;h3 id='gzip'&gt;开启GZip&lt;/h3&gt;

&lt;p&gt;开启GZip后会减少这个请求在网络上传输的内容，减少请求在网络上消耗的时间。通过设置请求头&lt;code&gt;Accept-Encoding&lt;/code&gt;和对应的相应头&lt;code&gt;Content-Encoding&lt;/code&gt;开启GZip功能。虽然减少了网络传输的内容，但是由于内容要先经过压缩，接收到还要解压，这务必会产生一些性能的消耗。所以当请求的内容比较复杂（如图片或者pdf文档）就不应该使用GZip压缩的功能。&lt;/p&gt;

&lt;h3 id='id20'&gt;把样式表尽量提前&lt;/h3&gt;

&lt;p&gt;样式表放在前面会提高页面渲染的效率。试想一下当一个HTML文档渲染好后遇到一个样式表，其中的规则务必对已渲染的内容做出改动（例如改变大小、颜色甚至是布局等），这样也会带来一定的性能开销。&lt;/p&gt;

&lt;p&gt;把样式表放前面的另外一个优点是当HTML文档渲染好后，页面与我们期待的是一致的，而不会出现一开始什么样式都没有，然后一闪才到我们期待的样式。&lt;/p&gt;

&lt;h3 id='id21'&gt;把脚本尽量放后&lt;/h3&gt;

&lt;p&gt;我们知道，浏览器页面渲染、处理用户交互跟执行代码这三个工作都是发生在一个线程里面。当加载一大段脚本的时候，页面渲染会被迫停止。假如加载的时间很长，页面就会长期保持在一个空白的状态，严重影响用户体验。所以，脚本应该在页面展现之后才加载、执行。这需要把脚本文件尽量放到&lt;code&gt;body&lt;/code&gt;元素的最后面。&lt;/p&gt;

&lt;p&gt;更好的方法是，使用动态脚本的方式加载脚本，而不直接写死在HTML页面上的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;上。这样做的好处是我们可以控制脚本加载的时机，确保不会影响页面的正常展示。&lt;/p&gt;

&lt;h3 id='css'&gt;避免CSS表达式&lt;/h3&gt;

&lt;p&gt;CSS表达式最大的问题是，当交互频繁的时候（例如不断resize、不断滚动等），CSS表达式执行的次数超乎我们想象。所以尽量不要使用CSS表达式，同样的效果可以通过JavaScript的事件处理程序来实现。&lt;/p&gt;

&lt;h3 id='id22'&gt;外部脚本和样式表&lt;/h3&gt;

&lt;p&gt;外部脚本和样式表不仅可以提高代码的可维护性，也可以提高页面的响应速度。由于页面使用的脚本或者是样式表会在很多页面上面共享，所以这些外部文件非常容易就被缓存起来。下次请求同样的外部脚本跟样式表的时候直接读取缓存的内容，可以提高响应速度。&lt;/p&gt;

&lt;h3 id='dns'&gt;减少DNS查询次数&lt;/h3&gt;

&lt;p&gt;这条规则貌似只适用于大型网站的互相集成。由于每次获取获取域名跟主机名的映射关系也是十分耗时的，所以可以通过减少依赖的外部文件的域名来限制DNS的查询次数。但是减少域名的情况下会导致并行下载的个数也在减少。&lt;/p&gt;

&lt;p&gt;这里也分享一个关于DNS的优化手段。如果在页面的生命周期内还要去获取其他域名上的外部文件（例如图片、脚本等），可以通过&lt;code&gt;rel&lt;/code&gt;为&lt;code&gt;dns-prefetch&lt;/code&gt;的&lt;code&gt;link&lt;/code&gt;标签去做DNS预取，提高获取外部文件时的响应速度。&lt;/p&gt;

&lt;h3 id='id23'&gt;代码压缩&lt;/h3&gt;

&lt;p&gt;由于JavaSript、CSS文件都是解析型的，没有通过编译的结果，导致在生产环境中文件的大小跟源码的大小是一致的。其实源码里面很多的空白都是可以省略的，例如注释、空格、换行等。在部署的时候对脚本和样式表进行压缩、扰码是可以大大减少这些文件的大小，也不影响实际功能的运作。内联在HTML中的脚本和样式也可以被压缩的哦。&lt;/p&gt;

&lt;h3 id='id24'&gt;慎用重定向&lt;/h3&gt;

&lt;p&gt;由于HTTP状态码&lt;code&gt;301&lt;/code&gt;和&lt;code&gt;302&lt;/code&gt;会导致浏览器重定向，造成额外的开销，最常见的是&lt;code&gt;/show&lt;/code&gt;到&lt;code&gt;/show/&lt;/code&gt;的重定向，这种应该要尽量避免。&lt;/p&gt;

&lt;h3 id='id25'&gt;删除重复的外部文件引用&lt;/h3&gt;

&lt;h3 id='etag'&gt;使用ETag&lt;/h3&gt;

&lt;p&gt;ETag是用于校验请求的资源是否发生变化的一个HTTP头。简单的说ETag的内容就是声明了一个资源的某个版本。当ETag的内容发生变化的时候说明资源发生了变化，缓存失效。配置这个头可以提高校验缓存是否失效的效率，不过会让HTTP请求头稍微大了一些。&lt;/p&gt;

&lt;h3 id='ajax'&gt;Ajax也可以缓存&lt;/h3&gt;

&lt;p&gt;以上就是Yahoo YSlow中的性能优化规则。不过这个只是最基本的排查点，还有很多性能优化点例如尽量使用局部变量去访问数据、限制闭包作用域链的深度、限制原型链的深度等，明天会写一篇读书笔记关于访问数据（JavaScript变量）如何提高效率的文章哦。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>三种原生JavaScript绑定事件方式对比</title>
   <link href="http://username.github.com/2013/08/02/javascript-bind-event-handler"/>
   <updated>2013-08-02T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/02/javascript-bind-event-handler</id>
   <content type="html">&lt;p&gt;今天又被问到三种原生JavaScript绑定事件的方式有什么不一样。感觉自己答不全啊，惭愧。晚上立马来恶补一下它们究竟有什么区别。下文主要从执行上下文（&lt;code&gt;this&lt;/code&gt;）、返回值等几个方面说明三者的区别。&lt;/p&gt;

&lt;h3 id='html'&gt;HTML标签上面的&lt;code&gt;onclick&lt;/code&gt;特性&lt;/h3&gt;

&lt;p&gt;曾经有那么一个时候，以下这种事件绑定的方式使用频率最高：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click me!&amp;quot; onclick=&amp;quot;alert(&amp;#39;Hello World&amp;#39;);&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当单击按钮的时候会弹出一个消息框。先来看看这个事件处理程序的特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;执行上下文是DOM元素。而MDN上面说的是&lt;code&gt;window&lt;/code&gt;对象。&lt;/li&gt;

&lt;li&gt;当返回值是&lt;code&gt;false&lt;/code&gt;的时候阻止默认行为，但不阻止事件传播。 3. 事件的传播只能是冒泡的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于第一点MDN说的情况我猜是这样的，假如有以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click me!&amp;quot; onclick=&amp;quot;doSomething();&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function doSomething() { alert(this === window); } // true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当单击按钮的时候执行&lt;code&gt;doSomething&lt;/code&gt;函数时，里面的&lt;code&gt;this&lt;/code&gt;就是&lt;code&gt;window&lt;/code&gt;，因为执行上下文在&lt;code&gt;window&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;例子&lt;a href='http://jsfiddle.net/MB9af/5/'&gt;参考这里&lt;/a&gt;。当JavaScript代码偏少的时候，这种方式还能勉强接受。当代码规模变大的时候，这种方式明显地带来很多不方便的东西。例如修改行为的时候还需要去修改HTML文件，这不是我们想要看到的。我们希望HTML与JavaScript能够分开维护，当修改行为的时候不要修改负责显示的东西。所以就有了下面这个绑定事件的方式。&lt;/p&gt;

&lt;h3 id='dom'&gt;DOM对象上的&lt;code&gt;onclick&lt;/code&gt;属性&lt;/h3&gt;

&lt;p&gt;为了能够分开HTML和JavaScript代码，我们也曾经广泛使用了一下这种方式去绑定事件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var button = document.getElementById(&amp;quot;#id&amp;quot;);
button.onclick = function (evt) { evt = evt || windowo.event; alert(&amp;quot;Hello World&amp;quot;); };&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个事件处理程序的特点是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;执行上下文是绑定的DOM元素&lt;code&gt;button&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;返回值是&lt;code&gt;false&lt;/code&gt;的时候阻止默认行为，但不阻止事件传播。 3. 事件的传播只能是冒泡的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例子&lt;a href='http://jsfiddle.net/ZbR4J'&gt;参考这里&lt;/a&gt;。以上这段JavaScript代码就为一个按钮绑定了一个单击事件。从代码结构上看，HTML和JavaScript确实分开了。但是这种方式有个严重的问题，就是只能为一个DOM元素的一个事件绑定唯一一个事件处理程序，重复绑定会覆盖了第一个绑定的事件处理程序，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;button.onclick = function (evt) { alert(1); }
button.onclick = function (evt) { alert(2); }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码，单击&lt;code&gt;button&lt;/code&gt;只会弹出&lt;code&gt;2&lt;/code&gt;，第一个事件处理程序已经被覆盖了。而且在低版本的IE浏览器里面这种写法很容易就会导致DOM与JavaScript对象的循环引用，导致内存泄露。&lt;/p&gt;

&lt;h3 id='addeventlistener'&gt;addEventListener&lt;/h3&gt;

&lt;p&gt;为了能在一个DOM上面的一个事件绑定多个事件处理程序，DOM level 2定义了以下的方式去绑定事件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;button.addEventListener(&amp;quot;click&amp;quot;, function (evt) { ... }, true); // IE9, IE9+, Chrome, Safari, Opera
button.attatchEvent(&amp;quot;onclick&amp;quot;, function () { ... }); // IE9-&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个事件处理程序的特点是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;执行上下文是DOM元素。&lt;/li&gt;

&lt;li&gt;返回值是&lt;code&gt;false&lt;/code&gt;的时候不阻止默认行为，也不阻止事件传播，只能通过调用事件对象的&lt;code&gt;preventDefault&lt;/code&gt;才能阻止默认行为，调用&lt;code&gt;stopPropagation&lt;/code&gt;才能阻止事件传播。&lt;/li&gt;

&lt;li&gt;事件的传播可以选择是冒泡（默认）或者是捕获的。（IE不支持事件捕获）&lt;/li&gt;

&lt;li&gt;绑定的事件处理程序可以通过&lt;code&gt;removeEventHandler&lt;/code&gt;或者&lt;code&gt;detachEvent&lt;/code&gt;来删除。&lt;/li&gt;

&lt;li&gt;多个事件处理程序的执行顺序是由绑定的顺序决定的，而且如果一个事件处理程序报错，不影响其他事件处理程序的执行。例子&lt;a href='http://jsfiddle.net/myPP7/'&gt;参考这里&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例子&lt;a href='http://jsfiddle.net/5zpLT/3/'&gt;参考这里&lt;/a&gt;。DOM level 2的事件绑定机制可以让我们把HTML和JavaScript代码分开，也支持为一个DOM的同一个事件绑定多个事件处理程序，基本满足了我们对事件绑定的需求。由于IE这个奇葩不支持事件捕获机制，所以要写跨浏览器的代码，只能使用冒泡来传播事件哦！&lt;/p&gt;

&lt;p&gt;貌似还不太够啊，等哥再仔细看看MDN和W3的规范后再补补。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>JavaScript typeof操作符</title>
   <link href="http://username.github.com/2013/08/01/javascript-typeof"/>
   <updated>2013-08-01T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/08/01/javascript-typeof</id>
   <content type="html">&lt;p&gt;昨天讨论&lt;code&gt;instanceof&lt;/code&gt;运算符，其中有一个比较坑的限制是，当使用iframe的时候可能会有意想不到的场景：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = [];
alert(a instanceof top.Array); // 当这段代码出现在iframe里面的时候是false&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因很简单，就是&lt;code&gt;window.Array&lt;/code&gt;跟&lt;code&gt;top.Array&lt;/code&gt;是两个不同的对象。虽然我们写代码的时候不会像上面那样显式地引用&lt;code&gt;top.Array&lt;/code&gt;，但是在iframe集成的场景下我们可能会这么调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (isArray(a)) { ... }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而&lt;code&gt;isArray&lt;/code&gt;可能会这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function isArray(a) { return top.isArray(a); }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就会出现上述的坑爹问题。今天来讨论另外一个检测JavaScript变量的运算符&lt;code&gt;typeof&lt;/code&gt;，看它是否能解决以上这个坑爹的问题。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;typeof操作符返回一个字符串，代表一个未估值的操作数(unevaluated operand)的类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt;接受一个操作数和一对可选的括号，返回表示该操作数的类型的字符串，操作数可以是字符串、对象、数字甚至是未定义的变量等。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt;运算符能返回以下表示操作数类型的字符串：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;undefined&lt;/code&gt;，操作数是未定义的变量或者属性，例如&lt;code&gt;undefined&lt;/code&gt;，或者&lt;code&gt;var a = {}; alert(typeof a.foo);&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;object&lt;/code&gt;，操作数是一个对象，例如&lt;code&gt;null&lt;/code&gt;、&lt;code&gt;{}&lt;/code&gt;、正则表达式或者&lt;code&gt;new String(&amp;quot;123&amp;quot;)&lt;/code&gt;等。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;boolean&lt;/code&gt;，操作数是一个布尔值，如&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;或者&lt;code&gt;Boolean(&amp;quot;false&amp;quot;)&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;number&lt;/code&gt;，操作数是一个数字，如&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;1.123&lt;/code&gt;或者&lt;code&gt;Number(&amp;quot;123&amp;quot;)&lt;/code&gt;等。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;string&lt;/code&gt;，操作数是一个字符串，如&lt;code&gt;&amp;quot;123&amp;quot;&lt;/code&gt;或者&lt;code&gt;String(&amp;quot;123&amp;quot;)&lt;/code&gt;等。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;function&lt;/code&gt;，操作数是一个方法，如&lt;code&gt;function () {}&lt;/code&gt;或者&lt;code&gt;new Function()&lt;/code&gt;等。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中一个比较奇怪的是&lt;code&gt;typeof null === &amp;quot;object&amp;quot;&lt;/code&gt;，这个貌似从JavaScript诞生以来就是这样，下面是MDN的解释：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在JavaScript最初的实现中,JavaScript中的值是由一个类型标签和一个数值组成的,对象的类型标签是0,由于null代表的是空指针(大多数平台下值为0x00),因此,null的类型标签也成为了0,typeof null就错误的返回了&amp;#8221;object&amp;#8221;.(该段文字没有具体的出处,正确性有待考证)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用&lt;code&gt;typeof&lt;/code&gt;可以跨iframe判断一个变量是否对象、布尔值、数字、字符串或者方法，这里引用玉伯的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function isType(type) {
  return function(obj) {
    return Object.prototype.toString.call(obj) === &amp;quot;[object &amp;quot; + type + &amp;quot;]&amp;quot;
  }
}
var isObject = isType(&amp;quot;Object&amp;quot;)
var isString = isType(&amp;quot;String&amp;quot;)
var isArray = Array.isArray || isType(&amp;quot;Array&amp;quot;)
var isFunction = isType(&amp;quot;Function&amp;quot;)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，由于当&lt;code&gt;type&lt;/code&gt;是&lt;code&gt;undefined&lt;/code&gt;或者&lt;code&gt;null&lt;/code&gt;的时候，&lt;code&gt;typeof&lt;/code&gt;操作都不会报错，所以也免去了对输入参数的非空判断的代码，引入闭包还能减少代码数量，快哉！&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>JavaScript instanceof操作符</title>
   <link href="http://username.github.com/2013/07/31/javascript-instanceof"/>
   <updated>2013-07-31T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/31/javascript-instanceof</id>
   <content type="html">&lt;p&gt;JavaScript中的&lt;code&gt;instanceof&lt;/code&gt;操作符通常是用来判断一个对象是否具体“类型”的“实例”，比较常见的用法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (obj instanceof Array) { ... }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家有没有想过这个&lt;code&gt;instanceof&lt;/code&gt;操作符是怎么判断一个对象是否一个“类型”的实例呢？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;instanceof运算符可以用来判断某个构造函数的prototype属性是否存在另外一个要检测对象的原型链上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常来说，一个&lt;code&gt;obj instanceof c&lt;/code&gt;中，会比较&lt;code&gt;obj&lt;/code&gt;的&lt;code&gt;__proto__&lt;/code&gt;是否存在于&lt;code&gt;c&lt;/code&gt;的原型链上。在&lt;a href='http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/'&gt;JavaScript instanceof 运算符深入剖析&lt;/a&gt;中有一段JavaScript代码模拟了&lt;code&gt;instanceof&lt;/code&gt;的执行过程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function instance_of(L, R) {//L 表示左表达式，R 表示右表达式
  var O = R.prototype;// 取 R 的显示原型
  L = L.__proto__;// 取 L 的隐式原型
  while (true) { 
    if (L === null) 
      return false; 
    if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true 
      return true; 
    L = L.__proto__; 
  } 
} &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意哦，同一个对象对同一个构造函数作&lt;code&gt;instanceof&lt;/code&gt;运算的结果不是一成不变的。构造函数的原型链是可以发生改变的，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function A () {}
function B () {}
function C () {}
B.prototype = new A();
var b = new B();
alert(b instanceof B); // true
B.prototype = new C();
alert(b instanceof B); // false
alert(b instanceof A); // true!&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;a href='http://jsfiddle.net/Lzsba/3/'&gt;参考这里&lt;/a&gt;。由于&lt;code&gt;B&lt;/code&gt;的原型链发生变化，令后一个&lt;code&gt;instanceof&lt;/code&gt;的结果发生变化。奇怪的是为什么最后一个&lt;code&gt;instanceof&lt;/code&gt;还是返回的&lt;code&gt;true&lt;/code&gt;？原因是在实例化的时候，&lt;code&gt;b&lt;/code&gt;的原型链指向的是一个&lt;code&gt;A&lt;/code&gt;的实例，即使后面&lt;code&gt;B&lt;/code&gt;的原型指向另一个对象，也不影响已经实例化的&lt;code&gt;b&lt;/code&gt;原型链上的对象，所以沿着&lt;code&gt;b&lt;/code&gt;的原型链还是可以找到&lt;code&gt;A&lt;/code&gt;。而改变原型链可以影响到已经实例化的对象的前提是&lt;strong&gt;往原型对象上附加属性或者更改已有的属性，而不能把原型对象的引用指向一个新的对象&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;即使修改&lt;code&gt;b&lt;/code&gt;的&lt;code&gt;constructor&lt;/code&gt;属性，也不能改变&lt;code&gt;instanceof&lt;/code&gt;的结果，如以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;b.constructor = C;
alert(b instanceof C); // still false&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这应该说明了在进行&lt;code&gt;instanceof&lt;/code&gt;计算的时候，即使手工改变一个对象上的&lt;code&gt;constructor&lt;/code&gt;或者&lt;code&gt;__proto__&lt;/code&gt;不会影响&lt;code&gt;instanceof&lt;/code&gt;的结果。详细的例子&lt;a href='http://jsfiddle.net/vkk8L/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>beforeunload事件</title>
   <link href="http://username.github.com/2013/07/30/beforeunload-event"/>
   <updated>2013-07-30T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/30/beforeunload-event</id>
   <content type="html">&lt;p&gt;去jsFiddle写代码片段的时候，如果没保存又去关闭浏览器的话，会弹出一个浏览器自带的消息框，提示是否要离开这个编辑中的页面。这种类似的功能使用的就是&lt;code&gt;beforeunload&lt;/code&gt;这个事件。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The beforeunload event is fired when the window, the document and its resources are about to be unloaded.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个事件在页面即将被unload的时候触发，并可以通过返回值告诉浏览器是否要弹出消息框。如果返回非空字符串，则浏览器会弹出消息框，并显示返回的字符串；否则这个事件的处理程序会静默地执行。&lt;/p&gt;

&lt;p&gt;注意，这个事件不能让浏览器跳转到某个URL，例如以下的代码是无效的，例子&lt;a href='http://jsfiddle.net/wpMpa/5/show/'&gt;参考这里&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(window).on(&amp;quot;beforeunload&amp;quot;, function () {
  window.location.href = &amp;quot;http://some.other.site&amp;quot;; // 这句代码没有任何作用
  return &amp;quot;Are you sure to leave?&amp;quot;;
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个值得注意的地方是，FireFox、IE跟Safari、Chrome对显示信息的处理方式也不一样。前者是通过事件对象的&lt;code&gt;returnValue&lt;/code&gt;属性去控制显示信息，而后者则是通过&lt;code&gt;return&lt;/code&gt;返回的字符串控制显示信息。以下是一个兼容多个浏览器的写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.addEventListener(&amp;quot;beforeunload&amp;quot;, function (e) {
  var confirmationMessage = &amp;quot;\o/&amp;quot;;
  (e || window.event).returnValue = confirmationMessage;     //Gecko + IE
  return confirmationMessage;                                //Webkit, Safari, Chrome etc.
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个事件的效果不能通过弹出自定义的对话框（例如jQuery UI中的dialog）来模拟同样的效果哦。如果不需要弹出确认框，又需要在页面卸载的时候处理一些逻辑，例如垃圾回收之类的操作，那最好还是绑定&lt;code&gt;unload&lt;/code&gt;事件。以后也会继续讨论&lt;code&gt;unload&lt;/code&gt;事件的用法。&lt;/p&gt;

&lt;p&gt;坚持自己的步伐，不回头，默默地前进，共勉之。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>HTML LINK 标签</title>
   <link href="http://username.github.com/2013/07/29/html-link-tag"/>
   <updated>2013-07-29T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/29/html-link-tag</id>
   <content type="html">&lt;p&gt;我们平常用的最多的&lt;code&gt;link&lt;/code&gt;标签就是引入外部的样式文件。大家有没有想过其实&lt;code&gt;link&lt;/code&gt;还有别的作用。今天就来看看&lt;code&gt;link&lt;/code&gt;究竟还能做些什么东西。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The HTML link Element specifies relationships between the current document and other documents.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上是MDN对&lt;code&gt;link&lt;/code&gt;标签的解释。其实&lt;code&gt;link&lt;/code&gt;标签就是声明文档与文档之间的关系，例如HTML与外部样式文件之间的关系就是&lt;code&gt;stylesheet&lt;/code&gt;的关系。这个标签的属性有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;charset&lt;/code&gt;，声明被链接的文件使用的字符编码。&lt;strong&gt;注意，这个属性在HTML5中已经被HTML文档中的&lt;code&gt;Content-Type&lt;/code&gt;头取代。&lt;/strong&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;href&lt;/code&gt;，声明被链接的文档的URI。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;hreflang&lt;/code&gt;，声明被链接的文档的语言，在&lt;code&gt;href&lt;/code&gt;的值不为空的时候才有效。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;type&lt;/code&gt;，声明这个链接的MIME类型。例如平常使用的外部样式表就是&lt;code&gt;text/css&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;rel&lt;/code&gt;，声明被链接文档与该文档的关系。如&lt;code&gt;stylesheet&lt;/code&gt;，更多的关系请留意下文。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;rev&lt;/code&gt;，声明该文档与被链接文档的关系。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;media&lt;/code&gt;，声明目标样式与设备的关系。响应式设计中的&lt;code&gt;media query&lt;/code&gt;就是基于这个属性来进行媒体查询的。关于媒体查询会在以后的博客中作介绍。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有几个不是标准的属性，&lt;strong&gt;不是每个浏览器都支持哦&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;disabled&lt;/code&gt;，声明链接是否可用，例如可以通过设置值为&lt;code&gt;false&lt;/code&gt;禁用某个外部样式表。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;target&lt;/code&gt;，声明在哪里加载这个外部文档，如&lt;code&gt;a&lt;/code&gt;的&lt;code&gt;target&lt;/code&gt;属性的取值。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有几个HTML5专用的属性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;crossorigin&lt;/code&gt;，声明这个&lt;code&gt;link&lt;/code&gt;标签是否需要使用跨域请求（CROS）来获取。取值范围是&lt;code&gt;anonymous&lt;/code&gt;（匿名访问）或者&lt;code&gt;use-credentials&lt;/code&gt;（需要认证）。如果没有设置这个属性，则会以一般的请求来获取外部文档。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;sizes&lt;/code&gt;，声明icon的大小，必须&lt;code&gt;rel&lt;/code&gt;为&lt;code&gt;icon&lt;/code&gt;才有效。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们最常用的引入外部样式表可以用下面的一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link href=&amp;quot;xxx.css&amp;quot; type=&amp;quot;text/css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; media=&amp;quot;screen&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个情况下只有&lt;code&gt;href&lt;/code&gt;和&lt;code&gt;rel&lt;/code&gt;就可以让外部文档作为一个样式文件加入到当前文档中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link href=&amp;quot;xxx.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后来关注一下&lt;code&gt;rel&lt;/code&gt;（或者&lt;code&gt;rev&lt;/code&gt;）能有哪些取值：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Alternate&lt;/code&gt;，被链接的文档是该文档的替代版本，例如翻译、打印等。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Stylesheet&lt;/code&gt;，被链接的文档是一个外部样式表。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Start&lt;/code&gt;，被链接的文档是文档集合的第一个文档。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Next&lt;/code&gt;，被链接的文档是文档集合的下一个文档。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Prev&lt;/code&gt;，被链接的文档是文档集合的上一个文档。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Contents&lt;/code&gt;，被链接的文档是当前文档的目录。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Index&lt;/code&gt;，被链接的文档是当前文档的索引。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Glossary&lt;/code&gt;，被链接的文档是在文档中使用的词汇的术语表（解释）。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Copyright&lt;/code&gt;，被链接的文档是当前文档的版权信息。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Chapter&lt;/code&gt;，被链接的文档是当前文档的章信息。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Section&lt;/code&gt;，被链接的文档是当前文档的节信息。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Subsection&lt;/code&gt;，被链接的文档是当前文档的小节信息。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Appendix&lt;/code&gt;，被链接的文档是当前文档的附录。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Help&lt;/code&gt;，被链接的文档是当前文档的帮助信息。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Bookmark&lt;/code&gt;，被链接的文档是当前文档的相关文档。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些属性其中一个重要的作用，就是可以通过以上的这些&lt;code&gt;rel&lt;/code&gt;属性的值，可以告诉搜索引擎各个文档之间的关系，方便搜索引擎整理这些文档之间的索引信息。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Secrets of the JavaScript Ninja 读书笔记之 闭包（三）</title>
   <link href="http://username.github.com/2013/07/28/closure-usage-3"/>
   <updated>2013-07-28T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/28/closure-usage-3</id>
   <content type="html">&lt;p&gt;这次读书笔记的最后一篇。今天主要分享即时执行函数的作用。我们知道，在JavaScript中是没有块作用域的（例如&lt;code&gt;if&lt;/code&gt;里面的块），唯一产生作用域的就是函数。常见的制造私有作用域的方法如以下代码所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function () {...})();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;书中强调了两个括号有不同的作用。第一组括号其实是声明了运算的优先级，而第二组括号却是一个运算符，用来执行第一组括号中的匿名函数。比较有趣的用法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.addEventListener(&amp;quot;click&amp;quot;, (function(){
  var numClicks = 0;  
  return function(){
    alert( ++numClicks );
  };
})(), false);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用了闭包，为事件处理程序增加了一个&lt;code&gt;numClicks&lt;/code&gt;的状态。这种写法适用于这个状态只是在这个事件处理程序中使用，可以减少外围作用域中的变量，也可以使代码更加简洁，层次更加清晰。&lt;/p&gt;

&lt;p&gt;通过给即时执行函数传入参数，可以解决一些重名冲突的问题。例如在即时执行函数中使用&lt;code&gt;$&lt;/code&gt;来使用jQuery，而在外部则可以让&lt;code&gt;$&lt;/code&gt;指向另外的变量（例如Prototype框架的&lt;code&gt;$&lt;/code&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function ($, undefined) {...})(jQuery, undefined);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方式也可以解决一些长变量名或者引用层次深的变量的引用问题，也可以帮助JavaScript代码压缩的时候提高压缩比，例如把&lt;code&gt;undefined&lt;/code&gt;压缩成&lt;code&gt;a&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;书中也讲到了一个循环与闭包的常见问题，例如给一系列的DOM元素绑定事件处理程序（不使用jQuery）。通常我们使用&lt;code&gt;for&lt;/code&gt;循环来绑定事件，要注意以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (var i = 0; i &amp;lt; div.length; i++) (function(n){
  div[n].addEventListener(&amp;quot;click&amp;quot;, function(){
    alert(&amp;quot;div #&amp;quot; + n + &amp;quot; was clicked.&amp;quot;);
  }, false);
})(i);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意以上的写法，没有简单调用&lt;code&gt;addEventListener&lt;/code&gt;去绑定事件，而是为每次循环制造了一个闭包来保存迭代子&lt;code&gt;i&lt;/code&gt;的值。这样做才能保证在事件处理程序调用的时候能正确引用正确的&lt;code&gt;i&lt;/code&gt;的值，否则当事件处理程序调用的时候只能获取到迭代子&lt;code&gt;i&lt;/code&gt;最后的状态！&lt;/p&gt;

&lt;p&gt;最后一个点就是在闭包内部，如果需要暴露到全局的对象，要注意这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(){
  var jQuery = window.jQuery = function(){
    // Initialize
  };
  // ...
})();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var jQuery = (function(){
  function jQuery(){
    // Initialize
  }
  // ...
  return jQuery;
})();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写的好处是，如果外部有恶意用户写出&lt;code&gt;jQuery = null&lt;/code&gt;这样的恶意代码，也不影响之前正确使用jQuery的相关功能，因为这样的代码影响的只是全局变量中的jQuery的引用，而不会影响闭包内部逻辑的正确处理，&lt;a href='http://jsfiddle.net/XBy5X/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Secrets of the JavaScript Ninja 读书笔记之 闭包（二）</title>
   <link href="http://username.github.com/2013/07/27/closure-usage-2"/>
   <updated>2013-07-27T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/27/closure-usage-2</id>
   <content type="html">&lt;p&gt;今天接着分享JavaScript闭包的作用。&lt;/p&gt;

&lt;h3 id='memorize'&gt;Memorize&lt;/h3&gt;

&lt;p&gt;在一些需要频繁调用执行效率又比较低的方法可以使用Memorize这个方法，记录每次调用后的结果，下次传入相同的参数就可以直接返回缓存的结果，不需要重新再次执行其逻辑，提高执行效率。书中实现这个Memorize的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Function.prototype.memoized = function(key){
  this._values = this._values || {};
  return this._values[key] !== undefined ?
    this._values[key] :
    this._values[key] = this.apply(this, arguments);
  };
Function.prototype.memoize = function(){
  var fn = this;                        
  return function(){                           
    return fn.memoized.apply( fn, arguments );
  };
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;memoize&lt;/code&gt;这个方法里面，使用闭包记录原始方法，在返回的新方法中让原来的方法附加上Memorize的特性。这样封装了Memorize的具体实现，而且使用起来非常方便，甚至可以为一个匿名方法添加Memorize的功能，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var func = (function (n) { ... }).memoize();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述的例子&lt;code&gt;func&lt;/code&gt;就有了Memorize的功能。&lt;/p&gt;

&lt;h3 id='function_wrapping'&gt;Function Wrapping&lt;/h3&gt;

&lt;p&gt;在写与跨浏览器相关代码的时候，由于不同的浏览器对于特定功能也有不同的实现，经常会写出下面的这种daima :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function func () {
  if (/** is ie  **/) {
    /** do something only in IE **/
  }
  
  if (/** is Opera **/) {
    /** do something only in Opera **/
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无疑太丑陋了！这时可以使用Function Wrapping来为某种浏览器来做特殊处理。书中的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function wrap(object, method, wrapper) {  
  var fn = object[method];              
  return object[method] = function() {         
    return wrapper.apply(this, [fn.bind(this)].concat(
      Array.prototype.slice.call(arguments)));
  };
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里闭包的作用也是记录原始的方法，然后重新为对象上的方法赋值，第一个参数传入原始的参数，以便在重写的方法里面可以调用原始方法的逻辑，有点像装饰模式。通过这中方式把屏蔽浏览器差异相关的代码提取出来，提高代码的可维护性。&lt;/p&gt;

&lt;p&gt;要跟妹纸看电影啦！明天继续！&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Secrets of the JavaScript Ninja 读书笔记之 闭包（一）</title>
   <link href="http://username.github.com/2013/07/26/closure-usage"/>
   <updated>2013-07-26T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/26/closure-usage</id>
   <content type="html">&lt;p&gt;又到读书笔记的时候了！闭包，是JavaScript的重要特性之一，这里不聊什么是闭包，这篇文章主要关注闭包的作用。&lt;/p&gt;

&lt;h3 id='id17'&gt;绑定函数的执行上下文&lt;/h3&gt;

&lt;p&gt;我们知道，为一个DOM元素绑定事件，无论使用原生的&lt;code&gt;addEventListener&lt;/code&gt;或者jQuery的&lt;code&gt;on&lt;/code&gt;，事件处理程序里面的上下文&lt;code&gt;this&lt;/code&gt;都是DOM元素本身。如果把一个对象的方法作为事件处理程序绑定到DOM元素的某个事件上，而这个方法又使用了&lt;code&gt;this&lt;/code&gt;引用这个对象的其他方法，这样触发事件执行处理程序的时候必然会出错。所以我们需要手动把事件处理程序的执行上下文&lt;code&gt;this&lt;/code&gt;改变成这个对象本身，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!Function.prototype.bind) {
  Function.prototype.bind = function (context){
    var fn = this;
    return function(){                                
      return fn.apply(context,arguments);  
    };                                                
  }
｝&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我作了一些小改动，在JavaScript 1.8.5中，&lt;code&gt;bind&lt;/code&gt;已经是&lt;code&gt;Function&lt;/code&gt;原型的方法了。通过闭包把原来的方法记录下来，在返回的匿名函数中调用原来方法的&lt;code&gt;apply&lt;/code&gt;改变执行上下文&lt;code&gt;this&lt;/code&gt;指向的对象，这样就可以手动地改变事件处理程序中的&lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我个人更偏好于使用jQuery的&lt;code&gt;proxy&lt;/code&gt;方法来做这个事情，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&amp;quot;#id&amp;quot;).on(&amp;quot;click&amp;quot;, $.proxy(obj.func, obj));&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保持对象（或者“类”的“实例”）方法中&lt;code&gt;this&lt;/code&gt;的指向永远是该对象本身，对于面向对象的JavaScript来说我认为是十分必要的，可以增加一个“类”中代码的可读性与可维护性。&lt;/p&gt;

&lt;h3 id='id18'&gt;柯里化&lt;/h3&gt;

&lt;p&gt;柯里化就是把一个函数的某些参数预置好，返回一个新的函数，接受没有预置的参数。实现的方式有很多种，如果不通过闭包可以将函数进行二次封装而产生新的函数。纯粹地预置参数，这样做未免有些冗余，如果使用闭包，只需要调用某个&lt;code&gt;curry&lt;/code&gt;函数，传入预置的参数，就可以返回一个新的函数了。这里分享一个比较有意思的实现，它能预置一个函数中任意位置的参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Function.prototype.partial = function() {
  var fn = this, args = Array.prototype.slice.call(arguments);
  return function() {
    var arg = 0;
    for (var i = 0; i &amp;lt; args.length &amp;amp;&amp;amp; arg &amp;lt; arguments.length; i++) {
      if (args[i] === undefined) {
        args[i] = arguments[arg++];
      }
    }
    return fn.apply(this, args);
  };
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过柯里化过程中传入&lt;code&gt;undefined&lt;/code&gt;的位置，预留给结果函数来传入非预置的参数。传给结果函数的参数会像填坑一样把那些之前标识为&lt;code&gt;undefined&lt;/code&gt;的参数填充起来。&lt;/p&gt;

&lt;p&gt;今天就先到这里，闭包的作用还有很多很多，明天继续！&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>HTTP协议之HTTP方法</title>
   <link href="http://username.github.com/2013/07/25/http-method"/>
   <updated>2013-07-25T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/25/http-method</id>
   <content type="html">&lt;p&gt;今天看阿雄写代码，封装与服务器交互的相关工具方法。各种&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;post&lt;/code&gt;、&lt;code&gt;put&lt;/code&gt;、&lt;code&gt;del&lt;/code&gt;的方法，对应各种HTTP方法。&lt;code&gt;get&lt;/code&gt;和&lt;code&gt;post&lt;/code&gt;不用说，看到&lt;code&gt;put&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;的时候，阿雄说这两个方法的参数都不是放在请求体里面。奇怪了，按照常理来说对服务有影响的操作都应该把参数放到请求体里面啊（类似&lt;code&gt;post&lt;/code&gt;），难道不是这样的？&lt;/p&gt;

&lt;p&gt;看W3的规范里面，HTTP协议能使用的方法大概有以下几种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;OPTIONS&lt;/code&gt;，列出当前服务器支持哪些HTTP方法（几乎没有人用这个HTTP方法，不过可以利用这个方法做自文档的Restful服务的查询方法，&lt;a href='http://zacstewart.com/2012/04/14/http-options-method.html'&gt;参考这里&lt;/a&gt;）。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;GET&lt;/code&gt;，最常用的HTTP方法之一，从服务器获取URI指定的资源。资源会放到响应体里面返回。&lt;code&gt;GET&lt;/code&gt;方法获取数据应该是有缓存机制的，通过&lt;code&gt;If-Modified-Since&lt;/code&gt;等HTTP头可以声明当前这个URI对应的信息是否发生变化，如果没有变化则可以使用之前的缓存信息，这样可以减少不必要的网络数据传输。当请求含有&lt;code&gt;Range&lt;/code&gt;头的时候，这次&lt;code&gt;GET&lt;/code&gt;请求所返回的信息是部分的，当分块下载的时候会用到。&lt;strong&gt;注意，&lt;code&gt;GET&lt;/code&gt;请求的参数都是作为查询串放到URL后面，所以当请求参数含有敏感数据的时候千万不要用&lt;code&gt;GET&lt;/code&gt;。&lt;/strong&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;HEAD&lt;/code&gt;，与&lt;code&gt;GET&lt;/code&gt;类似，只是返回的响应体的内容是空的，只包含响应头。这个方法常用作校验有效性、校验权限以及查看信息是否被修改。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;POST&lt;/code&gt;，往URI指定的路径新增一个资源。&lt;code&gt;POST&lt;/code&gt;的参数是放在请求体里面的，一般这个参数就是声明了一个新的资源，例如文件夹里面的一个新文件、邮件列表里面的一个新邮箱或者数据表中的一条新的记录。与我们日常使用的场景不同，如果服务器没有增加新的资源，或者这个请求体是空的，应该返回状态码200或者204；如果服务器正确增加了一个新的资源，应该返回一个201表示资源已经被创建。而我们日常一般就是用200表示服务器已经正确处理请求而已。一般&lt;code&gt;POST&lt;/code&gt;是不会缓存的，除非设置了&lt;code&gt;Cache-Control&lt;/code&gt;或者&lt;code&gt;Expires&lt;/code&gt;头。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;PUT&lt;/code&gt;，分两种情况。如果URI指定的资源不存在，则当&lt;code&gt;POST&lt;/code&gt;处理，往服务器新增一个指定的资源；如果存在，则修改现有的资源，修改成功返回状态码200或者204，修改失败则按照失败的具体原因返回5XX等状态码。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;DELETE&lt;/code&gt;，删除URI指定的资源。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;TRACE&lt;/code&gt;，对可能经过代理服务器传送到服务器上去的报文进行追踪。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;CONNECT&lt;/code&gt;，一个保留的方法，指定代理改变发送请求时使用的协议，例如从HTTP到HTTPS。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面使用&lt;code&gt;jQuery.ajax&lt;/code&gt;方法来看看真实场景下HTTP方法是如何运用的。例子&lt;a href='http://jsfiddle.net/4Y8t2/2/show/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;例子非常简单，就是使用不同的HTTP方法往服务器发送HTTP请求。可以看到&lt;code&gt;GET&lt;/code&gt;和&lt;code&gt;HEAD&lt;/code&gt;的参数是放到查询串（search）上面的。其他方法一律是放到请求体里面。这个例子里面的&lt;code&gt;POST&lt;/code&gt;、&lt;code&gt;PUT&lt;/code&gt;和&lt;code&gt;DELETE&lt;/code&gt;都被服务器拒绝了，返回状态码403（Forbidden）。&lt;/p&gt;

&lt;p&gt;有趣的是，同样一段代码，在IE9上面返回的结果跟Chrome上不一样。主要表现在&lt;code&gt;TRACE&lt;/code&gt;和&lt;code&gt;CONNECT&lt;/code&gt;上。IE9上的&lt;code&gt;TRACE&lt;/code&gt;输出“参数无效”，&lt;code&gt;CONNECT&lt;/code&gt;是403；而Chrome则都是输出一个“DOM Exception 18”，这个往后可以研究一下&lt;code&gt;jQuery.ajax&lt;/code&gt;的具体实现才能看出什么端倪来。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>换行还是不换行之word-break</title>
   <link href="http://username.github.com/2013/07/24/css-word-break"/>
   <updated>2013-07-24T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/24/css-word-break</id>
   <content type="html">&lt;p&gt;再继续前两天的问题，今天介绍另一个影响单词断行的CSS样式&lt;code&gt;word-break&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The word-break property specifies line breaking rules for non-CJK scripts.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;word-break&lt;/code&gt;声明了非CJK单词的断行规则，其中也有属性值是跟CJK单词有关系。这个样式的可选取值有以下几个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;normal&lt;/code&gt;，默认值，单词根据其默认的规则进行断行。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;break-all&lt;/code&gt;，非CJK单词会在一个单词之间断行以防止单词内容溢出。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;keep-all&lt;/code&gt;，保持CJK单词，不让其断行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看样子跟昨天介绍的&lt;code&gt;word-wrap&lt;/code&gt;看上去作用都是差不多的，都是控制单词的断行规则。与&lt;code&gt;word-wrap&lt;/code&gt;类似，&lt;strong&gt;当&lt;code&gt;white-space&lt;/code&gt;声明为不允许自动换行的情况下是没有任何效果的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;word-break&lt;/code&gt;跟&lt;code&gt;word-wrap&lt;/code&gt;主要有以下这几个不同点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Opera和低版本的FireFox（低于15）不支持&lt;code&gt;word-break&lt;/code&gt;，而所有主流的浏览器都支持&lt;code&gt;word-wrap&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;虽然&lt;code&gt;word-break: break-all&lt;/code&gt;和&lt;code&gt;word-wrap: break-word&lt;/code&gt;都是允许断开非CJK单词，但是前者明显暴力于后者。前者会忽略所有排版规则强制断开单词，而后者则会尽最大限度保持现有的排版规则。例子&lt;a href='http://jsfiddle.net/RsUqv/'&gt;参考这里&lt;/a&gt;。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;word-break: keep-all&lt;/code&gt;还特别声明了针对CJK单词的规则，这个是&lt;code&gt;word-wrap&lt;/code&gt;所没有的。&lt;em&gt;（但是&lt;code&gt;keep-all&lt;/code&gt;Chrome和Safari都不支持……）。&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;针对&lt;code&gt;word-break&lt;/code&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当需要强制换行时，设置成&lt;code&gt;break-all&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;当需要强制不换行时，设置成&lt;code&gt;normal&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于换行和不换行的话题暂时先讨论到这里吧。现在总结一下三天的内容：&lt;/p&gt;

&lt;p&gt;如果要强制换行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;white-space: normal;
word-wrap: break-word;
word-break: break-all; /** 超级暴力换行！ **/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要强制不换行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;white-space: nowrap;
word-wrap: normal;
word-break: keep-all;&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>换行还是不换行之word-wrap</title>
   <link href="http://username.github.com/2013/07/23/css-word-wrap"/>
   <updated>2013-07-23T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/23/css-word-wrap</id>
   <content type="html">&lt;p&gt;继续昨天的话题，今天介绍另一个影响文字换行的属性&lt;code&gt;word-wrap&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This property specifies whether the UA may arbitrarily break within a word to prevent overflow when an otherwise-unbreakable string is too long to fit within the line box. &lt;strong&gt;It only has an effect when ‘white-space’ allows wrapping.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;word-wrap&lt;/code&gt;这个属性声明用户代理（一般就是指浏览器）能否从一个单词中间断开，防止这个单词溢出容器。这里值得注意的是，要&lt;code&gt;word-wrap&lt;/code&gt;属性生效，必须让&lt;code&gt;white-space&lt;/code&gt;这个属性允许自动换行（即&lt;code&gt;white-space&lt;/code&gt;的属性只能是&lt;code&gt;normal&lt;/code&gt;、&lt;code&gt;pre-wrap&lt;/code&gt;和&lt;code&gt;pre-line&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;可选的取值有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;normal&lt;/code&gt;，默认值，不允许从一个单词中间断开，显示溢出部分。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;break-word&lt;/code&gt;，如果一行中没有其他可接受的断点，那么将强行断开文本单词。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里的“单词”，指的是非CJK（Chinese、Japanese、Korean）中由若干个字母组成的单词。这个单词是有独立意义的，不同单词使用空格或者&lt;code&gt;-&lt;/code&gt;分开。所以如果随意把超长的单词从中间断开，可能会导致理解上的误差。例子&lt;a href='http://jsfiddle.net/VKP78/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这个属性所有浏览器都支持。IE引入了一个别名叫&lt;code&gt;-ms-word-wrap&lt;/code&gt;，在标准的IE8里面已经支持标准的&lt;code&gt;word-wrap&lt;/code&gt;，所以也不需要加上这个前缀了。&lt;/p&gt;

&lt;p&gt;还有一个值得注意的是，在最近的CSS3规范中，&lt;code&gt;word-wrap&lt;/code&gt;已经被改名叫&lt;code&gt;overflow-wrap&lt;/code&gt;了，在最新的Chrome和Opera中已经支持新名字了哦。在往后的标准实现中，&lt;code&gt;word-wrap&lt;/code&gt;只能作为&lt;code&gt;overflow-wrap&lt;/code&gt;的一个别名存在，太悲催了。&lt;/p&gt;

&lt;p&gt;总结一下，在&lt;code&gt;white-space&lt;/code&gt;声明支持自动换行的情况下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;normal&lt;/code&gt;不会中断一个非CJK单词。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;break-wrod&lt;/code&gt;会最大限度维持排版规则去中断溢出的非CJK单词。&lt;/li&gt;
&lt;/ol&gt;</content>
 </entry>
 
 <entry>
   <title>换行还是不换行之white-space</title>
   <link href="http://username.github.com/2013/07/22/css-white-space"/>
   <updated>2013-07-22T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/22/css-white-space</id>
   <content type="html">&lt;p&gt;今天又给一个换行还是不换行的问题困扰了。决定好好地研究一下块元素中的行内元素是如何控制换行的。主要从几个CSS样式入手，包括&lt;code&gt;white-space&lt;/code&gt;、&lt;code&gt;word-break&lt;/code&gt;等，最后会综合讨论块元素的其他CSS是如何影响行内元素的换行控制。&lt;/p&gt;

&lt;p&gt;今天先看看&lt;code&gt;white-space&lt;/code&gt;这个CSS属性。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The white-space property specifies how white-space inside an element is handled.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;white-space&lt;/code&gt;这个属性是用来声明一个元素内部的空白（包括空格还有换行符等）是如何处理的。可选的取值有以下几个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;normal&lt;/code&gt;，默认值，合并所有空白，当内容接触容器元素边界的时候自动换行。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;nowrap&lt;/code&gt;，与&lt;code&gt;normal&lt;/code&gt;类似，只是不会自动换行&lt;strong&gt;（强制不换行必须配上这个CSS样式）&lt;/strong&gt;。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;pre&lt;/code&gt;，保留所有空白，也不会自动换行。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;pre-wrap&lt;/code&gt;，保留所有空白，会自动换行。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;pre-line&lt;/code&gt;，除了换行符之外的空格合并，会自动换行。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;inherit&lt;/code&gt;，继承父元素的值。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于行内元素来说：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当值是&lt;code&gt;normal&lt;/code&gt;、&lt;code&gt;nowrap&lt;/code&gt;和&lt;code&gt;pre-line&lt;/code&gt;的时候，换行符前后的空白会被删除。&lt;/li&gt;

&lt;li&gt;当值是&lt;code&gt;pre&lt;/code&gt;和&lt;code&gt;pre-wrap&lt;/code&gt;的时候，多个空格组成的序列不会在遇到元素边缘的时候被中断。而&lt;code&gt;pre-wrap&lt;/code&gt;则会在序列的最后自动换行。&lt;/li&gt;

&lt;li&gt;当值是&lt;code&gt;normal&lt;/code&gt;和&lt;code&gt;nowrap&lt;/code&gt;的时候，换行符会被转化成一个空格、一个长度为0的字符串或者压根不显示，具体如何转化需要看浏览器的实现算法。&lt;/li&gt;

&lt;li&gt;当值是&lt;code&gt;normal&lt;/code&gt;、&lt;code&gt;nowrap&lt;/code&gt;和&lt;code&gt;pre-line&lt;/code&gt;的时候，制表符会被转化成一个空格，多个连续的空格会被归并成一个空格。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在W3上讲了一个比较有意思的例子，就是涉及到文字阅读方向的问题。假如存在下面的一段HTML片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ltr&amp;gt;A[1]&amp;lt;rtl&amp;gt;[2]B[3]&amp;lt;/rtl&amp;gt;[4]C&amp;lt;/ltr&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中1、2、3、4是4个空格，&lt;code&gt;white-space&lt;/code&gt;是&lt;code&gt;normal&lt;/code&gt;。理论上1和2会合并，3和4会合并。但是出来的结果确是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A[12][34]BC&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因就是文字阅读方向杂糅（虽然这个场景在实际应用之中少之又少）。空格12是左往右读的，空格34是右往左读的，这个顺序跟HTML中的顺序是保持一致的。所以，避免出现上述情况的混淆，W3建议&lt;strong&gt;在一个元素的开始和结尾不要写空白&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;总结一下，单就&lt;code&gt;white-space&lt;/code&gt;这个CSS样式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;强制换行，需要设置成&lt;code&gt;normal&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;强制不换行，需要设置成&lt;code&gt;nowrap&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;</content>
 </entry>
 
 <entry>
   <title>HTTP协议之简述一个HTTP请求的经过</title>
   <link href="http://username.github.com/2013/07/21/a-http-request"/>
   <updated>2013-07-21T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/21/a-http-request</id>
   <content type="html">&lt;p&gt;之前已经科普过HTTP的请求/响应头还有HTTP状态码，今天简单的看看一个HTTP请求的过程。&lt;/p&gt;

&lt;p&gt;先来根据W3的HTTP 1.1官方规范来看一些术语：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;连接（connection），指的是两个程序为了通讯而建立的一个“虚拟”的通道。&lt;/li&gt;

&lt;li&gt;客户端（client），指的是发出HTTP请求的一方。&lt;/li&gt;

&lt;li&gt;服务端（server），指的是接收HTTP请求并返回HTTP响应的一方。&lt;/li&gt;

&lt;li&gt;代理（proxy），指的是接收HTTP请求，作出一些处理（例如翻译），然后发送HTTP请求到某个特定的服务端的中间件。&lt;/li&gt;

&lt;li&gt;网关（gateway），与代理类似，不过它更着重于一个“关口”的概念，把接收到的HTTP请求继续传递给其下级子网来进行处理。&lt;/li&gt;

&lt;li&gt;隧道（tunnel），与代理类似，不过它更着重于一个“透传”的概念，把接收到HTTP请求直接透传到某个特定的服务端中间件。&lt;/li&gt;

&lt;li&gt;缓存（cache），一个本地存储及其管理系统，程序可以根据特定的机制决定是否在服务端真正地进行处理作为响应还是直接读取本地存储中的内容作为响应。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;术语还有很多，详情可以&lt;a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec1.html'&gt;参考这里&lt;/a&gt;。同学们如果发现英文翻译有误的请赶紧拍砖啊。&lt;/p&gt;

&lt;p&gt;现在来看看一个HTTP请求究竟经历了哪些步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;建立连接，客户端会根据服务器的ip地址和端口号与服务器建立socket连接。&lt;/li&gt;

&lt;li&gt;客户端发送一个HTTP请求，里面的HTTP请求头会包含一些这个请求的信息，例如URI、HTTP方法等。&lt;/li&gt;

&lt;li&gt;服务器根据请求的内容进行处理，并返回一个HTTP响应。&lt;/li&gt;

&lt;li&gt;客户端接收HTTP响应，关闭socket连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样，一个最简单的HTTP请求就完成了。现实中的场景可能会比较复杂，例如一个HTTP请求，经过N个中间件（例如代理、网关和隧道），转发了N+1这么多次才到达真正要处理这个请求的服务器。而每一个中间件也有可能把接收到的HTTP请求进行转发，转发到更多的服务器上面进行处理。&lt;/p&gt;

&lt;p&gt;为了提高转发的效率，每一个中间件，包括发出请求的客户端，还有最后真正处理请求的服务端，都可以进行缓存。当其中一个中间件判断这个请求的缓存可用的情况下，这个HTTP请求就不会再被转发到下一个中间件，而是直接返回，这样能大大地减少网络带宽和请求处理的时间。&lt;/p&gt;

&lt;p&gt;HTTP协议相关的内容实在太多了，还有HTTP请求、HTTP响应，MIME类型等等等等。再次引用一个前同事的话，当遇到一个与浏览器或者Web服务器相关的疑难问题攻不下来，这时不妨看看对应的规范，才能了解浏览器或者是Web服务器为什么要这样实现，说不定会有种豁然开朗的感觉。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Secrets of the JavaScript Ninja 读书笔记之 JavaScript重载</title>
   <link href="http://username.github.com/2013/07/20/javascript-overload"/>
   <updated>2013-07-20T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/20/javascript-overload</id>
   <content type="html">&lt;p&gt;今天来点轻松的，分享一个之前的读书笔记。我们知道，JavaScript是不支持重载的。后面定义的重名函数，无论参数的个数是否一样，都会把前面已经定义的重名函数给覆盖掉。要想实现类似Java中的重载机制，一般只能把所有的逻辑都写在同一个函数里，类似这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var ninja = {
    whatever: function() {
        switch (arguments.length) {
        case 0:
            /* do something */
            break;
        case 1:
            /* do something else */
            break;
        case 2:
            /* do yet something else */
            break;
        //and so on ...
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据&lt;code&gt;arguments.length&lt;/code&gt;这个属性，可以判断当前调用这个函数的时候传入了多少个参数，根据参数的个数判断应该执行什么逻辑。这种方式虽然简单，但是如果以后扩展的时候需要再增加一个重载的逻辑，就需要增加一个&lt;code&gt;case&lt;/code&gt;分支，这样是违背了开放封闭原则的，提高了维护的成本（估计大家也不想看到铺天盖地的&lt;code&gt;case&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们尝试使用一种新的思路去分析。首先，需要提供自定义的重载机制，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var ninja = {};
addMethod(ninja,&amp;#39;whatever&amp;#39;,function(){ /* do something */ });
addMethod(ninja,&amp;#39;whatever&amp;#39;,function(a){ /* do something else */ });
addMethod(ninja,&amp;#39;whatever&amp;#39;,function(a,b){ /* yet something else */ });&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;addMethod&lt;/code&gt;接受三个参数：&lt;/p&gt;

&lt;p&gt;1. 一个对象，对象上有需要重载的方法。&lt;/p&gt;

&lt;p&gt;2. 这个对象上需要重载的方法名。&lt;/p&gt;

&lt;p&gt;3. 重载方法。&lt;strong&gt;注意，这里的重载方法声明时的参数个数必须与之前定义过的重载方法的参数个数不一样。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;调用的时候，我们可以通过传入的参数个数不同而调用不同的重载方法。实现上面的机制使用了一个非常巧妙的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function addMethod(object, name, fn) {
    var old = object[name];                  
    object[name] = function(){              
        if (fn.length == arguments.length)       
            return fn.apply(this, arguments)       
        else if (typeof old == &amp;#39;function&amp;#39;)      
            return old.apply(this, arguments);    
    };
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的实现使用了&lt;code&gt;fn.length&lt;/code&gt;这个属性。这个属性表示的是方法定义的形参的个数。通过判断形参的个数来决定调用哪个重载的方法。其中最巧妙的地方就是使用了一个闭包，把上一个重载方法记录下来。如果这次调用时传入的参数的个数刚好等于最后一个定义的重载方法的形参个数，就直接调用这个重载方法，否则就调用上一个重载方法。这样，每加入一个重载方法，都会按照同样的逻辑进行调用，当参数个数匹配的时候就会调用相应的重载方法。实在是太妙了！&lt;/p&gt;

&lt;p&gt;下面是书中的例子，我把它放到JSFiddle里面，可以&lt;a href='http://jsfiddle.net/d5yRU/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;虽然这种重载只能根据参数的个数进行重载，不能完全实现像Java一样的可以根据参数类型进行重载的机制，但是也是JavaScript向着完整面向对象程序设计伟大的一步。这种机制提供了一个强大的工具让我们继续重构、继续优化现有的代码。&lt;/p&gt;

&lt;p&gt;这种重载方式会带来额外的性能开销，如果对性能的要求非常高的场景还是慎用。但是，这种重载方式提高了代码的可维护性，在可以使用的地方就尽管大胆的用吧！&lt;/p&gt;

&lt;p&gt;看完了这个JavaScript重载，深深感觉到JavaScript中的闭包、函数是多么的灵活，也感叹于作者对于JavaScript这些特性的深入理解。最后再次强烈推荐这本jQuery之父，Jhon Resig编写的《Secrets of the JavaScript Ninja》。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>再谈CSS等高布局</title>
   <link href="http://username.github.com/2013/07/19/css-equal-height-again"/>
   <updated>2013-07-19T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/19/css-equal-height-again</id>
   <content type="html">&lt;p&gt;之前写过一篇CSS等高布局相关的文章，讲的是使用负外边距和内边距的相互抵消做出来的一个“障眼法”。大湿看过之后立马表示有更科学的办法实现，就是CSS3的&lt;code&gt;box-flex&lt;/code&gt;。今天再来回顾一下到底还有什么方法实现CSS等高布局。&lt;/p&gt;

&lt;h3 id='display_box'&gt;display: box&lt;/h3&gt;

&lt;p&gt;通过&lt;code&gt;display: box&lt;/code&gt;声明该元素的盒模型是一个弹性的盒模型，与CSS2中的盒模型是不一样的。其内部元素可以通过设置&lt;code&gt;box-flex&lt;/code&gt;来声明其空间占的比例是多少。&lt;/p&gt;

&lt;p&gt;简单看一下声明了&lt;code&gt;display: box&lt;/code&gt;之后该元素还能设置CSS属性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;box-orient&lt;/code&gt;，声明其内部元素的排列方向，可选的值有&lt;code&gt;horizontal&lt;/code&gt;、&lt;code&gt;vertical&lt;/code&gt;、&lt;code&gt;inline-axis&lt;/code&gt;、&lt;code&gt;block-axis&lt;/code&gt;、&lt;code&gt;inherit&lt;/code&gt;。默认值是&lt;code&gt;inline-axis&lt;/code&gt;，所以在&lt;code&gt;diplay: box&lt;/code&gt;元素内部的子元素都会表现得像行内元素一般的行为。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;box-direction&lt;/code&gt;，声明其内部元素的排列顺序，可选的值有&lt;code&gt;normal&lt;/code&gt;、&lt;code&gt;reverse&lt;/code&gt;、&lt;code&gt;inherit&lt;/code&gt;。通过设置&lt;code&gt;reverse&lt;/code&gt;可以把元素的顺序反转过来。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;box-align&lt;/code&gt;，声明其内部元素的垂直对齐方式（有点类似&lt;code&gt;vertical-align&lt;/code&gt;），可选的值有&lt;code&gt;start&lt;/code&gt;、&lt;code&gt;end&lt;/code&gt;、&lt;code&gt;center&lt;/code&gt;、&lt;code&gt;baseline&lt;/code&gt;、&lt;code&gt;stretch&lt;/code&gt;。&lt;strong&gt;默认值&lt;code&gt;stretch&lt;/code&gt;就是拉伸其子元素让其高度（或者宽度）一致，所以在&lt;code&gt;display: box&lt;/code&gt;下使用&lt;code&gt;box-flex&lt;/code&gt;就可以做出等高的效果。&lt;/strong&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;box-pack&lt;/code&gt;，声明其内部元素的对齐方式（有点类似&lt;code&gt;text-align&lt;/code&gt;），可选的值有&lt;code&gt;start&lt;/code&gt;、&lt;code&gt;end&lt;/code&gt;、&lt;code&gt;center&lt;/code&gt;、&lt;code&gt;justify&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;box-flex&lt;/code&gt;用来声明子元素占父元素内部的空间，其值是一个大于1的整数。当一个弹性盒模型计算其内部元素占用的空间时，优先计算显式声明了&lt;code&gt;width&lt;/code&gt;（以默认排列方向为例）的元素，其占用的空间就是&lt;code&gt;width&lt;/code&gt;声明的空间。然后根据&lt;code&gt;box-flex&lt;/code&gt;这个属性的权重值去设置该子元素的占用的空间。&lt;/p&gt;

&lt;p&gt;一个简单的例子&lt;a href='http://jsfiddle.net/gt8rN/1/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这个方法的优点是代码简洁、功能强大。缺点则是CSS3面临的其中一个严重的缺点：老版本的IE不支持CSS3（甚至IE9也不支持，太惨烈了）。&lt;/p&gt;

&lt;h3 id='display_table'&gt;display: table&lt;/h3&gt;

&lt;p&gt;看了这个标题，仿佛又回到了那个使用&lt;code&gt;table&lt;/code&gt;做布局的石器时代。很多人反对使用&lt;code&gt;table&lt;/code&gt;作为布局工具，但是有没有想过究竟为什么不使用&lt;code&gt;table&lt;/code&gt;来布局？因为&lt;code&gt;table&lt;/code&gt;布局不具有语义。这个不是一个表，是一个布局，所以用&lt;code&gt;table&lt;/code&gt;是不合适的。但是反过来看，这里说的&lt;code&gt;table&lt;/code&gt;只得是HTML中的&lt;code&gt;table&lt;/code&gt;标签。可以通过CSS，使元素能像表格一样布局，而又可以保持元素原来的语义，这样何乐而不为呢？&lt;/p&gt;

&lt;p&gt;首先使用最经典的HTML模式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;left&amp;quot; class=&amp;quot;col&amp;quot;&amp;gt;This is left&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;middle&amp;quot; class=&amp;quot;col&amp;quot;&amp;gt;This is middle&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;right&amp;quot; class=&amp;quot;col&amp;quot;&amp;gt;This is right&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加两行简单的CSS：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container { display: table; width: 100%; }
.col { display: table-cell; }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来了！等！高！布！局！&lt;/p&gt;

&lt;p&gt;其实就是把上面的HTML片段当成一个表格来进行布局了，简单不，兴奋不？所有适用于表格布局的CSS设置方式都适用于这里。&lt;/p&gt;

&lt;p&gt;这个方法的优点是代码简洁，兼容性比上面的好一点（IE8、IE9都支持，可怜的IE6、IE7……）。缺点是门槛高，要详细理解表格是怎么布局的，不然很难达到精确布局的效果。&lt;/p&gt;

&lt;p&gt;一个简单的例子&lt;a href='http://jsfiddle.net/TvYgB/1/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;感谢黄大湿抽出宝贵的事件看小弟的技术唠叨，还提出了不少关于如何改进这个博客跟微信之间的互动建议。希望大家也多来拍个砖，小弟在这里谢谢大家啦！&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>神奇的负边距</title>
   <link href="http://username.github.com/2013/07/18/negative-margin"/>
   <updated>2013-07-18T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/18/negative-margin</id>
   <content type="html">&lt;p&gt;之前写过一篇&lt;a href='http://dafeizizhu.github.io/2013/07/08/three-column-layout-middle-first/'&gt;《经典三列布局之如何让中间的列先显示出来》&lt;/a&gt;，里面讲的就是使用浮动、相对定位和负边距来做的一套布局。写那篇文章的时候还没太搞懂负边距是怎么回事，今天简单分析一下对不同元素（正常、浮动、绝对定位等）的负边距是如何起作用的。&lt;/p&gt;

&lt;p&gt;首先明确几点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;负边距是完全合法的CSS写法，W3允许边距的值是负值。&lt;/li&gt;

&lt;li&gt;负边距不属于CSS hack。&lt;/li&gt;

&lt;li&gt;a负边距不会使元素脱离文档流。&lt;/li&gt;

&lt;li&gt;所有现代浏览器都支持负边距（IE6也部分支持，太棒了！）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简单看看负边距的工作原理：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在&lt;code&gt;top&lt;/code&gt;和&lt;code&gt;left&lt;/code&gt;方向上应用负边距，该元素会向指定的方向移动，随后的元素也会跟着一起移动。&lt;/li&gt;

&lt;li&gt;在&lt;code&gt;bottom&lt;/code&gt;和&lt;code&gt;right&lt;/code&gt;方向上应用负边距，该元素的位置不会发生任何移动，但是随后的元素会挤压过来，看上去的效果就是该元素占的空间变小了。&lt;/li&gt;

&lt;li&gt;当该元素没有应用宽度（&lt;code&gt;width: auto&lt;/code&gt;也算），为该元素设置&lt;code&gt;left&lt;/code&gt;和&lt;code&gt;right&lt;/code&gt;方向上的负边距会让元素的宽度边大。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;负边距有什么用呢？其中最重要的一个作用我认为是把DOM树中较后出现的元素显示在页面较前的位置。我们知道HTML解析DOM树的时候是根据书写的顺序解析的。而文档的解析顺序是从上到下，从左到右（当然方向是&lt;code&gt;ltr&lt;/code&gt;）的，那么正常书写的N列布局肯定是第一列写在最前边，但是可能我们需要中间第n列先解析，这时候就要把第n列的内容书写在前边，通过负边距调整位置，达到理想的效果。&lt;/p&gt;

&lt;p&gt;现在分析一下之前写过的那篇文章中，左列的CSS究竟是如何达到最后的效果的。现来看看左列的CSS代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#left {
    position: relative; // 1
    left: -100px;       // 2
    float: left;        // 3
    margin-left: -100%; // 4   
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个元素分别使用了浮动、相对定位和负边距三种方式进行布局。现在按负边距、浮动、相对定位的顺序加上CSS，效果为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;加上负边距，该元素向左移动，移动的距离跟父元素的宽度一致。注意，这里的宽度是指&lt;strong&gt;内容宽度&lt;/strong&gt;，即不算&lt;code&gt;padding&lt;/code&gt;、&lt;code&gt;border&lt;/code&gt;和&lt;code&gt;margin&lt;/code&gt;的宽度。&lt;/li&gt;

&lt;li&gt;加上浮动，该元素与&lt;code&gt;middle&lt;/code&gt;两个元素都变成浮动元素，负边距使得该元素沿着浮动方向位移了父元素的宽度，效果是该元素的左边界与&lt;code&gt;middle&lt;/code&gt;的左边界重合。&lt;/li&gt;

&lt;li&gt;最后加上相对定位，让该元素相对于其现有位置再向左移动与其宽度相等的距离。最后的效果就是该元素移动到&lt;code&gt;middle&lt;/code&gt;元素的左侧。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;利用负边距，还能做出很多有趣的效果，例如一些层叠效果，如标签页、印章等。与其他CSS样式结合起来更是有趣。&lt;/p&gt;

&lt;p&gt;今天在工作中也利用了之前写的三列布局的知识。用心沉淀，再返回到实践中，这种感觉真好。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>响应式设计入门之viewport</title>
   <link href="http://username.github.com/2013/07/17/viewport"/>
   <updated>2013-07-17T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/17/viewport</id>
   <content type="html">&lt;p&gt;今天为我的博客加入了一些响应式设计的要素，现在妈妈再也不用担心我的微信中阅读原文之后布局全乱了。说白了就是使用了两个响应式设计相关的技术：&lt;code&gt;viewport&lt;/code&gt;和&lt;code&gt;media query&lt;/code&gt;而已。今天先写一下为什么需要viewport，viewport这个东西怎么用。&lt;/p&gt;

&lt;h3 id='id13'&gt;背景&lt;/h3&gt;

&lt;p&gt;先看看w3的定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This specification introduces a way of overriding the size of the viewport provided by the user agent (UA).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于移动终端的分辨率一般比桌面浏览器的分辨率要小，移动终端上的浏览器通常会把页面放入一个虚拟的“视口“中，让页面的内容缩小以适配该移动终端的分辨率，用户可以通过缩放和移动来查看整个页面的全部内容。Safari引入&lt;code&gt;viewport&lt;/code&gt;这个&lt;code&gt;meta&lt;/code&gt;头，旨在让开发人员控制视口的大小和缩放。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;code&gt;body&lt;/code&gt;元素（如果不是HTML和XHTML的文档则是根元素）中的&lt;code&gt;direction&lt;/code&gt;会影响缩放时的原点（&lt;code&gt;ltr&lt;/code&gt;是左上角，&lt;code&gt;rtl&lt;/code&gt;是右上角）。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id='id14'&gt;用法&lt;/h3&gt;

&lt;p&gt;来个最简单的&lt;code&gt;viewport&lt;/code&gt;使用例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1, maximum-scale=1&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;声明一个&lt;code&gt;meta&lt;/code&gt;头，&lt;code&gt;name&lt;/code&gt;是&lt;code&gt;viewport&lt;/code&gt;，其中的&lt;code&gt;content&lt;/code&gt;是一个逗号分隔的键值对列表。可供设置的键值对有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;width&lt;/code&gt;，视口宽度，数字表示绝对宽度，如&lt;code&gt;width=900&lt;/code&gt;，也可以使用字符串常量&lt;code&gt;device-width&lt;/code&gt;表示设备的横向分辨率。在iOS的Safari上默认值是980。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;height&lt;/code&gt;，视口宽度，与&lt;code&gt;width&lt;/code&gt;类似。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;initial-scale&lt;/code&gt;，初始化的缩放比例，如&lt;code&gt;initial-scale=1&lt;/code&gt;表示初始缩放比例为1。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;maximun-scale&lt;/code&gt;，最大缩放比例。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;minimun-scale&lt;/code&gt;，最小缩放比例。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;user-scalable&lt;/code&gt;，配置用户是否能缩放。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注：当设备的方向发生变化时，&lt;code&gt;device-width&lt;/code&gt;和&lt;code&gt;device-height&lt;/code&gt;也会相应的变化。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id='id15'&gt;总结&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;viewport&lt;/code&gt;可以使移动终端上页面的展示符合响应式设计的显示效果。换句话来说，如果没有使用响应式设计，要慎重设置初始缩放比例、最大缩放比例等参数，不然很有可能用户不能看清页面所有内容了。&lt;/p&gt;

&lt;h3 id='id16'&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href='http://developer.apple.com/library/safari/#documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html'&gt;Configuring the Viewport&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='view-source:https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag'&gt;Using the viewport meta tag to control layout on mobile browsers - Mozilla | MDN&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://dev.w3.org/csswg/css-device-adapt/#the-viewport'&gt;CSS Device Adaptation&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>CSS等高布局</title>
   <link href="http://username.github.com/2013/07/16/css-equal-hight"/>
   <updated>2013-07-16T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/16/css-equal-hight</id>
   <content type="html">&lt;p&gt;今天本来想写express的，不过还没看清楚它的文档，以免误人子弟，先放一下。今天来写一个以前遗留的问题，CSS三列布局如何等高。&lt;/p&gt;

&lt;p&gt;接着上次写的“经典三列布局之如何让中间的列先显示出来“的代码，&lt;a href='http://jsfiddle.net/zBXbp/7/'&gt;参考这里&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;HTML：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;middle&amp;quot;&amp;gt;This is middle!&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;left&amp;quot;&amp;gt;This is left!&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;right&amp;quot;&amp;gt;This is right!&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#left { width: 100px; background: red;}
#right { width: 100px; background: blue;}
#middle { width: 100%; background: green;}

#container { 
    position: relative;
    padding: 0 100px;
    overflow: hidden;
    margin: 0 auto;
}

#middle {
    float: left;
}

#left {
    position: relative;
    left: -100px;
    float: left;
    margin-left: -100%;   
}

#right {
    float: left;
    margin-right: -100%;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从效果看来，虽然左右固定像素、中间自适应的布局是实现了，但是可以看到，三列的高也“自适应”了，非常难看。怎么能这三列等高显示呢？&lt;/p&gt;

&lt;p&gt;首先，绝对的等高，出了用JavaScript之外，用HTML、CSS实现是不行的。所以这个只能看上去“等高”。我们的目的就是让这三列的背景色等高。参考了一些网上的资料，最简单的方法是加入以下一条样式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#left, #middle, #right {
    margin-bottom: -10000px;
    padding-bottom: 10000px;
} &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原理看似简单又不简单，最好的解释可以参考这里：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;首先把列的padding-bottom设为一个足够大的值，再把列的margin-bottom设一个与前面的padding-bottom的正值相抵消的负值，父容器设置超出隐藏，这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到它里面最高那列的高度，其他比这列矮的列则会用它们的padding-bottom来补偿这部分高度差。因为背景是可以用在padding占用的空间里的，而且边框也是跟随padding变化的，所以就成功的完成了一个障眼法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;效果&lt;a href='http://jsfiddle.net/3depS/1/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这个方案也有缺点，当需要用&lt;code&gt;border&lt;/code&gt;显示边框的时候，边框是不能自适应的。只能通过背景的层叠模拟边框的效果。能否不通过JavaScript解决，留一个遗留问题。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>模拟触发DOM事件之jQuery trigger</title>
   <link href="http://username.github.com/2013/07/15/event-constructor-and-jquery-trigger"/>
   <updated>2013-07-15T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/15/event-constructor-and-jquery-trigger</id>
   <content type="html">&lt;p&gt;昨天写了一下&lt;code&gt;document.createEvent&lt;/code&gt;这个方法，并描述了如何使用该方法模拟DOM事件。今天看看MDN建议的&lt;code&gt;Event&lt;/code&gt;构造函数，以及jQuery是如何处理&lt;code&gt;trigger&lt;/code&gt;的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Event&lt;/code&gt;构造函数接受两个参数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;表示事件类型的字符串，如&lt;code&gt;click&lt;/code&gt;、&lt;code&gt;change&lt;/code&gt;甚至是自定义的字符串。&lt;/li&gt;

&lt;li&gt;事件的附加属性，用一个JavaScript对象表示，如&lt;code&gt;{ &amp;quot;a&amp;quot;: &amp;quot;something additional&amp;quot; }&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于简化了事件附加属性的设置，不需要像&lt;code&gt;document.createEvent&lt;/code&gt;那样分开各种事件类型，并且使用不同的&lt;code&gt;init&lt;/code&gt;方法。下面给出一个MDN上面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var event = new Event(&amp;#39;build&amp;#39;);

// Listen for the event.
elem.addEventListener(&amp;#39;build&amp;#39;, function (e) { ... }, false);

// Dispatch the event.
elem.dispatchEvent(event);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Event&lt;/code&gt;构造函数在绝大部分的现代浏览器里面都支持（IE9也支持，可怜的IE8）。如果要兼容老版本的IE浏览器，需要使用昨天的&lt;code&gt;document.createEvent&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;现在来看看jQuery的&lt;code&gt;trigger&lt;/code&gt;方法，是如何实现跨浏览器模拟触发DOM事件的。&lt;/p&gt;

&lt;p&gt;看了源码我震惊了，jQuery完全没有使用上述任何一个API，包括&lt;code&gt;document.createEvent&lt;/code&gt;和&lt;code&gt;Event&lt;/code&gt;构造函数。jQuery使用的是自定义的事件对象&lt;code&gt;jQuery.Event&lt;/code&gt;，里面包括了原生事件里面的所有属性和方法（封装了浏览器的差异），以及一些jQuery的扩展属性。当使用&lt;code&gt;trigger&lt;/code&gt;时，jQuery会遍历这个DOM元素的事件冒泡路径，就是这个DOM元素在DOM树里面的完整路径。然后收集在DOM树上所有这个事件的处理程序，根据冒泡的顺序触发对应的事件处理程序。整个过程都没有使用DOM原生的模拟事件。&lt;/p&gt;

&lt;p&gt;有趣的是，即使不是使用jQuery绑定的事件，都可以通过&lt;code&gt;trigger&lt;/code&gt;触发，这个是由于有以下两段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;handle = ontype &amp;amp;&amp;amp; cur[ ontype ];
if ( handle &amp;amp;&amp;amp; jQuery.acceptData( cur ) &amp;amp;&amp;amp; handle.apply &amp;amp;&amp;amp; handle.apply( cur, data ) === false ) {
    event.preventDefault();
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tmp = elem[ ontype ];
if ( tmp ) {
    elem[ ontype ] = null;
}
// Prevent re-triggering of the same event, since we already bubbled it above
jQuery.event.triggered = type;
elem[ type ]();
jQuery.event.triggered = undefined;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;elem&lt;/code&gt;上面属性可以获取到通过&lt;code&gt;onXXX&lt;/code&gt;（DOM2）以及&lt;code&gt;addEventListener&lt;/code&gt;（DOM3）绑定的事件处理程序，并执行它们。可以&lt;a href='http://jsfiddle.net/qxAz8/2/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;今天终于收到offer了，下个月就离开我司。最后享受这一个月的时光吧，fight！&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>模拟触发DOM事件之原生模拟事件</title>
   <link href="http://username.github.com/2013/07/14/simulate-event"/>
   <updated>2013-07-14T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/14/simulate-event</id>
   <content type="html">&lt;p&gt;昨天讲到一个如何在测试的时候模拟一个DOM事件，例如单击鼠标、输入文字等。当时我第一反应就是使用jQuery的&lt;code&gt;trigger&lt;/code&gt;方法触发事件，那哥们竟然说了一个原生的API：&lt;code&gt;document.createEvent&lt;/code&gt;。当时我就震惊了，为啥不用jQuery哦亲。今天先简单了解一下这个API的作用，科普科普。&lt;/p&gt;

&lt;p&gt;先看看MDN上面对&lt;code&gt;document.createEvent&lt;/code&gt;的说明是啥：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Creates an event of the type specified. The returned object should be first initialized and can then be passed to element.dispatchEvent.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个API是创建一个Event对象，接受一个参数，就是表示事件类型的字符串。该字符串的可能取值为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;UIEvent&lt;/code&gt;，通用的UI事件，键盘鼠标事件都是继承于这个事件。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;MouseEvent&lt;/code&gt;，鼠标事件。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;MutationEvent&lt;/code&gt;，通用的突变事件。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;HTMLEvent&lt;/code&gt;，通用的HTML事件。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用该API创建出事件对象之后，需要在触发模拟事件的DOM上调用&lt;code&gt;dispatchEvent&lt;/code&gt;方法，触发该模拟事件。MDN的实例代码如下，&lt;a href='http://developer.mozilla.org/samples/domref/dispatchEvent.html'&gt;参考这里&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function simulateClick() {
    var evt = document.createEvent(&amp;quot;MouseEvents&amp;quot;);
    evt.initMouseEvent(&amp;quot;click&amp;quot;, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
    var cb = document.getElementById(&amp;quot;checkbox&amp;quot;); 
    var canceled = !cb.dispatchEvent(evt);
    if(canceled) {
        // A handler called preventDefault
        alert(&amp;quot;canceled&amp;quot;);
    } else {
        // None of the handlers called preventDefault
        alert(&amp;quot;not canceled&amp;quot;);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;dispatchEvent&lt;/code&gt;会返回该事件是否取消浏览器默认行为的布尔值。&lt;/p&gt;

&lt;p&gt;注意哦，不同类型的Event对象使用的初始化方法也不同，上述的四个事件类型对应的初始化事件的方法分别是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;initUIEvent&lt;/code&gt;，初始化基本UI事件，该方法接受事件类型、是否冒泡、是否能取消默认行为、关联的视图（window）、详细信息（如鼠标单击事件鼠标被单击多少次）等参数。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;initMouseEvent&lt;/code&gt;，初始化鼠标事件，前五个参数与&lt;code&gt;initUIEvent&lt;/code&gt;类似，后面有鼠标位置相对于屏幕的坐标、相对于client的坐标、修饰键、哪个鼠标按键被按下以及鼠标移入或者移出的DOM对象。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;initMutationEvent&lt;/code&gt;，初始化通用突变事件。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;initEvent&lt;/code&gt;，初始化HTML通用事件，与&lt;code&gt;initUIEvent&lt;/code&gt;的前三个参数类似。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;initKeyboardEvent&lt;/code&gt;，这个是键盘事件对应事件类型，可以在&lt;code&gt;createEvent&lt;/code&gt;方法中传入&lt;code&gt;KeyboardEvent&lt;/code&gt;来创建键盘事件，该事件继承于&lt;code&gt;UIEvent&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;更详细的信息请猛击&lt;a href='https://developer.mozilla.org/en-US/docs/Web/API/document.createEvent'&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;一个值得注意的地方是，MDN上有这么一个警告：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The createEvent method is deprecated. Use event constructors instead.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;原来这个方法已经被废弃了，MDN建议使用Event的构造方法来创建Event对象。明天将继续研究Event的构造方法以及jQuery的&lt;code&gt;trigger&lt;/code&gt;方法是如何实现的。&lt;/p&gt;

&lt;p&gt;两天的阿里D2结束了，接收到不少干货，也走了西湖，匆忙的旅行也算是比较满足了。两天的演讲里面，让我真的非常佩服于阿里人的演讲水平。一些本来是非常好的干货，讲得太干了原来也让人难以下咽。借用一个前同事的话来总结：程序员发展到一定的水平后，瓶颈并不在技术水平上，而是在表达能力上。再见啦杭州，下次一定会再来！&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>HTTP协议之HTTP状态码</title>
   <link href="http://username.github.com/2013/07/13/http-status-code"/>
   <updated>2013-07-13T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/13/http-status-code</id>
   <content type="html">&lt;p&gt;继续HTTP协议科普贴。讲一下HTTP状态码，这个已经被人问过N次了。记得上次只能答出200、304、404、503等，然后被深深的鄙视。HTTP状态码表示该HTTP响应状态的三位数字代码，所有状态的第一个数字表示的是同一类的状态。&lt;/p&gt;

&lt;h3 id='1xx'&gt;1XX&lt;/h3&gt;

&lt;p&gt;这类的响应指的是服务器已经接受到客户端的请求，在继续处理。&lt;strong&gt;由于HTTP协议没有定义1XX的状态码，除非在某些试验的情况下，不应该向客户端发送该类响应的状态码。&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;100 Continue，表示客户端应该继续发送剩余的请求部分。服务器必须在请求完成后返回一个最终的请求结果。&lt;/li&gt;

&lt;li&gt;101 Switch Protocol，表示客户端应该使用不同的协议继续完成这个请求。只能转移到比现在这个协议更加好的协议上去。&lt;/li&gt;

&lt;li&gt;103 Processing，WebDAV定义的状态码，表示处理将继续进行。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='2xx'&gt;2XX&lt;/h3&gt;

&lt;p&gt;这类的响应指的是请求已经被正确接收并理解，是正确的状态。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;200 OK，请求成功，并根据不同的HTTP Method返回不同的信息。&lt;/li&gt;

&lt;li&gt;201 Created，请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回&amp;#8217;202 Accepted&amp;#8217;。&lt;/li&gt;

&lt;li&gt;202 Accepted，表示请求已经被接受，但是还没有处理。这个状态码特别适合某种异步操作的场景，当服务器操作可能比较慢的场景下，可以通过发送202状态码通知客户端，不需要客户端继续保持与服务器的这个HTTP连接。&lt;/li&gt;

&lt;li&gt;203 Non-Authoritative Information，表示这个请求已经成功处理了，但是entity-header的信息在当前服务器上没有有效的确定集合，可能存在本地或者第三方的某个拷贝。&lt;/li&gt;

&lt;li&gt;204 No Content，表示返回的响应没有内容。&lt;/li&gt;

&lt;li&gt;205 Reset Content，表示返回的响应没有内容。与204不一样，205会重置文档视图，即会重置表单的输入域的值。&lt;/li&gt;

&lt;li&gt;206 Partial Content，表示只返回了部分响应的内容，这个状态码在分块下载的时候非常有用，以后会单独进行分析。&lt;/li&gt;

&lt;li&gt;207 Multi-Status，WebDAV定义的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='3xx'&gt;3XX&lt;/h3&gt;

&lt;p&gt;这类响应指的是需要客户端进行进一步的操作才能处理。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;300 Multiple Choices，被请求的资源有一系列可供选择的回馈信息，可供客户端自行选择该如何操作。&lt;/li&gt;

&lt;li&gt;301 Moved Permanently，请求的资源已经被永久移动到新位置，新位置应该在Location头里面指定。&lt;/li&gt;

&lt;li&gt;302 Found，请求的资源临时定位到另一个位置，由于是临时的，客户端下次发出这个请求时应该还是从原来的URL中获取该资源。&lt;/li&gt;

&lt;li&gt;303 See Other，这个请求在另一个位置上找到，指示客户端应该使用GET在那个位置上获取该资源。&lt;/li&gt;

&lt;li&gt;304 Not Modified，这个请求的资源没有发生过变化，指示客户端可以使用本地缓存。&lt;/li&gt;

&lt;li&gt;305 Use Proxy，这个请求必须通过代理服务器访问。&lt;/li&gt;

&lt;li&gt;306 Switch Proxy，这个状态码已废弃。&lt;/li&gt;

&lt;li&gt;307 Temporary Redirect，于302类似。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='4xx'&gt;4XX&lt;/h3&gt;

&lt;p&gt;这类响应指的是请求错误，表示客户端发生了错误导致请求失败。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;400 Bad Request，表示由于客户端的错误（例如语法错误）导致请求失败。&lt;/li&gt;

&lt;li&gt;401 Unauthorized，表示该请求需要认证才能处理。&lt;/li&gt;

&lt;li&gt;402 Payment Required，这个状态码为将来的需求预留。&lt;/li&gt;

&lt;li&gt;403 Forbidden，表示服务器已经接收到请求，但是拒绝处理。可以在响应的实体里面反馈究竟是为啥不响应这个请求。&lt;/li&gt;

&lt;li&gt;404 Not Found，表示请求的资源在服务器上没有找到。&lt;/li&gt;

&lt;li&gt;405 Method Not Allowed，表示该请求所使用的方法是不允许的。例如在一些不支持&lt;code&gt;PUT&lt;/code&gt;的Web服务器使用&lt;code&gt;PUT&lt;/code&gt;方法。&lt;/li&gt;

&lt;li&gt;406 Not Acceptable，请求的资源的内容特性无法满足请求头中的条件。&lt;/li&gt;

&lt;li&gt;407 Proxy Authentication Required，表示必须通过代理服务器的认证。&lt;/li&gt;

&lt;li&gt;408 Request Timeout，请求超时。&lt;/li&gt;

&lt;li&gt;409 Conflict，由于和被请求的资源的当前状态之间存在冲突，请求无法完成。&lt;/li&gt;

&lt;li&gt;410 Gone，与404类似，区别是410是永远找不到这个位置的资源，而404则无法确认是临时的还是永远的。&lt;/li&gt;

&lt;li&gt;411 Length Required，必须在头里面声明Content-Length。&lt;/li&gt;

&lt;li&gt;412 Precondition Failed，先决条件失败。&lt;/li&gt;

&lt;li&gt;413 Request Entity Too Large，请求的实体大小太大。可以通过Retry-After的响应头指示客户端应该何时进行重试。&lt;/li&gt;

&lt;li&gt;414 Request-URI Too Long，请求的URI太长，超出服务器的处理范围。&lt;/li&gt;

&lt;li&gt;415 Unsupported Media Type，不支持这个请求的媒体类型。&lt;/li&gt;

&lt;li&gt;416 Requested Range Not Satisfiable，如果请求中包含了Range请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义If-Range请求头。&lt;/li&gt;

&lt;li&gt;417 Expectation Failed，在请求头Expect中指定的预期内容无法被服务器满足。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='5xx'&gt;5XX&lt;/h3&gt;

&lt;p&gt;这类响应指的是服务器错误。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;500 Internal Server Error，服务器内部错误，通常是程序出错的时候后会返回这个错误码。&lt;/li&gt;

&lt;li&gt;501 Not Implemented，服务器无法处理这个HTTP方法。&lt;/li&gt;

&lt;li&gt;502 Bad Gateway，网关或者代理服务器错误。&lt;/li&gt;

&lt;li&gt;503 Service Unavailable，服务器临时不能处理这个请求，可以通过Retry-After的相应头指示客户端应该何时进行重试。&lt;/li&gt;

&lt;li&gt;504 Gateway Timeout，网关或者代理服务器超时。&lt;/li&gt;

&lt;li&gt;505 HTTP Version Not Supported，服务器不支持该HTTP版本。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;今天只是简单罗列一下HTTP状态码，对于某些重要的状态码需要以后进一步分析。&lt;/p&gt;

&lt;p&gt;今天参加了阿里D2论坛，接收到不少干货。感受到阿里的一些企业文化，确实比较吸引重视技术的人材。还是希望有一天，我司也能搞出这么一个技术论坛，可以吸引到这么多人来共同参与分享大家的知识，共同进步，祝福我司。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>HTTP协议之HTTP 头</title>
   <link href="http://username.github.com/2013/07/12/http-header"/>
   <updated>2013-07-12T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/12/http-header</id>
   <content type="html">&lt;p&gt;今天启程去阿里ADC，无奈被困机场，飞机起飞遥遥无期，故趁等飞机起飞的闲暇事件写一下HTTP协议之HTTP头的简介，来慰藉我寂寞的心（顺便鄙视周围的家伙们都在玩手机）。&lt;/p&gt;

&lt;p&gt;看了一下RFC关于HTTP头的规范，我跟我的小伙伴们都惊呆了，有这么多，&lt;a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html'&gt;参考这里&lt;/a&gt;。今天我决定先从一个比较简单的角度入手，对HTTP头及几个重要的头进行解析，抛砖引玉一下。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;HTTP header fields are components of the message header of requests and responses in the Hypertext Transfer Protocol (HTTP). They define the operating parameters of an HTTP transaction.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单地说就是一些关于HTTP协议中请求与响应的传输中的控制参数。HTTP头由多个头域组成，至一个空的头域结束。每个头域是一个冒号分隔的键值对。HTTP头有标准头跟自定义头两种。标准头是每个实现都必须支持的头，如&lt;code&gt;Expires&lt;/code&gt;、&lt;code&gt;Set-Cookie&lt;/code&gt;等。非标准头可以由实现者自己定义，如IE的&lt;code&gt;X-UA-Compatible&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;在HTTP协议本身是没有限制HTTP头的大小。尽管如此，很多Web服务器、客户端和代理软件都对HTTP头的大小进行限制。如Apache2.3中，每个头的大小最多是8160个字节，一个请求里面最多包含100个头。&lt;/p&gt;

&lt;p&gt;头域大致可以分成两种，一种是请求头，客户端向服务器发请求的时候使用什么方法、请求什么URI、协议版本等都是在请求头中指定。另一种是响应头，服务器接到客户端的请求后返回响应的是否成功、返回的MIME类型是什么都在请求头中指定。&lt;/p&gt;

&lt;h3 id='id11'&gt;请求头&lt;/h3&gt;

&lt;p&gt;常用的标准请求头包括下面几个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Accept&lt;/code&gt;，声明哪种相应是可接受的，如&lt;code&gt;text\plain&lt;/code&gt;、&lt;code&gt;application\json&lt;/code&gt;等。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Cache-Control&lt;/code&gt;，声明缓存控制机制，如&lt;code&gt;no-cache&lt;/code&gt;声明不做缓存。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Connection&lt;/code&gt;，声明与服务器的连接机制，如&lt;code&gt;keep-alive&lt;/code&gt;等。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Cookie&lt;/code&gt;，声明Cookie信息。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Content-Type&lt;/code&gt;，声明请求体的MIME类型。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Host&lt;/code&gt;，声明需要请求URI的主机信息。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;If-Match&lt;/code&gt;，声明匹配这个请求的Key，如果服务器的ETag与这个Key一致，则认为这个请求的资源没有发生改变，客户端可以选择从还从中加载这个请求。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Origin&lt;/code&gt;，声明跨域请求的时候支持什么域名进行访问。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;User-Agent&lt;/code&gt;，声明发出这个请求的客户端的描述，如果是浏览器发出的请求，可以根据这个头判断是哪个浏览器的哪个版本。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;非标准请求头包括下面几个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;X-Request-With&lt;/code&gt;，通常通过这个头告诉服务器这个请求是XMLHttpRequest发送的。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;DNT&lt;/code&gt;，表示是否开启&lt;code&gt;DNT&lt;/code&gt;（Do not track）功能，&lt;code&gt;1&lt;/code&gt;表示开启，&lt;code&gt;0&lt;/code&gt;表示关闭。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Front-End-Https&lt;/code&gt;，是微软用的一个自定义头，与负载均衡有关。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Proxy-Connection&lt;/code&gt;，与标准头&lt;code&gt;Connection&lt;/code&gt;一致，是早期HTTP协议的产物。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='id12'&gt;相应头&lt;/h3&gt;

&lt;p&gt;常用的标准相应头大概有以下几个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;，声明这个响应可以参与到哪个域的跨域访问中。&lt;code&gt;*&lt;/code&gt;表示可以参与到任何域的跨域访问。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Allow&lt;/code&gt;，声明这个HTTP响应是使用哪个HTTP方法，如&lt;code&gt;GET&lt;/code&gt;、&lt;code&gt;POST&lt;/code&gt;等。如果是一个不支持的HTTP方法，则会返回错误码&lt;code&gt;405 Method not allowed&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Content-Type&lt;/code&gt;，声明这个响应的MIME类型。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;ETag&lt;/code&gt;，声明这个响应版本的key，可以标识一个资源是否有改变过（参考请求头&lt;code&gt;If-Match&lt;/code&gt;）。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Pragma&lt;/code&gt;，声明这个响应是否支持缓存，可以设置&lt;code&gt;no-cache&lt;/code&gt;禁用这个响应的缓存。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Refresh&lt;/code&gt;，声明这个响应在特定时间后刷新或者跳转到新的URL。例如&lt;code&gt;Refresh: 5;http://example.com&lt;/code&gt;，就表示5秒之后跳转到指定的URL。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Status&lt;/code&gt;，声明这个响应的状态码，后面会专门写一篇关于状态码的文章。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;非标准的相应头包括下面几个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;X-Frame-Options&lt;/code&gt;，声明防止Clickjacking攻击的参数，如&lt;code&gt;deny&lt;/code&gt;就是防止响应被渲染在iframe里面，而&lt;code&gt;sameorigin&lt;/code&gt;就是防止响应在非本域的页面中渲染。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;X-Content-Type-Options&lt;/code&gt;，帮助IE能不识别MIME类型不对的stylesheet和script，也用于Chrome下载其扩展。只有一个合法值&lt;code&gt;nosniff&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;X-Powered-By&lt;/code&gt;，声明该响应是通过哪种语言生成的，如&lt;code&gt;X-Powered-By: PHP/5.4.0&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;X-UA-Compatible&lt;/code&gt;，帮助IE使用特定的文档模式显式该响应，也可以指导IE使用Google Chrome Frame来渲染页面。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在&lt;code&gt;meta&lt;/code&gt;里面定义的&lt;code&gt;http-equiv&lt;/code&gt;头，跟某些HTTP头是相通的。可以设置服务器返回的HTTP头，让整个站点的所有页面都在HTTP传输过程中的行为保持一直。这样可以减少纯HTML（服务器脚本，如JSP、PHP、ASP等可以通过&lt;code&gt;include&lt;/code&gt;的方式实现类似效果）的页面的代码量，减轻维护成本。&lt;/p&gt;

&lt;p&gt;今天晚上12点才到杭州，1点半才到酒店，不过精神还行，期待明天阿里ADC！&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>jQuery事件绑定研究续</title>
   <link href="http://username.github.com/2013/07/11/jquery-event-2"/>
   <updated>2013-07-11T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/11/jquery-event-2</id>
   <content type="html">&lt;p&gt;昨天留下了两个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;究竟&lt;code&gt;on&lt;/code&gt;能否解决在事件委托的情况下不能使用&lt;code&gt;event.stopPropagation&lt;/code&gt;的问题？&lt;/li&gt;

&lt;li&gt;假如在委托模式下，选择元素的其中一个子元素阻止事件冒泡，&lt;code&gt;on&lt;/code&gt;委托的事件处理程序还能否顺利执行？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;针对问题1，先做一个实验，&lt;a href='http://jsfiddle.net/Ask5n/2/'&gt;参考这里&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;HTML：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;root&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;outer&amp;quot;&amp;gt;
        Outer
        &amp;lt;div id=&amp;quot;inner&amp;quot;&amp;gt;Inner&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&amp;quot;#root&amp;quot;).on(&amp;quot;click&amp;quot;, function (evt) {
    alert(&amp;quot;click on root&amp;quot;);
});

$(&amp;quot;#root&amp;quot;).on(&amp;quot;click&amp;quot;, &amp;quot;#outer&amp;quot;, function (evt) {
    alert(&amp;quot;click on outer delegate&amp;quot;);
});

$(&amp;quot;#root&amp;quot;).on(&amp;quot;click&amp;quot;, &amp;quot;#inner&amp;quot;, function (evt) {
    alert(&amp;quot;click on inner delegate, and i stop propagation!&amp;quot;);
    evt.stopPropagation();
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单击&lt;code&gt;#inner&lt;/code&gt;，成功的阻止了&lt;code&gt;#outer&lt;/code&gt;和&lt;code&gt;#root&lt;/code&gt;上面的单击事件，说明在全部都用&lt;code&gt;on&lt;/code&gt;的情况下是可以实现阻止冒泡的功能。这个貌似跟事件委托的原理有点违背的感觉。看看jQuery的源码是怎么实现的。&lt;/p&gt;

&lt;p&gt;观察1.7的源码发现，&lt;code&gt;on&lt;/code&gt;对于选中的元素进行事件绑定的数据是用内部的&lt;code&gt;_data&lt;/code&gt;方法存在DOM里面的。所有事件都会绑定到内部的&lt;code&gt;dispatch&lt;/code&gt;方法，由这个方法分发具体的事件，进而触发具体的事件处理程序。其中有这么一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( selector ) {
    handlers.splice( handlers.delegateCount++, 0, handleObj );
} else {
    handlers.push( handleObj );
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是事件委托，会放到处理程序队列的前端（但是还是按照委托的顺序进行存放），而事件绑定则是放到队列的最后。这样导致事件委托的处理程序会优先于事件绑定的处理程序执行。现在再来看看事件触发的时候jQuery是怎么处理的。&lt;/p&gt;

&lt;p&gt;触发事件时，先拿到当前事件处理程序的&lt;code&gt;elem&lt;/code&gt;属性（即做事件委托时选中的“根”元素），然后以这个元素为事件处理程序的执行上下文（使用&lt;code&gt;apply&lt;/code&gt;把&lt;code&gt;dispatch&lt;/code&gt;方法里面的&lt;code&gt;this&lt;/code&gt;变成该元素），并传入事件对象。&lt;code&gt;dispatch&lt;/code&gt;方法先把事件对象封装一下，屏蔽浏览器差异（万恶的IE），然后从触发事件的&lt;code&gt;target&lt;/code&gt;出发，遍历其父元素一直到“根”元素。在每一次循环里面，再遍历“根”元素这个事件上的&lt;code&gt;handler&lt;/code&gt;队列（就是上文的&lt;code&gt;handlers&lt;/code&gt;）中的事件委托部分，如果该事件委托的&lt;code&gt;selector&lt;/code&gt;与当前这个元素匹配，则把该事件处理程序及其对应的元素放入最终的事件处理程序队列。事件委托遍历完成后，把剩余的事件绑定的处理程序及“根”元素一并放入最终队列中。到这个时候，就可以看出前面那个实验的结果是理所当然的。&lt;strong&gt;当为一个“根”元素中若干个子元素进行事件委托，&lt;code&gt;event.stopPropagation&lt;/code&gt;是有效的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;经过以上的分析，问题2的答案也出来了。当全部都是使用&lt;code&gt;on&lt;/code&gt;的事件委托模式去处理事件，是不会出现问题的。但是假如其中一个元素使用的是事件绑定的方式，则有可能会阻止事件委托的处理程序的执行，&lt;a href='http://jsfiddle.net/rp3Wp/'&gt;参考这里&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&amp;quot;#root&amp;quot;).on(&amp;quot;click&amp;quot;, function (evt) {
    alert(&amp;quot;click on root&amp;quot;);
});

$(&amp;quot;#outer&amp;quot;).on(&amp;quot;click&amp;quot;, function (evt) {
    alert(&amp;quot;click on outer delegate, and i stop propagation!&amp;quot;);
    evt.stopPropagation();
});

$(&amp;quot;#root&amp;quot;).on(&amp;quot;click&amp;quot;, &amp;quot;#inner&amp;quot;, function (evt) {
    alert(&amp;quot;click on inner&amp;quot;);
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单击&lt;code&gt;#inner&lt;/code&gt;，有趣的事情发生了，&lt;code&gt;#outer&lt;/code&gt;的事件处理程序执行，并阻止了事件冒泡，导致&lt;code&gt;#inner&lt;/code&gt;的事件处理程序没有被执行，坑爹啊！&lt;/p&gt;

&lt;p&gt;血淋淋的事实告诉我们，要把&lt;code&gt;on&lt;/code&gt;的事件委托进行到底到底到底到底……&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>简析jQuery几个绑定事件方法的优劣异同</title>
   <link href="http://username.github.com/2013/07/10/jquery-bind-live-on-delegate"/>
   <updated>2013-07-10T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/10/jquery-bind-live-on-delegate</id>
   <content type="html">&lt;p&gt;今天被问到jQuery中绑定事件的方式，回答了&lt;code&gt;bind&lt;/code&gt;、&lt;code&gt;live&lt;/code&gt;、&lt;code&gt;on&lt;/code&gt;三种。继续被问到哪种方式比较好。当时我毫不犹豫地说是&lt;code&gt;on&lt;/code&gt;。继续被追问说除了&lt;code&gt;on&lt;/code&gt;还知不知道有什么更好的方式绑定事件。当时哥就蒙了，还有更好的绑定事件的方式吗？决定写一下jQuery中绑定事件有哪些方式，各种方式之间的区别又是啥。&lt;/p&gt;

&lt;h3 id='bind'&gt;.bind&lt;/h3&gt;

&lt;p&gt;先看看jQuery官方是怎么描述&lt;code&gt;bind&lt;/code&gt;的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Attach a handler to an event for the elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单地说就是往元素上绑定事件处理程序。该方法接受三个参数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;eventType&lt;/code&gt;，绑定事件的名称。名称可以是任意的，接受自定义事件（只能通过&lt;code&gt;trigger&lt;/code&gt;触发）。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;eventData&lt;/code&gt;，可选，绑定事件附加的数据，这个数据会附在事件对象的&lt;code&gt;data&lt;/code&gt;属性里面。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;handler&lt;/code&gt;，事件处理程序，每次触发事件都会执行这个事件处理程序。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;必须在一个已存在的元素上才能使用&lt;code&gt;bind&lt;/code&gt;。&lt;/strong&gt;&lt;code&gt;bind&lt;/code&gt;只能把事件处理程序绑定到指定的DOM元素上面。注意的是，如果为该对象的同一个事件绑定多个事件处理程序，则其执行的顺序是按照其绑定的先后顺序决定的。&lt;/p&gt;

&lt;p&gt;假如绑定的对象只是一个DOM元素（例如通过id选择器选择），那么用&lt;code&gt;bind&lt;/code&gt;是可以的，不会带来太多额外的开销。但是当选择器选择的DOM对象个数非常多，由于要在每一个元素上都绑定同一个事件处理程序，会带来额外的开销，包括获取DOM元素、遍历所有DOM元素绑定事件处理程序等。而且由于&lt;code&gt;bind&lt;/code&gt;绑定时机的局限性，一般在频繁动态创建和删除DOM的场景下都不会使用&lt;code&gt;bind&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id='live'&gt;.live&lt;/h3&gt;

&lt;p&gt;又看看jQuery官方是怎么描述&lt;code&gt;live&lt;/code&gt;的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Attach an event handler for all elements which match the current selector, now and in the future.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以为所有匹配该选择器的元素（无论存在与否）绑定事件处理程序。该方法接受的参数跟&lt;code&gt;bind&lt;/code&gt;是一致的。&lt;/p&gt;

&lt;p&gt;这个方法把事件处理程序绑定到&lt;code&gt;document&lt;/code&gt;上，根据触发事件的DOM对象是否满足选择器而决定是否执行事件处理程序。由于事件处理程序是绑定在&lt;code&gt;document&lt;/code&gt;上的，所有无论在绑定事件的时候选择器对应的元素是否存在，都能在事件触发之后正确执行相关的事件处理程序。&lt;/p&gt;

&lt;p&gt;根据官方的说法，&lt;code&gt;live&lt;/code&gt;有以下几个缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;jQuery按照选择器先获取所有匹配的DOM对象，这个开销是不必要的。 2. 不支持链式的写法。&lt;/li&gt;

&lt;li&gt;因为所有的事件处理程序都是绑定在&lt;code&gt;document&lt;/code&gt;元素，如果目标元素所在的DOM树节点比较深，会有一个比较长的冒泡路径。&lt;/li&gt;

&lt;li&gt;在iPad、iTouch和iPhone上，&lt;code&gt;click&lt;/code&gt;事件不会冒泡到&lt;code&gt;document&lt;/code&gt;上（囧）。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;event.stopPropagation&lt;/code&gt;不能阻止事件冒泡，因为事件已经冒泡到&lt;code&gt;document&lt;/code&gt;上面了（囧）。&lt;/li&gt;

&lt;li&gt;与别的事件绑定方法共用会有意想不到的结果。例如&lt;code&gt;$(document).off(&amp;quot;click&amp;quot;)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;鉴于以上种种缺点，&lt;strong&gt;这个方法在1.7已经被声明是废弃的了。&lt;/strong&gt;1.7之后的版本应该是用&lt;code&gt;on&lt;/code&gt;来替代，1.7之前的版本应该用&lt;code&gt;delegate&lt;/code&gt;来替代。&lt;/p&gt;

&lt;h3 id='delegate'&gt;.delegate&lt;/h3&gt;

&lt;p&gt;再看看jQuery官方是怎么描述&lt;code&gt;delegate&lt;/code&gt;的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Attach a handler to one or more events for all elements that match the selector, now or in the future, based on a specific set of root elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;跟&lt;code&gt;live&lt;/code&gt;不一样，&lt;code&gt;delegate&lt;/code&gt;可以把事件处理程序委托到一个指定的“根”元素上面（而&lt;code&gt;live&lt;/code&gt;一定是&lt;code&gt;document&lt;/code&gt;）。这个方法接受四个参数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;selector&lt;/code&gt;，选择器，当触发事件的DOM元素匹配这个选择器时触发事件处理程序。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;eventType&lt;/code&gt;，同&lt;code&gt;bind&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;eventData&lt;/code&gt;，同&lt;code&gt;bind&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;handler&lt;/code&gt;，同&lt;code&gt;bind&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从参数上看，由于&lt;code&gt;delegate&lt;/code&gt;可以指定一个元素作为“根”，则没有&lt;code&gt;live&lt;/code&gt;的缺点1、缺点2和缺点3。跟&lt;code&gt;live&lt;/code&gt;类似，&lt;code&gt;event.stopPropagation&lt;/code&gt;在代理的事件处理程序中也是无效的，更有甚者，假如在“根”元素的DOM树下，其中一个元素的这个事件处理程序阻止了事件冒泡，那么代理的事件处理程序将被阻止执行。在1.7之前，&lt;code&gt;delegate&lt;/code&gt;是最效率的事件绑定方式。在1.7，&lt;code&gt;delegate&lt;/code&gt;已经被&lt;code&gt;on&lt;/code&gt;代替了。&lt;/p&gt;

&lt;h3 id='on'&gt;.on&lt;/h3&gt;

&lt;p&gt;最后看看jQuery官方是怎么描述&lt;code&gt;on&lt;/code&gt;的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Attach an event handler function for one or more events to the selected elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有点返璞归真的感觉，就是往选中的元素绑定某个事件处理程序。在1.7里，&lt;code&gt;on&lt;/code&gt;提供了所有有关于事件绑定的功能，这个方法接受四个参数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;events&lt;/code&gt;，要绑定的事件，可以多个，用空格隔开。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;selector&lt;/code&gt;，可选，过滤选择器，只有匹配这个选择器的元素才执行事件处理程序。如果没有提供则认为是绑定在选中的元素上。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;data&lt;/code&gt;，可选，同&lt;code&gt;bind&lt;/code&gt;的&lt;code&gt;eventData&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;handler&lt;/code&gt;，同&lt;code&gt;bind&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;on&lt;/code&gt;比较有趣的是&lt;code&gt;selector&lt;/code&gt;这个参数。如果没有，则跟&lt;code&gt;bind&lt;/code&gt;一样是绑定在某个特定的元素上。如果有，则跟&lt;code&gt;delegate&lt;/code&gt;类似，是一个事件代理，把&lt;code&gt;selector&lt;/code&gt;匹配的元素的事件处理程序代理到选中的元素上。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;小细节：&lt;code&gt;load&lt;/code&gt;、&lt;code&gt;scroll&lt;/code&gt;、&lt;code&gt;error&lt;/code&gt;不支持事件委托哦亲！&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;从jQuery的官方文档看出来，jQuery强烈建议后来写的代码都用&lt;code&gt;on&lt;/code&gt;作为事件绑定的方式。所有关于事件绑定的内容，如事件名称及其命名空间、直接绑定和事件委托、事件处理程序及其运行上下文（&lt;code&gt;this&lt;/code&gt;）、附加数据还有事件性能等说明，都写在&lt;code&gt;on&lt;/code&gt;的那一页。从代码上看，之前的&lt;code&gt;bind&lt;/code&gt;、&lt;code&gt;live&lt;/code&gt;、&lt;code&gt;delegate&lt;/code&gt;在1.7里面的实现都变成是&lt;code&gt;on&lt;/code&gt;了。从接口上看&lt;code&gt;on&lt;/code&gt;也统一了绑定事件处理程序的各种接口。就让&lt;code&gt;on&lt;/code&gt;来得更猛烈一些吧！&lt;/p&gt;

&lt;p&gt;由于时间关系，对于&lt;code&gt;on&lt;/code&gt;的研究还要继续，需要解决的问题有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;究竟&lt;code&gt;on&lt;/code&gt;能否解决在事件委托的情况下不能使用&lt;code&gt;event.stopPropagation&lt;/code&gt;的问题？&lt;/li&gt;

&lt;li&gt;假如在委托模式下，选择元素的其中一个子元素阻止事件冒泡，&lt;code&gt;on&lt;/code&gt;委托的事件处理程序还能否顺利执行？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;明天继续探讨。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>经典三列布局之如何让中间的列先显示出来</title>
   <link href="http://username.github.com/2013/07/08/three-column-layout-middle-first"/>
   <updated>2013-07-08T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/08/three-column-layout-middle-first</id>
   <content type="html">&lt;p&gt;在某些并发访问非常高的页面，由于服务器压力过大，导致页面的内容要很久才能加载完。这个时候，我们应该尽可能把用户觉得重要的信息（大多数情况放在中栏）先显示出来。&lt;/p&gt;

&lt;p&gt;首先是原始的HTML：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;left&amp;quot;&amp;gt;This is left!&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;middle&amp;quot;&amp;gt;This is middle!&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;right&amp;quot;&amp;gt;This is right!&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照HTML解析顺序，上面的HTML片段应该是先显示left，再显示middle，最后显示right。&lt;/p&gt;

&lt;h3 id='id7'&gt;第一步&lt;/h3&gt;

&lt;p&gt;先调整HTML的顺序，让middle先行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;middle&amp;quot;&amp;gt;This is middle!&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;left&amp;quot;&amp;gt;This is left!&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;right&amp;quot;&amp;gt;This is right!&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='id8'&gt;第二步&lt;/h3&gt;

&lt;p&gt;为&lt;code&gt;div&lt;/code&gt;加上底色，比较好看（(╯‵□′)╯︵┻━┻）。然后设置每个栏的宽度，中间的自适应。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#left { width: 100px; background: red;}
#right { width: 100px; background: blue;}
#middle { width: 100%; background: green;}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果&lt;a href='http://jsfiddle.net/zBXbp/5/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id='id9'&gt;第三步&lt;/h3&gt;

&lt;p&gt;让左栏弄到middle左边去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container { 
    position: relative;
    padding: 0 100px;
    overflow: hidden;
    margin: 0 auto;
}

#middle {
    float: left;
}

#left {
    position: relative;
    left: -100px;
    float: left;
    margin-left: -100%;   
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果&lt;a href='http://jsfiddle.net/zBXbp/6/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id='id10'&gt;第四步&lt;/h3&gt;

&lt;p&gt;让右栏弄到middle右边去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#right {
    float: left;
    margin-right: -100%;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果&lt;a href='http://jsfiddle.net/zBXbp/7/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;由于时间的问题，这个问题的解决方案到这里就先暂告一段落（还有IE hack、header、footer、三栏高度统一等问题）。这里简单地描述了解决这个问题的思路，这个方案使用了HTML的负边距，在以后的博文里面会重点对负边距进行解析。&lt;/p&gt;

&lt;p&gt;题外话：今天在我司跟了1年半的老大要惯例了，有点唏嘘，祝一路走好，前程似锦！&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>window.location 浅析</title>
   <link href="http://username.github.com/2013/07/07/window-location"/>
   <updated>2013-07-07T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/07/window-location</id>
   <content type="html">&lt;p&gt;国际惯例，先看看&lt;code&gt;window.location&lt;/code&gt;在w3schools的简单描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The window.location object can be used to get the current page address (URL) and to redirect the browser to a new page.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单地说，这个对象就是用来获取页面的URL，控制页面跳转等功能。&lt;/p&gt;

&lt;h3 id='id5'&gt;属性&lt;/h3&gt;

&lt;p&gt;可以通过以下属性获取关于当前页面路径的信息，也可以设置某些属性跳转到新的url上面。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;hash&lt;/code&gt;，url中跟着&lt;code&gt;#&lt;/code&gt;的内容，包含&lt;code&gt;#&lt;/code&gt;。注意，&lt;strong&gt;如果&lt;code&gt;#&lt;/code&gt;后面没用东西或者没有&lt;code&gt;#&lt;/code&gt;，则这个属性的值是空字符串&lt;/strong&gt;。还可以绑定&lt;code&gt;hashchange&lt;/code&gt;事件监听&lt;code&gt;hash&lt;/code&gt;变化。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;host&lt;/code&gt;，由url的主机名称&lt;code&gt;hostname&lt;/code&gt;跟端口&lt;code&gt;port&lt;/code&gt;组成的字符串。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;hostname&lt;/code&gt;，url的主机名称。注意，&lt;strong&gt;在Chrome跟Safari是包括括号的（IPv6的情况），而IE跟FireFox则不包括括号&lt;/strong&gt;。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;href&lt;/code&gt;，完整的url。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;pathname&lt;/code&gt;，相对于主机名的路径。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;port&lt;/code&gt;，url的端口号。如果使用的是默认端口（80），则这个属性的值是空字符串。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;protocol&lt;/code&gt;，url的协议。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;search&lt;/code&gt;，url中跟着&lt;code&gt;?&lt;/code&gt;的内容，包含&lt;code&gt;?&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;orign&lt;/code&gt;，由url的协议、主机名跟端口组成的字符串。目前只有Chrome跟FireFox 21支持这个属性。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='id6'&gt;方法&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;assign(url)&lt;/code&gt;，将当前页面跳转到指定的url。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;reload(forceget)&lt;/code&gt;，重新加载当前页面。如果&lt;code&gt;forceget&lt;/code&gt;跟true，则会强制从服务器刷新，否则浏览器可能会读取缓存。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;replace(url)&lt;/code&gt;，与&lt;code&gt;assign&lt;/code&gt;方法类似，唯一不同的是&lt;code&gt;replace&lt;/code&gt;不会留下历史记录，意味着跳转后不能使用浏览器的后退功能返回前一个页面。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;toString&lt;/code&gt;，返回完整的url（&lt;code&gt;href&lt;/code&gt;）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href='https://developer.mozilla.org/en-US/docs/Web/API/window.location#Properties'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;说到&lt;code&gt;window.location&lt;/code&gt;的作用，不得不提到Ajax。在Ajax泛滥的今天，影响最大之一的就是收藏夹。传统HTML页面，一个URL会对应一个页面，页面的内容是固定的。Ajax应用中，一个页面，可能会根据用户的行为而产生不同的内容（无论是形式上还是传统的内容上）。如何去收藏经过用户操作之后的Ajax应用页面呢？其中一个比较好的办法就是使用&lt;code&gt;window.location.hash&lt;/code&gt;这个属性，记录用户的简单操作。当用户操作时，记录一个简单的hash。当页面初始化时，根据hash判断Ajax应用的状态，可以基本实现收藏夹的功能，下面举个例子（完整代码&lt;a href='http://jsfiddle.net/GeYw8/1/show/'&gt;参考这里&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a id=&amp;quot;a1&amp;quot; href=&amp;quot;#&amp;quot;&amp;gt;Click A1&amp;lt;/a&amp;gt;
&amp;lt;a id=&amp;quot;a2&amp;quot; href=&amp;quot;#&amp;quot;&amp;gt;Click A2&amp;lt;/a&amp;gt;
&amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;



var hash = window.location.hash || &amp;quot;#status1&amp;quot;;
var text = &amp;quot;&amp;quot;;
    
switch (hash) {
    case &amp;quot;#status1&amp;quot;:
        text = &amp;quot;This is Status1&amp;quot;;
        break;
    case &amp;quot;#status2&amp;quot;:
        text = &amp;quot;This is Status2&amp;quot;;
        break;
}

$(&amp;quot;#content&amp;quot;).html(text);

$(&amp;quot;#a1&amp;quot;).click(function (evt) {
    window.location.hash = &amp;quot;#status1&amp;quot;;
    $(&amp;quot;#content&amp;quot;).html(&amp;quot;This is Status1&amp;quot;);
    evt.preventDefault();
});

$(&amp;quot;#a2&amp;quot;).click(function (evt) {
    window.location.hash = &amp;quot;#status2&amp;quot;;
    $(&amp;quot;#content&amp;quot;).html(&amp;quot;This is Status2&amp;quot;);
    evt.preventDefault();
});&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>前端攻城师的职业规划</title>
   <link href="http://username.github.com/2013/07/06/frontend-career"/>
   <updated>2013-07-06T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/06/frontend-career</id>
   <content type="html">&lt;p&gt;直接上图。&lt;/p&gt;
&lt;img src='http://popotang.com/blog/wp-content/uploads/2011/12/655534efgw1do2a8dvcldj.jpg' alt='frontend' width='100%' /&gt;</content>
 </entry>
 
 <entry>
   <title>Href中的JavaScript link</title>
   <link href="http://username.github.com/2013/07/05/href-javascript-expression"/>
   <updated>2013-07-05T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/05/href-javascript-expression</id>
   <content type="html">&lt;p&gt;在&lt;code&gt;A&lt;/code&gt;标签的&lt;code&gt;href&lt;/code&gt;属性写上JavaScript“表达式”，其中一个目的就是为了那些不是链接的&lt;code&gt;A&lt;/code&gt;标签通过HTML验证，&lt;a href='http://stackoverflow.com/questions/7755088/href-expression-a-href-javascript-a'&gt;参考这里&lt;/a&gt;。&lt;em&gt;（注：刚才试了一下在最新的W3C的HTML在线校验里面没有&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;href&lt;/code&gt;属性的&lt;code&gt;A&lt;/code&gt;标签也能通过校验）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;不能写“#”，因为会跳到页面的头部&lt;em&gt;（可以通过取消浏览器默认事件防止该行为，&lt;a href='http://dafeizizhu.github.io/2013/07/03/a-tag/'&gt;参考这里&lt;/a&gt;）&lt;/em&gt;。也不能写空字符串，在IE下会刷新页面。那只能写一个JavaScript表达式，该表达式什么也不做。最常见的就是以下这个代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;javascript:void(0)&amp;quot;&amp;gt;Do not refresh or go to the top of this page.&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScrit提供了一种机制，供页面与JavaScript方法进行交互，其中一种机制就是&lt;code&gt;href&lt;/code&gt;中的JavaScript链接（JavaScript link）。一个最简单的JavaScript链接示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;javascript:MyFunction();&amp;quot;&amp;gt;Text to Click&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;MyFunction&lt;/code&gt;是全局的一个函数，当单击这个&lt;code&gt;A&lt;/code&gt;标签的时候，对应JavaScript链接的语句会被执行。&lt;/p&gt;

&lt;p&gt;如果同时设置了&lt;code&gt;href&lt;/code&gt;上的JavaScript链接，又设置了&lt;code&gt;onclick&lt;/code&gt;属性&lt;em&gt;（当然这个应该存在于黑暗之中永远不让它出来o(╯□╰)o）&lt;/em&gt;，会是怎样的一个场景呢？立马做一个实验，&lt;a href='http://jsfiddle.net/b7YLJ/1/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;javascript:alert(1);&amp;quot; onclick=&amp;quot;alert(2);&amp;quot;&amp;gt;Text to Click&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果是先弹出了2，再弹出1。仔细思考一下，其实这个结果是跟前天写的内容是吻合的。事件处理函数先执行，再执行浏览器的默认行为，在这里浏览器的默认行为就是弹出1。&lt;/p&gt;

&lt;p&gt;最后简单看看JavaScript中一个被忽略的运算符：&lt;code&gt;void&lt;/code&gt;。这个运算符有两种使用方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void (expression)

void expression&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个运算符的作用是执行JavaScript语句，但是不返回任何东西。可以作为&lt;code&gt;href&lt;/code&gt;的值，当单击&lt;code&gt;A&lt;/code&gt;标签的时候会执行该JavaScript语句。详细情况可以&lt;a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#void'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>HTML META 标签入门</title>
   <link href="http://username.github.com/2013/07/04/html-meta-tag"/>
   <updated>2013-07-04T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/04/html-meta-tag</id>
   <content type="html">&lt;p&gt;今天被妹纸狠狠地鄙视了我的博客样子太丑(/＞皿&amp;lt;)/ ～ ┴┴。闲逛看看有没有好看的博客设计。偷看他们源代码，发现有好多&lt;code&gt;meta&lt;/code&gt;标签都不认识，所以写一篇东西好好学习一下&lt;code&gt;html&lt;/code&gt;中的&lt;code&gt;meta&lt;/code&gt;标签究竟怎么用。&lt;/p&gt;

&lt;h3 id='id2'&gt;定义&lt;/h3&gt;

&lt;p&gt;又看看w3schools对&lt;code&gt;meta&lt;/code&gt;标签的定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The meta tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;再看看wikipedia的解释：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Meta elements can specify HTTP headers which should be sent &lt;strong&gt;before&lt;/strong&gt; the actual content when the HTML page is served from Web server to client.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;meta&lt;/code&gt;标签不会显示在页面中。使用&lt;code&gt;meta&lt;/code&gt;可以声明这个页面的描述、作者、关键字、最后修改日期等信息，可以供浏览器、搜索引擎和一些Web服务使用。&lt;/p&gt;

&lt;h3 id='id3'&gt;注意&lt;/h3&gt;

&lt;p&gt;以下是几点注意事项：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;meta&lt;/code&gt;标签总是定义在&lt;code&gt;head&lt;/code&gt;标签之类。&lt;/li&gt;

&lt;li&gt;&lt;code&gt;meta&lt;/code&gt;标签总是以键值对（&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;content&lt;/code&gt;）传递信息。&lt;/li&gt;

&lt;li&gt;在定义&lt;code&gt;name&lt;/code&gt;或者&lt;code&gt;http-equiv&lt;/code&gt;属性之后才能定义&lt;code&gt;content&lt;/code&gt;属性。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='name'&gt;NAME&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;meta&lt;/code&gt;标签的&lt;code&gt;name&lt;/code&gt;属性就说说明当前的&lt;code&gt;meta&lt;/code&gt;标签是什么类型，以便于搜索引擎抓取，索引网页。相应的&lt;code&gt;content&lt;/code&gt;就是告诉搜索引擎相关的信息。对应的取值大概有（继续补充）：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;keyword&lt;/code&gt;，关键字，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;keyword&amp;quot; content=&amp;quot;key1,key2,key3&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多个关键字用&lt;code&gt;,&lt;/code&gt;隔开，还可以设置&lt;code&gt;lang&lt;/code&gt;属性指定语言。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;description&lt;/code&gt;，描述，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;something about this page.&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;robots&lt;/code&gt;，给搜索引擎，声明该页面的访问规则，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;robots&amp;quot; content=&amp;quot;all&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可选的取值有&lt;code&gt;all&lt;/code&gt;、&lt;code&gt;index&lt;/code&gt;、&lt;code&gt;follow&lt;/code&gt;、&lt;code&gt;noindex&lt;/code&gt;、&lt;code&gt;nofollow&lt;/code&gt;、&lt;code&gt;none&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;author&lt;/code&gt;，作者，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;author&amp;quot; content=&amp;quot;Zhiying Mai&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;copyright&lt;/code&gt;，版权信息，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;copyright&amp;quot; content=&amp;quot;Power by Zhiying Mai.&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;generator&lt;/code&gt;，页面制作工具（吐槽一个，浏览器连这个都管o(╯□╰)o）。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;copyright&amp;quot; content=&amp;quot;Front-page&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;revisit-after&lt;/code&gt;，告诉搜索引擎什么时候重新抓取，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;revisit-after&amp;quot; content=&amp;quot;2 days&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='httpequiv'&gt;HTTP-EQUIV&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;meta&lt;/code&gt;的&lt;code&gt;http-equiv&lt;/code&gt;属性,其作用类似于HTTP头协议,它会告诉浏览器一些关于字符设定，页面刷新，cookie，和缓存等等相关信息。对应的取值大概有（继续补充）：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;content-type&lt;/code&gt;，页面属性类型，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;content-type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在HTML5中已经使用独立的&lt;code&gt;meta&lt;/code&gt;标签来声明字符集。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;refresh&lt;/code&gt;，刷新时间，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;60&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示页面60秒后会自动刷新。还可以配置&lt;code&gt;url&lt;/code&gt;属性让页面在设置的刷新时间跳转到特定的url。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;expires&lt;/code&gt;，页面的过期时间，当页面过期后，必须重新从服务器请求该页面，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;expires&amp;quot; content=&amp;quot;Fri, 5 Jul 2013 01:13:13 GMT&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当&lt;code&gt;content&lt;/code&gt;是0时表示页面&lt;strong&gt;永不过期&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pragma&lt;/code&gt;，禁止浏览器缓存页面，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;pragma&amp;quot; content=&amp;quot;no-cach&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;set-cookie&lt;/code&gt;，设置cookie的过期时间，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;expires&amp;quot; content=&amp;quot;cookievalue=xxx; expires=Fri, 5 Jul 2013 01:13:13 GMT&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;window-target&lt;/code&gt;，强制页面在特定的框架中（特别是在&lt;code&gt;iframe&lt;/code&gt;中）显示，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;widow-target&amp;quot; content=&amp;quot;_top&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可选的取值为&lt;code&gt;_blank&lt;/code&gt;、&lt;code&gt;_top&lt;/code&gt;、&lt;code&gt;_self&lt;/code&gt;、&lt;code&gt;_parent&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;X-UA-Compatible&lt;/code&gt;，指定IE的文档兼容模式（这个太有用了），如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge,chrome=1&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示IE以最高版本的标准模式运行，如果有Google Chrome Frame则使用其渲染该页面。&lt;/p&gt;

&lt;h3 id='html5'&gt;HTML5&lt;/h3&gt;

&lt;p&gt;最后讲一个只有HTML5才有的&lt;code&gt;meta&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='id4'&gt;总结&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;meta&lt;/code&gt;标签由于SEO而被重视，但是其作用不仅仅是用作SEO，还能制造出类似HTTP协议头的效果。当需要IE浏览器处于某种特定的文档模式，也要注意使用&lt;code&gt;meta&lt;/code&gt;哦亲！&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>HTML A 标签简析</title>
   <link href="http://username.github.com/2013/07/03/a-tag"/>
   <updated>2013-07-03T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/03/a-tag</id>
   <content type="html">&lt;p&gt;HTML中的&lt;code&gt;A&lt;/code&gt;标签，使用频率应该非常高。可以作为一个链接、一个锚点，甚至一些按钮（Extjs和dojo等框架）。先看看w3schools对&lt;code&gt;A&lt;/code&gt;标签的定义是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The a tag defines a hyperlink, which is used to link from one page to another.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单的说，&lt;code&gt;A&lt;/code&gt;标签就是一个超链接。有趣的是，对于HTML4跟HTML5对&lt;code&gt;A&lt;/code&gt;标签的定义又有所不同。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In HTML 4.01, the a tag could be either a hyperlink or an anchor. In HTML5, the a tag is always a hyperlink, but if it has no href attribute, it is only a placeholder for a hyperlink.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在HTML4中，如果&lt;code&gt;A&lt;/code&gt;标签没有&lt;code&gt;href&lt;/code&gt;这个属性，则说明该&lt;code&gt;A&lt;/code&gt;标签仅仅是个锚，可以供链接跳转到该位置，就像一个“书签”的作用。但是在HTML5中&lt;code&gt;A&lt;/code&gt;标签&lt;strong&gt;只是个链接&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;最近在项目中发现有个奇怪的问题：在一个&lt;code&gt;A&lt;/code&gt;标签的事件处理程序中，改变浏览器的hash，发现不生效，只是在浏览器的地址栏的末尾加上了“#&amp;#8221;。打断点调试后发现该行代码执行之后，浏览器的地址栏确实是改变了，可以看到代码设置的hash。但是在代码走完之后，浏览器的hash自动变成“#”，代码设置上去的hash被重置了。观察该事件在jQuery中的处理函数，只有一个事件处理函数，没有其他的事件处理函数被执行，也没有异步方法执行。究竟这个hash是怎么被重置回去了？&lt;/p&gt;

&lt;p&gt;观察该&lt;code&gt;A&lt;/code&gt;标签的属性，发现有一行这样的代码：&lt;code&gt;href=&amp;quot;#&amp;quot;&lt;/code&gt;。使用Chrome的调试工具，把其改成&lt;code&gt;href=&amp;quot;#123&amp;quot;&lt;/code&gt;，神奇的事情发生了。单击按钮后地址栏上的hash被改成了“#123”。难道是&lt;code&gt;A&lt;/code&gt;标签的默认行为重置了浏览器的hash？&lt;/p&gt;

&lt;p&gt;为了验证该问题，为一个&lt;code&gt;DIV&lt;/code&gt;元素绑定了同样一个鼠标单击的事件处理函数，发现单击该&lt;code&gt;DIV&lt;/code&gt;元素，地址栏上的hash被正确修改，没有被重置。&lt;/p&gt;

&lt;p&gt;重现该场景写了一个&lt;a href='http://jsfiddle.net/Vy3W7/'&gt;测试代码&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;运行代码后发现地址栏上的hash变成了“#123”，而不是代码设置的“#456”。说明&lt;code&gt;A&lt;/code&gt;标签的默认行为是发生在事件处理函数之后的。&lt;/p&gt;

&lt;p&gt;要防止以上的场景发生，可以采取以下几个手段：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;把&lt;code&gt;href&lt;/code&gt;的值改成是&lt;code&gt;javascript:void(0);&lt;/code&gt;。JavaScript中void是一个操作符，该操作符指定要计算一个表达式但是不返回值，单击这个标签的默认行为就是什么都不做。&lt;/li&gt;

&lt;li&gt;在事件处理函数中使用&lt;code&gt;evt.preventDefault()&lt;/code&gt;阻止浏览器的默认行为，或者&lt;code&gt;return false&lt;/code&gt;也行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;尽量不要写&lt;code&gt;href=&amp;quot;#&amp;quot;&lt;/code&gt;了，如果没有阻止浏览器的默认行为，这句代码不仅会重置地址栏的hash，还会让页面滚动到最上方，慎用慎用。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Position: fixed 浏览器兼容性分析</title>
   <link href="http://username.github.com/2013/07/02/position-fixed"/>
   <updated>2013-07-02T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/07/02/position-fixed</id>
   <content type="html">&lt;p&gt;写这个是因为现在很多门户网站都采用了顶栏固定的布局，提供导航还有一些工作（例如搜索）。对于现代浏览器来说，可以简单的使用以下这个css样式达到效果：&lt;/p&gt;

&lt;p&gt;这个样式在Chrome、FireFox、Safari、Opera、IE7、IE8、IE9都是生效的。&lt;strong&gt;其中需要注意的是，在IE7和IE8下面需要声明文档模式是标准模式才能生效&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在IE6下需要CSS hack才能达到&lt;code&gt;position: fixed;&lt;/code&gt;的效果：&lt;/p&gt;

&lt;p&gt;其中带&lt;code&gt;*&lt;/code&gt;的样式只会被IE6跟IE7识别。在IE6中，需要把滚动条机制从&lt;code&gt;html&lt;/code&gt;元素移动到&lt;code&gt;body&lt;/code&gt;元素上，才能模拟出该效果，&lt;a href='http://tagsoup.com/cookbook/css/fixed/'&gt;参考这里&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Moving the scroll mechanism from the root element to the document body will cause absolutely positioned descendants of the body element to be fixed in respect to the viewport.&lt;/p&gt;
&lt;/blockquote&gt;</content>
 </entry>
 
 <entry>
   <title>弹出的模态对话框被拦截的条件</title>
   <link href="http://username.github.com/2013/01/23/post"/>
   <updated>2013-01-23T00:00:00+08:00</updated>
   <id>http://username.github.com/2013/01/23/post</id>
   <content type="html">&lt;p&gt;只要从用户行为到弹出模态对话框&lt;code&gt;showModalDialog&lt;/code&gt;之间，有任意一个异步调用（例如&lt;code&gt;setTimeout&lt;/code&gt;或者ajax调用），则会被浏览器认为是恶意的窗口，导致窗口被拦截。&lt;/p&gt;

&lt;p&gt;解决方案：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;删除任何&lt;code&gt;setTimeout&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;删除任何ajax调用，如果要跟服务交互，必须使用同步调用&lt;/li&gt;

&lt;li&gt;不使用&lt;code&gt;showModalDialog&lt;/code&gt;弹出对话框，使用更现代的方法（例如div模拟的模态对话框效果）&lt;/li&gt;
&lt;/ol&gt;</content>
 </entry>
 
 <entry>
   <title>2012 12 22 笔记</title>
   <link href="http://username.github.com/2012/12/22/note-2012-12-22"/>
   <updated>2012-12-22T00:00:00+08:00</updated>
   <id>http://username.github.com/2012/12/22/note-2012-12-22</id>
   <content type="html">&lt;h3 id='verticalalign_lineheight'&gt;vertical-align 与line-height的垂直居中答案&lt;/h3&gt;

&lt;p&gt;其实很简单……只要在label里面也加上vertical-align就ok了……&lt;/p&gt;

&lt;p&gt;记个遗留问题，要搞清楚块元素中行内元素的垂直居中机制。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>2012 12 20 Note</title>
   <link href="http://username.github.com/2012/12/20/2012-12-20-note"/>
   <updated>2012-12-20T00:00:00+08:00</updated>
   <id>http://username.github.com/2012/12/20/2012-12-20-note</id>
   <content type="html">&lt;h3 id='verticalalign_lineheight'&gt;vertical-align 与line-height的垂直居中&lt;/h3&gt;

&lt;p&gt;vertical-align用于块元素内的行内元素的垂直居中，而line-height则用于在行内元素中文字居中，当行高被块元素内部的某个元素（display: inline-block）撑大之后，使用前两个垂直居中的方法都不凑效。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;vertical-aligin作用在块元素中，不能使其他行内元素垂直居中，因为受到了那个撑大元素的影响&lt;/li&gt;

&lt;li&gt;line-height则要显式的设置固定像素值，不能满足自适应那个撑大元素的高度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;到最后还是要使用表格布局……&lt;/p&gt;

&lt;p&gt;遗留一个题目，等自己以后想起来了可以做一下，让那个span居中显示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
	p {
		vertical-align: center;
	｝
	label {
		width: 50px;
		display: inline-block;
	｝
&amp;lt;/style&amp;gt;
&amp;lt;p&amp;gt;
	&amp;lt;label&amp;gt;This is a long long long label&amp;lt;/label&amp;gt;
	&amp;lt;span&amp;gt;I need to be vertical center!&amp;lt;/span&amp;gt;
&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='css_background'&gt;css background&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;背景色background-color，不能被继承，默认值是transparent&lt;/li&gt;

&lt;li&gt;背景图片background-image，不能被继承，默认值是none&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据血的教训，同时设置这两个属性时要小心互相覆盖，最好还是使用shortcut的background属性确保设置的背景是所需要的背景&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>2012-12-18 笔记</title>
   <link href="http://username.github.com/2012/12/18/note-2012-12-18"/>
   <updated>2012-12-18T00:00:00+08:00</updated>
   <id>http://username.github.com/2012/12/18/note-2012-12-18</id>
   <content type="html">&lt;h3 id='id1'&gt;兼容的强制换行样式&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;content&amp;quot;&amp;gt;
    &amp;lt;p class=&amp;quot;wrap&amp;quot;&amp;gt;No matter how long, i wrap...&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;

.content {
    /* Important! */
    width: 200px;
}
.wrap {
    word-break: break-all;
    word-wrap: break-word;
}&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>Note 2012 12 17</title>
   <link href="http://username.github.com/2012/12/17/note-2012-12-17"/>
   <updated>2012-12-17T00:00:00+08:00</updated>
   <id>http://username.github.com/2012/12/17/note-2012-12-17</id>
   <content type="html">&lt;h3 id='ff_jqueryajax_datatype'&gt;FF jQuery.ajax 默认的dataType属性不生效&lt;/h3&gt;

&lt;p&gt;在FF10以上的环境，使用jQuery的ajax方法，如果没有配置dataType属性，返回的结果类型不可遇见（经调试发现是Document），例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajax({
	&amp;quot;url&amp;quot;: &amp;quot;xxx&amp;quot;,
	&amp;quot;success&amp;quot;: function (result) {
		console.log(result);	// In FF, it may be Document if has no dataType...
	}
	// This is nessery
	&amp;quot;dataType&amp;quot;: &amp;quot;text&amp;quot;
});&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='ie8jqueryattrboolean'&gt;在IE8下使用jQuery的attr方法，最好能使用明确的boolean值&lt;/h3&gt;

&lt;p&gt;在IE8下使用attr，如果使用例如空字符串或者undefined之类的去设置对应attr的值，可能会有意想不到的结果，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function test(booleanValue) {
	// This is nessery
	booleanValue = !!booleanValue;		

	$(&amp;quot;#id&amp;quot;).attr(&amp;quot;someAttr&amp;quot;, booleanValue);
}&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>My First Post</title>
   <link href="http://username.github.com/2012/12/16/my-first-post"/>
   <updated>2012-12-16T00:00:00+08:00</updated>
   <id>http://username.github.com/2012/12/16/my-first-post</id>
   <content type="html">&lt;h3 id='this_is_the_first_post'&gt;This is the first Post!!!!!&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function () {
    console.log(&amp;quot;Hello World!&amp;quot;);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个IT闷骚男的闷骚技术剥壳，记录编码中的一点一滴&lt;/p&gt;</content>
 </entry>
 
 
</feed>