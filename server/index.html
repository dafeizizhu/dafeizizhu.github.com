
<!DOCTYPE html>
<html>
  
  <head>
    <title>大肥子猪</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
    <meta content="text/html; charset=UTF-8" http-equiv=Content-Type />
    <meta name=author content="Zhiying.Mai" />
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" type="text/css" href="/assets/themes/dafeizizhu/bootstrap/css/bootstrap.min.css" />
	<link rel=stylesheet type=text/css href="/assets/themes/dafeizizhu/css/style.css" media=screen />
	<link rel=stylesheet type=text/css href="/assets/themes/dafeizizhu/css/style-responsive.css" media="screen and (max-width: 900px)"/>

	<!--[if lte IE 7]>
	<link rel="stylesheet" type="text/css" href="/assets/themes/dafeizizhu/css/style-iefixed.css" />
    <![endif]-->
  </head>
  
  <body>
    <DIV id=home class=pages>
      <DIV id=main_container>
        <DIV id="left">
          <DIV class=left_content>
            <H1>
              <A title="dafeizizhu" href="/">
                dafeizizhu
              </A>
            </H1>
            <DIV class=clear>
            </DIV>
            <DIV class=navigation>
              <UL id=slide>
                 
                


  <li class="page_item page-item-52  current_page_item "><a href="/index.html">首页</a></li>
  
    
      
    
  
    
      
      	
      	<li class="page_item page-item-52"><a href="/archive.html">博文</a></li>
      	
      
    
  
    
      
      	
      	<li class="page_item page-item-52"><a href="/tags.html">标签</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  




              </UL>
            </DIV>
			<DIV>
			  <ul class="socials">
                <li class="social-weixin"><a href="http://weixin.qq.com" title="扫一扫每天获取更新内容哦亲！"></a></li>
			  </ul>
            </DIV>
          </DIV>
        </DIV>
        <DIV id="center">
          <DIV class=right_content>
            <!--<DIV id=post-52 class=postsingle>-->
            <DIV class=entry>
              
<div class="row-fluid">
  <div class="span12">
    <div class='row-fluid'>
  <div class='span12'>
    <ul>
       
         <li style='margin-bottom: 50px;'>
            <a href='/2013/08/21/document-write'><h2>document write</h2></a>&nbsp;<span>21 Aug 2013</span>
            
         </li>
       
         <li style='margin-bottom: 50px;'>
            <a href='/2013/08/20/jquery-callbacks-source-code'><h2>jQuery源码解析之jQuery.Callbacks</h2></a>&nbsp;<span>20 Aug 2013</span>
            <p>昨天介绍了<code>jQuery.Callbacks</code>方法，今天简单看一下它的源码。github上的代码链接<a href='https://github.com/jquery/jquery/blob/master/src/callbacks.js'>在这里</a>。</p>

<p>jQuery的主干已经是2.0版本了。几乎每个文件的开始都是按照以下的形式给出：</p>

<pre><code>define([
  &quot;./core&quot;,
  &quot;./var/rnotwhite&quot;
], function( jQuery, rnotwhite ) {</code></pre>

<p>通过一个全局的<code>define</code>函数，实现类似于node的依赖管理。现在还没有看<code>define</code>的源码，可以猜测第一个参数就是这个js文件（模块）的依赖，而这个模块的逻辑都被封装在第二个匿名函数的闭包里面。</p>

<p>首先是一个工具方法，解析<code>jQuery.Callbacks</code>方法传入的参数，即各种flag。这里有一个性能优化点，<code>Callbacks</code>方法会以每次调用的字符串参数作为key，解析的结果作为value缓存起来，下次使用同样的字符串调用<code>jQuery.Callbacks</code>就可以省去解析参数的过程了。</p>

<p>这个方法的核心就是返回的对象，这个对象的核心就是<code>fire</code>、<code>add</code>和<code>remove</code>等方法。</p>

<p>首先来看一个工具函数<code>fire</code>，<code>Callbacks</code>对象上的<code>fire</code>跟<code>fireWidth</code>这两个方法都是基于这个工具函数的。这个工具函数会递归调用自己，并每次更改<code>fire</code>的索引来遍历整个回调列表。这里关注一下递归的结束条件：</p>

<pre><code>if ( stack ) {
  if ( stack.length ) {
    fire( stack.shift() );
  }
} else if ( memory ) {
  list = [];
} else {
  self.disable();
}</code></pre>

<p><code>stack</code>这个变量很有意思。当<code>once</code>标志生效时，这个<code>stack</code>永远都为<code>false</code>。如果<code>once</code>标志不生效，这个<code>stack</code>就是作为在<code>fire</code>的过程中，再调用<code>fire</code>时的一个类似于消息队列的东西。第一个逻辑是判断是否有消息队列，如果有则从消息队列中取出一个消息递归调用<code>fire</code>本身。如果没有消息队列，说明<code>stack</code>为<code>false</code>，这时也有两种情况。</p>

<ol>
<li><code>memory</code>标志生效，则把<code>list</code>重置为空数组，接受下一次的<code>add</code>操作。</li>

<li><code>memory</code>标志不生效，则说明个只有<code>once</code>标志生效，禁用这个<code>Callbacks</code>对象。</li>
</ol>

<p>第二个要关注的方法就是<code>add</code>，负责添加回调到<code>Callbacks</code>对象上面。这个方法支持传入参数的方式有很多种：可以是简单的一个方法，也可以是一个方法的数组，也可以是前两者的混搭，例如：</p>

<pre><code>var cbs = $.Callbacks();
cbs.add(fn);
cbs.add([fn1, fn2, fn3]);
cbs.add(fn, fn1, [fn2, fn3, fn4]);</code></pre>

<p>要实现这种机制，需要一个递归去遍历<code>arguments</code>。判断<code>arguments</code>中的每个参数的类型：</p>

<ol>
<li>如果是方法，直接加到回调列表<code>list</code>中。</li>

<li>如果是一个类似数组的东西，递归调用<code>add</code>（实现中是一个内部的匿名函数）。</li>
</ol>

<p>通过这个机制就可以把上面三种类型的参数传入方式都解析出来，提取对应的回调，并添加到回调列表里面。再关注一下最后的几行代码：</p>

<pre><code>// Do we need to add the callbacks to the
// current firing batch?
if ( firing ) {
  firingLength = list.length;
// With memory, if we&#39;re not firing then
// we should call right away
} else if ( memory ) {
  firingStart = start;
  fire( memory );
}</code></pre>

<p>注意，<code>fire</code>的时候也可以调用<code>add</code>。如果正处在<code>fire</code>的过程中（<code>firing === true</code>），需要把要遍历的回调列表长度调整到调用<code>add</code>之后的长度。如果不在<code>fire</code>过程中，则要判断<code>memory</code>标志是否生效，生效则需要重新触发<code>fire</code>，保证刚增加的回调函数能顺利执行。</p>

<p>最后再关注一下<code>remove</code>方法，这里值得注意的也是<code>fire</code>过程中的<code>remove</code>。需要判断当前删除的回调是否已经执行，代码片段如下：</p>

<pre><code>// Handle firing indexes
if ( firing ) {
  if ( index &lt;= firingLength ) {
    firingLength--;
  }
  if ( index &lt;= firingIndex ) {
    firingIndex--;
  }
}</code></pre>

<p><code>Callbacks</code>对象还有其他方法，例如<code>has</code>、<code>empty</code>、<code>disable</code>、<code>lock</code>，还有几个获取状态的方法，这里就不详细展开了，有兴趣的同鞋可以参考上面的github上的链接看其他的源码。不得不佩服jQuery为了满足各种各样的场景而写出这样完备的代码，在日常工作中，我个人还是觉得应该根据具体的应用场景去考虑代码的健壮性，如果每一个功能、每一段代码都得像jQuery那样严谨完备，的确是件十分美妙的事情，工作往往是更现实的事情，各种无奈就不多展开了啊！</p>
         </li>
       
         <li style='margin-bottom: 50px;'>
            <a href='/2013/08/19/jquery-callbacks'><h2>jQuery.Callbacks</h2></a>&nbsp;<span>19 Aug 2013</span>
            <p>今天第一天入职，就听到<code>jQuery.Callbacks</code>这个方法。使用这个方法可以实现功能强大的观察者模式。</p>

<blockquote>
<p>A multi-purpose callbacks list object that provides a powerful way to manage callback lists.</p>
</blockquote>

<p>这个方法是<code>jQuery.ajax</code>和<code>jQuery.Deffered</code>的内部实现呢。今天先不看代码，先简单看看这个方法是怎么使用的。这个方法接受一个参数<code>flag</code>，可选的值有以下几个或者这几个的组合（之间用空格隔开）：</p>

<ol>
<li><code>once</code>，保证相关的绑定的回调只会调用一次。</li>

<li><code>memory</code>，这个是一个相当有趣的标志。当先触发，再绑定的情况下绑定的回调照样会执行！</li>

<li><code>unique</code>，保证每个回调函数只能被绑定一次。</li>

<li><code>stopOnFalse</code>，当任何一个回调函数返回<code>false</code>的时候停止其他回调函数的执行。</li>
</ol>

<p>执行这个方法后会返回一个<code>Callbacks</code>类型的对象。该对象有几个比较重要的方法：</p>

<ol>
<li><code>add</code>，绑定回调，可以绑定单个函数或者绑定一个函数的数组。</li>

<li><code>remove</code>，解除绑定，接受的参数与<code>add</code>一致。</li>

<li><code>fire</code>，触发回调，传入的参数也会传入到每一个回调函数里面。</li>

<li><code>disable</code>，不接受参数，禁用该对象，<code>fire</code>、<code>remove</code>等都被禁用。</li>
</ol>

<p>使用<code>jQuery.Callbacks</code>可以实现一个观察者模式。下面是jQuery文档里面的一个例子：</p>

<pre><code>var topics = {};

jQuery.Topic = function( id ) {
  var callbacks,
    method,
    topic = id &amp;&amp; topics[ id ];
  
  if ( !topic ) {
    callbacks = jQuery.Callbacks();
    topic = {
      publish: callbacks.fire,
      subscribe: callbacks.add,
      unsubscribe: callbacks.remove
    };
    if ( id ) {
      topics[ id ] = topic;
    }
  }
  return topic;
};</code></pre>

<p>使用方法为：</p>

<pre><code>// Subscribers
$.Topic( &quot;mailArrived&quot; ).subscribe( fn1 );
$.Topic( &quot;mailArrived&quot; ).subscribe( fn2 );
$.Topic( &quot;mailSent&quot; ).subscribe( fn1 );

// Publisher
$.Topic( &quot;mailArrived&quot; ).publish( &quot;hello world!&quot; );
$.Topic( &quot;mailSent&quot; ).publish( &quot;woo! mail!&quot; );</code></pre>

<p>例子<a href='http://jsfiddle.net/x5NNQ/'>参考这里</a>。明天继续围观相关jQuery的源码！</p>
         </li>
       
         <li style='margin-bottom: 50px;'>
            <a href='/2013/08/18/javascript-timer-usage'><h2>Secrets of the JavaScript Ninja 读书笔记之 使用定时器</h2></a>&nbsp;<span>18 Aug 2013</span>
            <p>继续周末读书时间。昨天讨论了定时器的基本原理，今天来看看定时器在实际使用中能做些什么有趣的事情。</p>

<h3 id='id38'>连续执行耗时任务</h3>

<p>在某些应用场景中，需要对一大堆数据进行处理（例如根据数据渲染表格，数据量超过1000+条）。如果仅仅用一个<code>for</code>循环对每一个数据项进行处理，由于整个处理的过程都是同步的，而JavaScript的处理线程（包括浏览器渲染、事件处理等）是单线程的，这样连续的同步操作会导致浏览器没有办法对用户的操作进行响应，某些浏览器（例如FireFox），在超过特定的时间内执行的JavaScript代码，会弹出提示框提示用户是否继续执行这些操作。这样的用户体验是相当糟糕的。那么如何在处理这一大堆数据的同时，也不让浏览器弹出类似的提示框呢？</p>

<p>我们可以利用定时器把这一系列的同步操作分割成多个异步操作连续执行，在每个异步操作执行的间隔，把JavaScript线程空闲出来处理浏览器另外的事务。可以抽象出这样一个方法，对大数据（一般是<code>length</code>相当长的数组）进行分段操作：</p>

<pre><code>function asyncProcess(data, fn, complete, blockSize, timeout, context) {
  data = data || [];
  fn = fn || function () {};
  blockSize = blockSize || data.length;
  timeout = timeout || 200;
  complete = complete || function () {};

  var index = tId = 0;

  function process() {
    var block = data.slice(index, index + blockSize);
    for (var i = 0; i &lt; block.length; i++) {
      fn.call(context, block[i]);
    }
    if (index + blockSize &gt; data.length) {
      complete.call(context);
      clearTimeout(tId);
    } else {
      index = index + blockSize;
      tId = setTimeout(process, timeout);
    }
  }

  tId = setTimeout(process, timeout);
}</code></pre>

<p>在处理好每次分段处理的数据量之后，再也不会担心浏览器弹出那些讨厌的对话框了！例子<a href='http://jsfiddle.net/bVjxX/1/'>参考这里</a>。</p>

<h3 id='id39'>统一控制的定时器</h3>

<p>当一个功能比较简单的时候，可能仅仅需要一个或者两个定时器就能完成对应的功能。但是，随着需求的增加，可能会不断地往页面中添加定时器。当定时器的数量不断增多的时候，整个页面的定时器就越来越难管理起来。更多的定时器也意味着要处理更多相关的撤销代码、内存问题等。</p>

<p>应该尽量减少定时器的数量。能否用一个定时器，通过增加、删除对应的处理逻辑来实现相关的增加、撤销定时器的功能？统一控制的定时器就是为了解决这个问题。统一控制的定时器有下列特点：</p>

<p>1. 只有一个定时器实例。 2. 可以随时启停定时器。 3. 简化删除一个“定时器”的逻辑。</p>

<p>以下是实现这个定时器的代码：</p>

<pre><code>var timers = {                               
  timerID: 0,                                           
  timers: [],                                           
  add: function(fn) {                            
    this.timers.push(fn);
  },
  start: function() {                             
    if (this.timerID) return;
    (function runNext() {
      if (timers.timers.length &gt; 0) {
        for (var i = 0; i &lt; timers.timers.length; i++) {
          if (timers.timers[i]() === false) {
            timers.timers.splice(i,1);
            i--;
          }
        }
        timers.timerID = setTimeout(runNext, 0);
      }
    })();
  },
  stop: function() {                                  
    clearTimeout(this.timerID);
    this.timerID = 0;
  }
};</code></pre>

<p>通过对应的<code>start</code>和<code>stop</code>来实现定时器的启停。通过<code>add</code>增加一个“定时器”。通过在“定时器”逻辑中返回<code>false</code>来删除这个“定时器”。</p>
         </li>
       
         <li style='margin-bottom: 50px;'>
            <a href='/2013/08/17/javascript-timer'><h2>Secrets of the JavaScript Ninja 读书笔记之 定时器是怎么运作的</h2></a>&nbsp;<span>17 Aug 2013</span>
            <p>又到周末读书的时间啦！今天分享一下书中关于定时器的一些简单的原理。</p>

<h3 id='id36'>创建、撤销定时器</h3>

<p>在JavaScript中，定时器有两种。一种是Timeout，只会在设置的时间之后执行一次。另一种是Interval，会以设置的时间为周期反复执行。有两个创建定时器的方法与之对应：<code>setTimeout</code>和<code>setInterval</code>。这两个方法都接受两个参数：</p>

<ol>
<li>执行的代码，这个参数可以是一个匿名函数、一个函数的引用，甚至是一段以字符串形式表示的JavaScript代码。 2. 设置的时间。</li>
</ol>

<p>这两个参数都会返回一个<code>id</code>，通过这个<code>id</code>可以调用对应的<code>clearTimeout</code>和<code>clearInterval</code>撤销对应的定时器。撤销之后（Timeout必须在设置事件之前撤销）指定的代码将不会被执行。虽然有些浏览器可以用<code>clearTimeout</code>去撤销<code>setInterval</code>或者用<code>clearInterval</code>去撤销<code>setTimeout</code>，但是<strong>强烈建议创建跟撤销的方法配对使用</strong>。</p>

<h3 id='id37'>定时器执行</h3>

<p>记住一点，<strong>在定时器中设置的时间并不是精确的</strong>。例如以下代码：</p>

<pre><code>setTimeout(fn, 10);</code></pre>

<p><code>fn</code>并不一定在10毫秒之后被调用。这个是跟JavaScript是单线程处理有关。每一个时刻只有一段JavaScript代码被执行。在设置完定时器之后，可能有一段耗时超过10毫秒的代码一直在执行，也可能用户在这10毫秒之内频繁与浏览器进行交互，导致对应的事件处理程序不断被触发等。所以，尤其是Interval，这个时间并不是精确的。</p>

<h3 id='timeoutinterval'>Timeout跟Interval的区别</h3>

<p>最大的区别肯定是Timeout只执行一次，而Interval则会周期执行，一个Interval可以看作是一个不断Timouet不断地重复。其实它们之间还有很多不一样的地方，当设置时间到达之后还有代码在执行导致定时器发生延时：</p>

<ol>
<li>Timeout会一直延迟直到JavaScript线程空闲的时候立即执行。这个行为导致<code>setTimeout</code>代码执行的间隔时间只会比设置的事件要长，而不可能会短。</li>

<li>Interval先会查找执行队列中有没有要执行代码的实例，如果没有，则会在执行队列中对应的位置插入要执行的代码。如果已经存在了，则不会再次插入要执行代码的实例。所以，当执行被延时，队列中只会存在一份要执行代码的实例。当JavaScript线程空闲的时候，代码从队列中出队，当设置的时间又到的时候，又会在执行队列中插入对应的代码实例。由于这种机制，如果在代码出队之后，设置周期又到了，这之间的时间可能会比设置时间要短，这时Interval真正执行的周期就比设置的时间要短。</li>
</ol>

<p>上面说的这么多，可能没说清楚……但是只要记住一个点就可以了，就是<strong>Timeout执行的延迟永远只能更长，而Interval执行的周期则有可能比设置的时间更短</strong>。使用<code>setTimeout</code>多次重复调用来模拟<code>setInterval</code>的效果可以避免在一个周期内重复调用对应的代码超过一次，当执行的周期不是要求十分精确的时候（虽然<code>setInterval</code>也不能保证太精确，但是周期肯定会比反复调用<code>setTimeout</code>要稳定，如果代码能在设置的时间之内执行完），可以考虑使用反复调用<code>setTimeout</code>来代替<code>setInterval</code>进行周期性的任务。</p>
         </li>
       
    </ul>
  </div>
  <!--
  <div id="right" class="span3">
    <ul class="posts">
      
        <li><span>21 Aug 2013</span> &raquo; <a href="/2013/08/21/document-write">document write</a></li>
      
        <li><span>20 Aug 2013</span> &raquo; <a href="/2013/08/20/jquery-callbacks-source-code">jQuery源码解析之jQuery.Callbacks</a></li>
      
        <li><span>19 Aug 2013</span> &raquo; <a href="/2013/08/19/jquery-callbacks">jQuery.Callbacks</a></li>
      
        <li><span>18 Aug 2013</span> &raquo; <a href="/2013/08/18/javascript-timer-usage">Secrets of the JavaScript Ninja 读书笔记之 使用定时器</a></li>
      
        <li><span>17 Aug 2013</span> &raquo; <a href="/2013/08/17/javascript-timer">Secrets of the JavaScript Ninja 读书笔记之 定时器是怎么运作的</a></li>
      
        <li><span>16 Aug 2013</span> &raquo; <a href="/2013/08/16/css-media-query">响应式设计入门之media query</a></li>
      
        <li><span>15 Aug 2013</span> &raquo; <a href="/2013/08/15/ie-conditional-comment">IE条件注释</a></li>
      
        <li><span>14 Aug 2013</span> &raquo; <a href="/2013/08/14/dom-removeattribute">DOM 的removeAttribute方法</a></li>
      
        <li><span>13 Aug 2013</span> &raquo; <a href="/2013/08/13/dom-setattribute">DOM的setAttribute方法</a></li>
      
        <li><span>12 Aug 2013</span> &raquo; <a href="/2013/08/12/dom-getattribute">DOM的getAttribute方法</a></li>
      
        <li><span>11 Aug 2013</span> &raquo; <a href="/2013/08/11/javascript-code-evaluate">Secrets of the JavaScript Ninja 读书笔记之 执行字符串形式的表达式</a></li>
      
        <li><span>10 Aug 2013</span> &raquo; <a href="/2013/08/10/javascript-oo-gotchas">Secrets of the JavaScript Ninja 读书笔记之 面向对象陷阱</a></li>
      
        <li><span>09 Aug 2013</span> &raquo; <a href="/2013/08/09/jquery-each">jQuery源码解析之jQuery.each</a></li>
      
        <li><span>08 Aug 2013</span> &raquo; <a href="/2013/08/08/javascript-iteract-an-object">在JavaScript中遍历一个对象的所有属性</a></li>
      
        <li><span>07 Aug 2013</span> &raquo; <a href="/2013/08/07/css-bfc">了解BFC</a></li>
      
        <li><span>06 Aug 2013</span> &raquo; <a href="/2013/08/06/css-ie-haslayout">IE的hasLayout</a></li>
      
        <li><span>05 Aug 2013</span> &raquo; <a href="/2013/08/05/javascript-flash-comunication">JavaScript与Flash通信</a></li>
      
        <li><span>04 Aug 2013</span> &raquo; <a href="/2013/08/04/high-performance-javascript-read-note">High Performance JavaScript 读书笔记之 数据存取</a></li>
      
        <li><span>03 Aug 2013</span> &raquo; <a href="/2013/08/03/yahoo-performance-rules">Yahoo!性能优化规则</a></li>
      
        <li><span>02 Aug 2013</span> &raquo; <a href="/2013/08/02/javascript-bind-event-handler">三种原生JavaScript绑定事件方式对比</a></li>
      
        <li><span>01 Aug 2013</span> &raquo; <a href="/2013/08/01/javascript-typeof">JavaScript typeof操作符</a></li>
      
        <li><span>31 Jul 2013</span> &raquo; <a href="/2013/07/31/javascript-instanceof">JavaScript instanceof操作符</a></li>
      
        <li><span>30 Jul 2013</span> &raquo; <a href="/2013/07/30/beforeunload-event">beforeunload事件</a></li>
      
        <li><span>29 Jul 2013</span> &raquo; <a href="/2013/07/29/html-link-tag">HTML LINK 标签</a></li>
      
        <li><span>28 Jul 2013</span> &raquo; <a href="/2013/07/28/closure-usage-3">Secrets of the JavaScript Ninja 读书笔记之 闭包（三）</a></li>
      
        <li><span>27 Jul 2013</span> &raquo; <a href="/2013/07/27/closure-usage-2">Secrets of the JavaScript Ninja 读书笔记之 闭包（二）</a></li>
      
        <li><span>26 Jul 2013</span> &raquo; <a href="/2013/07/26/closure-usage">Secrets of the JavaScript Ninja 读书笔记之 闭包（一）</a></li>
      
        <li><span>25 Jul 2013</span> &raquo; <a href="/2013/07/25/http-method">HTTP协议之HTTP方法</a></li>
      
        <li><span>24 Jul 2013</span> &raquo; <a href="/2013/07/24/css-word-break">换行还是不换行之word-break</a></li>
      
        <li><span>23 Jul 2013</span> &raquo; <a href="/2013/07/23/css-word-wrap">换行还是不换行之word-wrap</a></li>
      
        <li><span>22 Jul 2013</span> &raquo; <a href="/2013/07/22/css-white-space">换行还是不换行之white-space</a></li>
      
        <li><span>21 Jul 2013</span> &raquo; <a href="/2013/07/21/a-http-request">HTTP协议之简述一个HTTP请求的经过</a></li>
      
        <li><span>20 Jul 2013</span> &raquo; <a href="/2013/07/20/javascript-overload">Secrets of the JavaScript Ninja 读书笔记之 JavaScript重载</a></li>
      
        <li><span>19 Jul 2013</span> &raquo; <a href="/2013/07/19/css-equal-height-again">再谈CSS等高布局</a></li>
      
        <li><span>18 Jul 2013</span> &raquo; <a href="/2013/07/18/negative-margin">神奇的负边距</a></li>
      
        <li><span>17 Jul 2013</span> &raquo; <a href="/2013/07/17/viewport">响应式设计入门之viewport</a></li>
      
        <li><span>16 Jul 2013</span> &raquo; <a href="/2013/07/16/css-equal-hight">CSS等高布局</a></li>
      
        <li><span>15 Jul 2013</span> &raquo; <a href="/2013/07/15/event-constructor-and-jquery-trigger">模拟触发DOM事件之jQuery trigger</a></li>
      
        <li><span>14 Jul 2013</span> &raquo; <a href="/2013/07/14/simulate-event">模拟触发DOM事件之原生模拟事件</a></li>
      
        <li><span>13 Jul 2013</span> &raquo; <a href="/2013/07/13/http-status-code">HTTP协议之HTTP状态码</a></li>
      
        <li><span>12 Jul 2013</span> &raquo; <a href="/2013/07/12/http-header">HTTP协议之HTTP 头</a></li>
      
        <li><span>11 Jul 2013</span> &raquo; <a href="/2013/07/11/jquery-event-2">jQuery事件绑定研究续</a></li>
      
        <li><span>10 Jul 2013</span> &raquo; <a href="/2013/07/10/jquery-bind-live-on-delegate">简析jQuery几个绑定事件方法的优劣异同</a></li>
      
        <li><span>08 Jul 2013</span> &raquo; <a href="/2013/07/08/three-column-layout-middle-first">经典三列布局之如何让中间的列先显示出来</a></li>
      
        <li><span>07 Jul 2013</span> &raquo; <a href="/2013/07/07/window-location">window.location 浅析</a></li>
      
        <li><span>06 Jul 2013</span> &raquo; <a href="/2013/07/06/frontend-career">前端攻城师的职业规划</a></li>
      
        <li><span>05 Jul 2013</span> &raquo; <a href="/2013/07/05/href-javascript-expression">Href中的JavaScript link</a></li>
      
        <li><span>04 Jul 2013</span> &raquo; <a href="/2013/07/04/html-meta-tag">HTML META 标签入门</a></li>
      
        <li><span>03 Jul 2013</span> &raquo; <a href="/2013/07/03/a-tag">HTML A 标签简析</a></li>
      
        <li><span>02 Jul 2013</span> &raquo; <a href="/2013/07/02/position-fixed">Position: fixed 浏览器兼容性分析</a></li>
      
        <li><span>23 Jan 2013</span> &raquo; <a href="/2013/01/23/post">弹出的模态对话框被拦截的条件</a></li>
      
        <li><span>22 Dec 2012</span> &raquo; <a href="/2012/12/22/note-2012-12-22">2012 12 22 笔记</a></li>
      
        <li><span>20 Dec 2012</span> &raquo; <a href="/2012/12/20/2012-12-20-note">2012 12 20 Note</a></li>
      
        <li><span>18 Dec 2012</span> &raquo; <a href="/2012/12/18/note-2012-12-18">2012-12-18 笔记</a></li>
      
        <li><span>17 Dec 2012</span> &raquo; <a href="/2012/12/17/note-2012-12-17">Note 2012 12 17</a></li>
      
        <li><span>16 Dec 2012</span> &raquo; <a href="/2012/12/16/my-first-post">My First Post</a></li>
      
    </ul>
  </div>
  -->
</div>
  </div>
</div>


            </DIV>
            <DIV class=footer>
              <p>
                &copy; Zhiying.Mai 2012 with help from
                <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">
                  Jekyll Bootstrap
                </a>
                and
                <a href="http://twitter.github.com/bootstrap/" target="_blank">
                  Twitter Bootstrap
                </a>
              </p>
            </DIV>
            <!--</DIV>-->
          </DIV>
        </DIV>
      </DIV>
      
  </body>
</html>

