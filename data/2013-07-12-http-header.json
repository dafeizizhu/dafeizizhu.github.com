{"year":"2013","month":"07","day":"12","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/07/12/http-header.html","fileName":"http-header","layout":"post","title":"HTTP协议之HTTP 头","description":"","tags":["http"],"markdownText":"\n\n\n今天启程去阿里ADC，无奈被困机场，飞机起飞遥遥无期，故趁等飞机起飞的闲暇事件写一下HTTP协议之HTTP头的简介，来慰藉我寂寞的心（顺便鄙视周围的家伙们都在玩手机）。\n\n看了一下RFC关于HTTP头的规范，我跟我的小伙伴们都惊呆了，有这么多，[参考这里](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)。今天我决定先从一个比较简单的角度入手，对HTTP头及几个重要的头进行解析，抛砖引玉一下。\n\n> HTTP header fields are components of the message header of requests and responses in the Hypertext Transfer Protocol (HTTP). They define the operating parameters of an HTTP transaction.\n\n简单地说就是一些关于HTTP协议中请求与响应的传输中的控制参数。HTTP头由多个头域组成，至一个空的头域结束。每个头域是一个冒号分隔的键值对。HTTP头有标准头跟自定义头两种。标准头是每个实现都必须支持的头，如`Expires`、`Set-Cookie`等。非标准头可以由实现者自己定义，如IE的`X-UA-Compatible`等。\n\n在HTTP协议本身是没有限制HTTP头的大小。尽管如此，很多Web服务器、客户端和代理软件都对HTTP头的大小进行限制。如Apache2.3中，每个头的大小最多是8160个字节，一个请求里面最多包含100个头。\n\n头域大致可以分成两种，一种是请求头，客户端向服务器发请求的时候使用什么方法、请求什么URI、协议版本等都是在请求头中指定。另一种是响应头，服务器接到客户端的请求后返回响应的是否成功、返回的MIME类型是什么都在请求头中指定。\n\n\n### 请求头\n\n常用的标准请求头包括下面几个：\n\n1. `Accept`，声明哪种相应是可接受的，如`text\\plain`、`application\\json`等。\n2. `Cache-Control`，声明缓存控制机制，如`no-cache`声明不做缓存。\n3. `Connection`，声明与服务器的连接机制，如`keep-alive`等。\n4. `Cookie`，声明Cookie信息。\n5. `Content-Type`，声明请求体的MIME类型。\n6. `Host`，声明需要请求URI的主机信息。\n7. `If-Match`，声明匹配这个请求的Key，如果服务器的ETag与这个Key一致，则认为这个请求的资源没有发生改变，客户端可以选择从还从中加载这个请求。\n8. `Origin`，声明跨域请求的时候支持什么域名进行访问。\n9. `User-Agent`，声明发出这个请求的客户端的描述，如果是浏览器发出的请求，可以根据这个头判断是哪个浏览器的哪个版本。\n\n非标准请求头包括下面几个：\n\n1. `X-Request-With`，通常通过这个头告诉服务器这个请求是XMLHttpRequest发送的。\n2. `DNT`，表示是否开启`DNT`（Do not track）功能，`1`表示开启，`0`表示关闭。\n3. `Front-End-Https`，是微软用的一个自定义头，与负载均衡有关。\n4. `Proxy-Connection`，与标准头`Connection`一致，是早期HTTP协议的产物。\n\n\n### 相应头\n\n常用的标准相应头大概有以下几个：\n\n1. `Access-Control-Allow-Origin`，声明这个响应可以参与到哪个域的跨域访问中。`*`表示可以参与到任何域的跨域访问。\n2. `Allow`，声明这个HTTP响应是使用哪个HTTP方法，如`GET`、`POST`等。如果是一个不支持的HTTP方法，则会返回错误码`405 Method not allowed`。\n3. `Content-Type`，声明这个响应的MIME类型。\n4. `ETag`，声明这个响应版本的key，可以标识一个资源是否有改变过（参考请求头`If-Match`）。\n5. `Pragma`，声明这个响应是否支持缓存，可以设置`no-cache`禁用这个响应的缓存。\n6. `Refresh`，声明这个响应在特定时间后刷新或者跳转到新的URL。例如`Refresh: 5;http://example.com`，就表示5秒之后跳转到指定的URL。\n7. `Status`，声明这个响应的状态码，后面会专门写一篇关于状态码的文章。\n\n非标准的相应头包括下面几个：\n\n1. `X-Frame-Options`，声明防止Clickjacking攻击的参数，如`deny`就是防止响应被渲染在iframe里面，而`sameorigin`就是防止响应在非本域的页面中渲染。\n2. `X-Content-Type-Options`，帮助IE能不识别MIME类型不对的stylesheet和script，也用于Chrome下载其扩展。只有一个合法值`nosniff`。\n3. `X-Powered-By`，声明该响应是通过哪种语言生成的，如`X-Powered-By: PHP/5.4.0`。\n4. `X-UA-Compatible`，帮助IE使用特定的文档模式显式该响应，也可以指导IE使用Google Chrome Frame来渲染页面。\n\n在`meta`里面定义的`http-equiv`头，跟某些HTTP头是相通的。可以设置服务器返回的HTTP头，让整个站点的所有页面都在HTTP传输过程中的行为保持一直。这样可以减少纯HTML（服务器脚本，如JSP、PHP、ASP等可以通过`include`的方式实现类似效果）的页面的代码量，减轻维护成本。\n\n今天晚上12点才到杭州，1点半才到酒店，不过精神还行，期待明天阿里ADC！\n","htmlText":"<p>今天启程去阿里ADC，无奈被困机场，飞机起飞遥遥无期，故趁等飞机起飞的闲暇事件写一下HTTP协议之HTTP头的简介，来慰藉我寂寞的心（顺便鄙视周围的家伙们都在玩手机）。</p>\n<p>看了一下RFC关于HTTP头的规范，我跟我的小伙伴们都惊呆了，有这么多，<a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\">参考这里</a>。今天我决定先从一个比较简单的角度入手，对HTTP头及几个重要的头进行解析，抛砖引玉一下。</p>\n<blockquote>\n<p>HTTP header fields are components of the message header of requests and responses in the Hypertext Transfer Protocol (HTTP). They define the operating parameters of an HTTP transaction.</p>\n</blockquote>\n<p>简单地说就是一些关于HTTP协议中请求与响应的传输中的控制参数。HTTP头由多个头域组成，至一个空的头域结束。每个头域是一个冒号分隔的键值对。HTTP头有标准头跟自定义头两种。标准头是每个实现都必须支持的头，如<code>Expires</code>、<code>Set-Cookie</code>等。非标准头可以由实现者自己定义，如IE的<code>X-UA-Compatible</code>等。</p>\n<p>在HTTP协议本身是没有限制HTTP头的大小。尽管如此，很多Web服务器、客户端和代理软件都对HTTP头的大小进行限制。如Apache2.3中，每个头的大小最多是8160个字节，一个请求里面最多包含100个头。</p>\n<p>头域大致可以分成两种，一种是请求头，客户端向服务器发请求的时候使用什么方法、请求什么URI、协议版本等都是在请求头中指定。另一种是响应头，服务器接到客户端的请求后返回响应的是否成功、返回的MIME类型是什么都在请求头中指定。</p>\n<h3 id=\"-\">请求头</h3>\n<p>常用的标准请求头包括下面几个：</p>\n<ol>\n<li><code>Accept</code>，声明哪种相应是可接受的，如<code>text\\plain</code>、<code>application\\json</code>等。</li>\n<li><code>Cache-Control</code>，声明缓存控制机制，如<code>no-cache</code>声明不做缓存。</li>\n<li><code>Connection</code>，声明与服务器的连接机制，如<code>keep-alive</code>等。</li>\n<li><code>Cookie</code>，声明Cookie信息。</li>\n<li><code>Content-Type</code>，声明请求体的MIME类型。</li>\n<li><code>Host</code>，声明需要请求URI的主机信息。</li>\n<li><code>If-Match</code>，声明匹配这个请求的Key，如果服务器的ETag与这个Key一致，则认为这个请求的资源没有发生改变，客户端可以选择从还从中加载这个请求。</li>\n<li><code>Origin</code>，声明跨域请求的时候支持什么域名进行访问。</li>\n<li><code>User-Agent</code>，声明发出这个请求的客户端的描述，如果是浏览器发出的请求，可以根据这个头判断是哪个浏览器的哪个版本。</li>\n</ol>\n<p>非标准请求头包括下面几个：</p>\n<ol>\n<li><code>X-Request-With</code>，通常通过这个头告诉服务器这个请求是XMLHttpRequest发送的。</li>\n<li><code>DNT</code>，表示是否开启<code>DNT</code>（Do not track）功能，<code>1</code>表示开启，<code>0</code>表示关闭。</li>\n<li><code>Front-End-Https</code>，是微软用的一个自定义头，与负载均衡有关。</li>\n<li><code>Proxy-Connection</code>，与标准头<code>Connection</code>一致，是早期HTTP协议的产物。</li>\n</ol>\n<h3 id=\"-\">相应头</h3>\n<p>常用的标准相应头大概有以下几个：</p>\n<ol>\n<li><code>Access-Control-Allow-Origin</code>，声明这个响应可以参与到哪个域的跨域访问中。<code>*</code>表示可以参与到任何域的跨域访问。</li>\n<li><code>Allow</code>，声明这个HTTP响应是使用哪个HTTP方法，如<code>GET</code>、<code>POST</code>等。如果是一个不支持的HTTP方法，则会返回错误码<code>405 Method not allowed</code>。</li>\n<li><code>Content-Type</code>，声明这个响应的MIME类型。</li>\n<li><code>ETag</code>，声明这个响应版本的key，可以标识一个资源是否有改变过（参考请求头<code>If-Match</code>）。</li>\n<li><code>Pragma</code>，声明这个响应是否支持缓存，可以设置<code>no-cache</code>禁用这个响应的缓存。</li>\n<li><code>Refresh</code>，声明这个响应在特定时间后刷新或者跳转到新的URL。例如<code>Refresh: 5;http://example.com</code>，就表示5秒之后跳转到指定的URL。</li>\n<li><code>Status</code>，声明这个响应的状态码，后面会专门写一篇关于状态码的文章。</li>\n</ol>\n<p>非标准的相应头包括下面几个：</p>\n<ol>\n<li><code>X-Frame-Options</code>，声明防止Clickjacking攻击的参数，如<code>deny</code>就是防止响应被渲染在iframe里面，而<code>sameorigin</code>就是防止响应在非本域的页面中渲染。</li>\n<li><code>X-Content-Type-Options</code>，帮助IE能不识别MIME类型不对的stylesheet和script，也用于Chrome下载其扩展。只有一个合法值<code>nosniff</code>。</li>\n<li><code>X-Powered-By</code>，声明该响应是通过哪种语言生成的，如<code>X-Powered-By: PHP/5.4.0</code>。</li>\n<li><code>X-UA-Compatible</code>，帮助IE使用特定的文档模式显式该响应，也可以指导IE使用Google Chrome Frame来渲染页面。</li>\n</ol>\n<p>在<code>meta</code>里面定义的<code>http-equiv</code>头，跟某些HTTP头是相通的。可以设置服务器返回的HTTP头，让整个站点的所有页面都在HTTP传输过程中的行为保持一直。这样可以减少纯HTML（服务器脚本，如JSP、PHP、ASP等可以通过<code>include</code>的方式实现类似效果）的页面的代码量，减轻维护成本。</p>\n<p>今天晚上12点才到杭州，1点半才到酒店，不过精神还行，期待明天阿里ADC！</p>\n","summaryMarkdownText":"\n\n\n今天启程去阿里ADC，无奈被困机场，飞机起飞遥遥无期，故趁等飞机起飞的闲暇事件写一下HTTP协议之HTTP头的简介，来慰藉我寂寞的心（顺便鄙视周围的家伙们都在玩手机）。\n\n看了一下RFC关于HTTP头的规范，我跟我的小伙伴们都惊呆了，有这么多，[参考这里](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)。今天我决定先从一个比较简单的角度入手，对HTTP头及几个重要的头进行解析，抛砖引玉一下。\n\n> HTTP header fields are components of the message header of requests and responses in the Hypertext Transfer Protocol (HTTP). They define the operating parameters of an HTTP transaction.\n\n简单地说就是一些关于HTTP协议中请求与响应的传输中的控制参数。HTTP头由多个头域组成，至一个空的头域结束。每个头域是一个冒号分隔的键值对。HTTP头有标准头跟自定义头两种。标准头是每个实现都必须支持的头，如`Expires`、`Set-Cookie`等。非标准头可以由实现者自己定义，如IE的`X-UA-Compatible`等。\n\n在HTTP协议本身是没有限制HTTP头的大小。尽管如此，很多Web服务器、客户端和代理软件都对HTTP头的大小进行限制。如Apache2.3中，每个头的大小最多是8160个字节，一个请求里面最多包含100个头。\n\n头域大致可以分成两种，一种是请求头，客户端向服务器发请求的时候使用什么方法、请求什么URI、协议版本等都是在请求头中指定。另一种是响应头，服务器接到客户端的请求后返回响应的是否成功、返回的MIME类型是什么都在请求头中指定。\n\n\n### 请求头\n\n常用的标准请求头包括下面几个：\n\n1. `Accept`，声明哪种相应是可接受的，如`text\\plain`、`application\\json`等。\n2. `Cache-Control`，声明缓存控制机制，如`no-cache`声明不做缓存。\n3. `Connection`，声明与服务器的连接机制，如`keep-alive`等。\n4. `Cookie`，声明Cookie信息。\n5. `Content-Type`，声明请求体的MIME类型。","summaryHtmlText":"<p>今天启程去阿里ADC，无奈被困机场，飞机起飞遥遥无期，故趁等飞机起飞的闲暇事件写一下HTTP协议之HTTP头的简介，来慰藉我寂寞的心（顺便鄙视周围的家伙们都在玩手机）。</p>\n<p>看了一下RFC关于HTTP头的规范，我跟我的小伙伴们都惊呆了，有这么多，<a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\">参考这里</a>。今天我决定先从一个比较简单的角度入手，对HTTP头及几个重要的头进行解析，抛砖引玉一下。</p>\n<blockquote>\n<p>HTTP header fields are components of the message header of requests and responses in the Hypertext Transfer Protocol (HTTP). They define the operating parameters of an HTTP transaction.</p>\n</blockquote>\n<p>简单地说就是一些关于HTTP协议中请求与响应的传输中的控制参数。HTTP头由多个头域组成，至一个空的头域结束。每个头域是一个冒号分隔的键值对。HTTP头有标准头跟自定义头两种。标准头是每个实现都必须支持的头，如<code>Expires</code>、<code>Set-Cookie</code>等。非标准头可以由实现者自己定义，如IE的<code>X-UA-Compatible</code>等。</p>\n<p>在HTTP协议本身是没有限制HTTP头的大小。尽管如此，很多Web服务器、客户端和代理软件都对HTTP头的大小进行限制。如Apache2.3中，每个头的大小最多是8160个字节，一个请求里面最多包含100个头。</p>\n<p>头域大致可以分成两种，一种是请求头，客户端向服务器发请求的时候使用什么方法、请求什么URI、协议版本等都是在请求头中指定。另一种是响应头，服务器接到客户端的请求后返回响应的是否成功、返回的MIME类型是什么都在请求头中指定。</p>\n<h3 id=\"-\">请求头</h3>\n<p>常用的标准请求头包括下面几个：</p>\n<ol>\n<li><code>Accept</code>，声明哪种相应是可接受的，如<code>text\\plain</code>、<code>application\\json</code>等。</li>\n<li><code>Cache-Control</code>，声明缓存控制机制，如<code>no-cache</code>声明不做缓存。</li>\n<li><code>Connection</code>，声明与服务器的连接机制，如<code>keep-alive</code>等。</li>\n<li><code>Cookie</code>，声明Cookie信息。</li>\n<li><code>Content-Type</code>，声明请求体的MIME类型。</li>\n</ol>\n"}