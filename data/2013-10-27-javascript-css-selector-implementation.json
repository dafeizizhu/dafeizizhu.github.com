{"year":"2013","month":"10","day":"27","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/10/27/javascript-css-selector-implementation.html","fileName":"javascript-css-selector-implementation","layout":"post","title":"Secrets of the JavaScript Ninja 读书笔记之 纯JavaScript实现的CSS选择器引擎","description":"","tags":["JavaScript"],"markdownText":"\n\n\n一个CSS选择器引擎的核心其实是纯JavaScript实现的这个部分。最主要的功能就是把CSS选择器映射到一系列浏览器原生提供的API（例如`getElementById`或者`getElementsByTagName`等）的调用序列，通过这些原生的API去寻找我们想要定位到的元素。\n\n为什么还需要一个纯JavaScript实现的CSS选择器引擎？\n\n1. a因为IE6和IE7不支持原生的CSS选择器、也不支持使用XPath。\n2. a因为我们的站点可能需要向前兼容这些古董浏览器。\n3. a因为效率，某些CSS选择器使用原生的API速度更快（例如`id`选择器）。\n4. a因为CSS选择器的覆盖率，由于不是所有支持原生CSS选择器的浏览器都支持所有CSS选择器，所以当某个选择器在某个浏览器里面不支持就要退化到纯JavaScript的实现。\n\n通常我们会从左到右分析一个CSS选择器，然后顺着`root`往下找，例如以下的选择器：\n\n    div.ninja a span\n\n按照一般的逻辑，我们会找`class`是`ninja`的`div`，在它的子元素中找`a`，在`a`的子元素中找`span`。这里要注意两个问题：\n\n1. a返回的结果可能有多个，它们的顺序要跟定义的顺序一致。\n2. a返回的结果中不能有重复的DOM。\n\n由于这两个问题，使用从上到下分析DOM文档树的方法可能需要一些额外的工作量，所以就有了从下到上分析DOM文档树的方法去解析CSS选择器。原理就是先找出文档树中匹配最右边的选择器的元素，再去匹配它的祖先元素是否满足左侧的CSS选择器：\n\n    function find(selector, root) {\n      root  = root || document;\n      var parts = selector.split(\" \"),\n          query = parts[0],\n          rest = parts.slice(1).join(\" \"),\n          elems = root.getElementsByTagName(query),\n          results = [];\n      \n      for (var i = 0; i < elems.length; i++) {\n        if (rest) {\n          results = results.concat(find(rest, elems[i]));\n        } else {\n          results.push(elems[i]);\n        }\n      }\n      return results;\n    }\n\n这里通过一个递归，从最底层的DOM元素开始，顺着文档树往上找就能找到所有匹配这个选择器的元素了，十分简单的逻辑。也是因为逻辑简单，所以效率没有从上往下实现的CSS选择器引擎要高，这就看大家的取舍了。\n","htmlText":"<p>一个CSS选择器引擎的核心其实是纯JavaScript实现的这个部分。最主要的功能就是把CSS选择器映射到一系列浏览器原生提供的API（例如<code>getElementById</code>或者<code>getElementsByTagName</code>等）的调用序列，通过这些原生的API去寻找我们想要定位到的元素。</p>\n<p>为什么还需要一个纯JavaScript实现的CSS选择器引擎？</p>\n<ol>\n<li>a因为IE6和IE7不支持原生的CSS选择器、也不支持使用XPath。</li>\n<li>a因为我们的站点可能需要向前兼容这些古董浏览器。</li>\n<li>a因为效率，某些CSS选择器使用原生的API速度更快（例如<code>id</code>选择器）。</li>\n<li>a因为CSS选择器的覆盖率，由于不是所有支持原生CSS选择器的浏览器都支持所有CSS选择器，所以当某个选择器在某个浏览器里面不支持就要退化到纯JavaScript的实现。</li>\n</ol>\n<p>通常我们会从左到右分析一个CSS选择器，然后顺着<code>root</code>往下找，例如以下的选择器：</p>\n<pre><code>div.ninja a span\n</code></pre><p>按照一般的逻辑，我们会找<code>class</code>是<code>ninja</code>的<code>div</code>，在它的子元素中找<code>a</code>，在<code>a</code>的子元素中找<code>span</code>。这里要注意两个问题：</p>\n<ol>\n<li>a返回的结果可能有多个，它们的顺序要跟定义的顺序一致。</li>\n<li>a返回的结果中不能有重复的DOM。</li>\n</ol>\n<p>由于这两个问题，使用从上到下分析DOM文档树的方法可能需要一些额外的工作量，所以就有了从下到上分析DOM文档树的方法去解析CSS选择器。原理就是先找出文档树中匹配最右边的选择器的元素，再去匹配它的祖先元素是否满足左侧的CSS选择器：</p>\n<pre><code>function find(selector, root) {\n  root  = root || document;\n  var parts = selector.split(&quot; &quot;),\n      query = parts[0],\n      rest = parts.slice(1).join(&quot; &quot;),\n      elems = root.getElementsByTagName(query),\n      results = [];\n\n  for (var i = 0; i &lt; elems.length; i++) {\n    if (rest) {\n      results = results.concat(find(rest, elems[i]));\n    } else {\n      results.push(elems[i]);\n    }\n  }\n  return results;\n}\n</code></pre><p>这里通过一个递归，从最底层的DOM元素开始，顺着文档树往上找就能找到所有匹配这个选择器的元素了，十分简单的逻辑。也是因为逻辑简单，所以效率没有从上往下实现的CSS选择器引擎要高，这就看大家的取舍了。</p>\n","summaryMarkdownText":"\n\n\n一个CSS选择器引擎的核心其实是纯JavaScript实现的这个部分。最主要的功能就是把CSS选择器映射到一系列浏览器原生提供的API（例如`getElementById`或者`getElementsByTagName`等）的调用序列，通过这些原生的API去寻找我们想要定位到的元素。\n\n为什么还需要一个纯JavaScript实现的CSS选择器引擎？\n\n1. a因为IE6和IE7不支持原生的CSS选择器、也不支持使用XPath。\n2. a因为我们的站点可能需要向前兼容这些古董浏览器。\n3. a因为效率，某些CSS选择器使用原生的API速度更快（例如`id`选择器）。\n4. a因为CSS选择器的覆盖率，由于不是所有支持原生CSS选择器的浏览器都支持所有CSS选择器，所以当某个选择器在某个浏览器里面不支持就要退化到纯JavaScript的实现。\n\n通常我们会从左到右分析一个CSS选择器，然后顺着`root`往下找，例如以下的选择器：\n\n    div.ninja a span\n\n按照一般的逻辑，我们会找`class`是`ninja`的`div`，在它的子元素中找`a`，在`a`的子元素中找`span`。这里要注意两个问题：\n\n1. a返回的结果可能有多个，它们的顺序要跟定义的顺序一致。\n2. a返回的结果中不能有重复的DOM。\n\n由于这两个问题，使用从上到下分析DOM文档树的方法可能需要一些额外的工作量，所以就有了从下到上分析DOM文档树的方法去解析CSS选择器。原理就是先找出文档树中匹配最右边的选择器的元素，再去匹配它的祖先元素是否满足左侧的CSS选择器：\n\n    function find(selector, root) {\n      root  = root || document;","summaryHtmlText":"<p>一个CSS选择器引擎的核心其实是纯JavaScript实现的这个部分。最主要的功能就是把CSS选择器映射到一系列浏览器原生提供的API（例如<code>getElementById</code>或者<code>getElementsByTagName</code>等）的调用序列，通过这些原生的API去寻找我们想要定位到的元素。</p>\n<p>为什么还需要一个纯JavaScript实现的CSS选择器引擎？</p>\n<ol>\n<li>a因为IE6和IE7不支持原生的CSS选择器、也不支持使用XPath。</li>\n<li>a因为我们的站点可能需要向前兼容这些古董浏览器。</li>\n<li>a因为效率，某些CSS选择器使用原生的API速度更快（例如<code>id</code>选择器）。</li>\n<li>a因为CSS选择器的覆盖率，由于不是所有支持原生CSS选择器的浏览器都支持所有CSS选择器，所以当某个选择器在某个浏览器里面不支持就要退化到纯JavaScript的实现。</li>\n</ol>\n<p>通常我们会从左到右分析一个CSS选择器，然后顺着<code>root</code>往下找，例如以下的选择器：</p>\n<pre><code>div.ninja a span\n</code></pre><p>按照一般的逻辑，我们会找<code>class</code>是<code>ninja</code>的<code>div</code>，在它的子元素中找<code>a</code>，在<code>a</code>的子元素中找<code>span</code>。这里要注意两个问题：</p>\n<ol>\n<li>a返回的结果可能有多个，它们的顺序要跟定义的顺序一致。</li>\n<li>a返回的结果中不能有重复的DOM。</li>\n</ol>\n<p>由于这两个问题，使用从上到下分析DOM文档树的方法可能需要一些额外的工作量，所以就有了从下到上分析DOM文档树的方法去解析CSS选择器。原理就是先找出文档树中匹配最右边的选择器的元素，再去匹配它的祖先元素是否满足左侧的CSS选择器：</p>\n<pre><code>function find(selector, root) {\n  root  = root || document;\n</code></pre>"}