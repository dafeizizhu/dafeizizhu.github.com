{"year":"2013","month":"11","day":"30","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/11/30/hp-walking-the-dom.html","fileName":"hp-walking-the-dom","layout":"post","title":"High Performance JavaScript 读书笔记之 遍历DOM","description":"","tags":["JavaScript"],"markdownText":"\n\n\nDOM提供了多种方式供我们去遍历整个文档。虽然使用哪种方式都可以达到目的，但是有些时候还是需要选出一个效率最高的方式去达到某些性能基线。\n\n我们可以使用`childNodes`去访问一个DOM的所以子元素，这样就可以递归地遍历整个文档中的DOM，下面是一个使用`childNodes`的例子：\n\n    function testChildNodes() {\n      var el = document.getElementById('mydiv'),\n          ch = el.childNodes,\n          len = ch.length,\n          name = '';\n      for (var count = 0; count < len; count++) {\n        name = ch[count].nodeName;\n      }\n      return name;\n    };\n\n我们也可以使用`nextSibling`去访问一个DOM的邻接节点，这样也可以遍历整个文档中的DOM：\n\n    function testNextSibling() {\n      var el = document.getElementById('mydiv'),\n          ch = el.firstChild,\n          name = '';\n      do {\n        name = ch.nodeName;\n      } while (ch = ch.nextSibling);\n      return name;\n    };\n\n这两种方式在现代浏览器中的效率是差不多的，但是在IE上，`nextSibling`要比`childNodes`的效率要高得多。\n\n`childNodes`、`nextSibling`或者`firstChild`等属性是不区分DOM的类型的，也就是说注释和文本节点都会包含在里面。大多数时候我们不会关心这些注释或者文本节点，所以在遍历的过程中我们需要判断元素的类型。基于这种需求，DOM也提供了一些过滤之后的属性，如`children`和`nextElementSibling`等。使用这些属性去遍历DOM，只会遍历到元素节点，不会包括注释和文本。注意，IE6、7、8只支持`children`。\n\n由于`children`等属性已经过滤掉注释和文本，所以其效率通常要比`childNodes`要高哦。\n","htmlText":"<p>DOM提供了多种方式供我们去遍历整个文档。虽然使用哪种方式都可以达到目的，但是有些时候还是需要选出一个效率最高的方式去达到某些性能基线。</p>\n<p>我们可以使用<code>childNodes</code>去访问一个DOM的所以子元素，这样就可以递归地遍历整个文档中的DOM，下面是一个使用<code>childNodes</code>的例子：</p>\n<pre><code>function testChildNodes() {\n  var el = document.getElementById(&#39;mydiv&#39;),\n      ch = el.childNodes,\n      len = ch.length,\n      name = &#39;&#39;;\n  for (var count = 0; count &lt; len; count++) {\n    name = ch[count].nodeName;\n  }\n  return name;\n};\n</code></pre><p>我们也可以使用<code>nextSibling</code>去访问一个DOM的邻接节点，这样也可以遍历整个文档中的DOM：</p>\n<pre><code>function testNextSibling() {\n  var el = document.getElementById(&#39;mydiv&#39;),\n      ch = el.firstChild,\n      name = &#39;&#39;;\n  do {\n    name = ch.nodeName;\n  } while (ch = ch.nextSibling);\n  return name;\n};\n</code></pre><p>这两种方式在现代浏览器中的效率是差不多的，但是在IE上，<code>nextSibling</code>要比<code>childNodes</code>的效率要高得多。</p>\n<p><code>childNodes</code>、<code>nextSibling</code>或者<code>firstChild</code>等属性是不区分DOM的类型的，也就是说注释和文本节点都会包含在里面。大多数时候我们不会关心这些注释或者文本节点，所以在遍历的过程中我们需要判断元素的类型。基于这种需求，DOM也提供了一些过滤之后的属性，如<code>children</code>和<code>nextElementSibling</code>等。使用这些属性去遍历DOM，只会遍历到元素节点，不会包括注释和文本。注意，IE6、7、8只支持<code>children</code>。</p>\n<p>由于<code>children</code>等属性已经过滤掉注释和文本，所以其效率通常要比<code>childNodes</code>要高哦。</p>\n","summaryMarkdownText":"\n\n\nDOM提供了多种方式供我们去遍历整个文档。虽然使用哪种方式都可以达到目的，但是有些时候还是需要选出一个效率最高的方式去达到某些性能基线。\n\n我们可以使用`childNodes`去访问一个DOM的所以子元素，这样就可以递归地遍历整个文档中的DOM，下面是一个使用`childNodes`的例子：\n\n    function testChildNodes() {\n      var el = document.getElementById('mydiv'),\n          ch = el.childNodes,\n          len = ch.length,\n          name = '';\n      for (var count = 0; count < len; count++) {\n        name = ch[count].nodeName;\n      }\n      return name;\n    };\n\n我们也可以使用`nextSibling`去访问一个DOM的邻接节点，这样也可以遍历整个文档中的DOM：\n\n    function testNextSibling() {\n      var el = document.getElementById('mydiv'),\n          ch = el.firstChild,\n          name = '';\n      do {","summaryHtmlText":"<p>DOM提供了多种方式供我们去遍历整个文档。虽然使用哪种方式都可以达到目的，但是有些时候还是需要选出一个效率最高的方式去达到某些性能基线。</p>\n<p>我们可以使用<code>childNodes</code>去访问一个DOM的所以子元素，这样就可以递归地遍历整个文档中的DOM，下面是一个使用<code>childNodes</code>的例子：</p>\n<pre><code>function testChildNodes() {\n  var el = document.getElementById(&#39;mydiv&#39;),\n      ch = el.childNodes,\n      len = ch.length,\n      name = &#39;&#39;;\n  for (var count = 0; count &lt; len; count++) {\n    name = ch[count].nodeName;\n  }\n  return name;\n};\n</code></pre><p>我们也可以使用<code>nextSibling</code>去访问一个DOM的邻接节点，这样也可以遍历整个文档中的DOM：</p>\n<pre><code>function testNextSibling() {\n  var el = document.getElementById(&#39;mydiv&#39;),\n      ch = el.firstChild,\n      name = &#39;&#39;;\n  do {\n</code></pre>"}