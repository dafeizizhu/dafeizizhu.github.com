{"year":"2013","month":"08","day":"01","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/08/01/javascript-typeof.html","fileName":"javascript-typeof","layout":"post","title":"JavaScript typeof操作符","description":"","tags":["JavaScript"],"markdownText":"\n\n\n昨天讨论`instanceof`运算符，其中有一个比较坑的限制是，当使用iframe的时候可能会有意想不到的场景：\n\n    var a = [];\n    alert(a instanceof top.Array); // 当这段代码出现在iframe里面的时候是false\n\n原因很简单，就是`window.Array`跟`top.Array`是两个不同的对象。虽然我们写代码的时候不会像上面那样显式地引用`top.Array`，但是在iframe集成的场景下我们可能会这么调用：\n\n    if (isArray(a)) { ... }\n\n而`isArray`可能会这么写：\n\n    function isArray(a) { return top.isArray(a); }\n\n这样就会出现上述的坑爹问题。今天来讨论另外一个检测JavaScript变量的运算符`typeof`，看它是否能解决以上这个坑爹的问题。\n\n> typeof操作符返回一个字符串，代表一个未估值的操作数(unevaluated operand)的类型。\n\n`typeof`接受一个操作数和一对可选的括号，返回表示该操作数的类型的字符串，操作数可以是字符串、对象、数字甚至是未定义的变量等。\n\n`typeof`运算符能返回以下表示操作数类型的字符串：\n\n1. `undefined`，操作数是未定义的变量或者属性，例如`undefined`，或者`var a = {}; alert(typeof a.foo);`。\n2. `object`，操作数是一个对象，例如`null`、`{}`、正则表达式或者`new String(\"123\")`等。\n3. `boolean`，操作数是一个布尔值，如`true`、`false`或者`Boolean(\"false\")`。\n4. `number`，操作数是一个数字，如`1`、`1.123`或者`Number(\"123\")`等。\n5. `string`，操作数是一个字符串，如`\"123\"`或者`String(\"123\")`等。\n6. `function`，操作数是一个方法，如`function () {}`或者`new Function()`等。\n\n其中一个比较奇怪的是`typeof null === \"object\"`，这个貌似从JavaScript诞生以来就是这样，下面是MDN的解释：\n\n> 在JavaScript最初的实现中,JavaScript中的值是由一个类型标签和一个数值组成的,对象的类型标签是0,由于null代表的是空指针(大多数平台下值为0x00),因此,null的类型标签也成为了0,typeof null就错误的返回了\"object\".(该段文字没有具体的出处,正确性有待考证)\n\n使用`typeof`可以跨iframe判断一个变量是否对象、布尔值、数字、字符串或者方法，这里引用玉伯的代码：\n\n    function isType(type) {\n      return function(obj) {\n        return Object.prototype.toString.call(obj) === \"[object \" + type + \"]\"\n      }\n    }\n    var isObject = isType(\"Object\")\n    var isString = isType(\"String\")\n    var isArray = Array.isArray || isType(\"Array\")\n    var isFunction = isType(\"Function\")\n\n另外，由于当`type`是`undefined`或者`null`的时候，`typeof`操作都不会报错，所以也免去了对输入参数的非空判断的代码，引入闭包还能减少代码数量，快哉！\n","htmlText":"<p>昨天讨论<code>instanceof</code>运算符，其中有一个比较坑的限制是，当使用iframe的时候可能会有意想不到的场景：</p>\n<pre><code>var a = [];\nalert(a instanceof top.Array); // 当这段代码出现在iframe里面的时候是false\n</code></pre><p>原因很简单，就是<code>window.Array</code>跟<code>top.Array</code>是两个不同的对象。虽然我们写代码的时候不会像上面那样显式地引用<code>top.Array</code>，但是在iframe集成的场景下我们可能会这么调用：</p>\n<pre><code>if (isArray(a)) { ... }\n</code></pre><p>而<code>isArray</code>可能会这么写：</p>\n<pre><code>function isArray(a) { return top.isArray(a); }\n</code></pre><p>这样就会出现上述的坑爹问题。今天来讨论另外一个检测JavaScript变量的运算符<code>typeof</code>，看它是否能解决以上这个坑爹的问题。</p>\n<blockquote>\n<p>typeof操作符返回一个字符串，代表一个未估值的操作数(unevaluated operand)的类型。</p>\n</blockquote>\n<p><code>typeof</code>接受一个操作数和一对可选的括号，返回表示该操作数的类型的字符串，操作数可以是字符串、对象、数字甚至是未定义的变量等。</p>\n<p><code>typeof</code>运算符能返回以下表示操作数类型的字符串：</p>\n<ol>\n<li><code>undefined</code>，操作数是未定义的变量或者属性，例如<code>undefined</code>，或者<code>var a = {}; alert(typeof a.foo);</code>。</li>\n<li><code>object</code>，操作数是一个对象，例如<code>null</code>、<code>{}</code>、正则表达式或者<code>new String(&quot;123&quot;)</code>等。</li>\n<li><code>boolean</code>，操作数是一个布尔值，如<code>true</code>、<code>false</code>或者<code>Boolean(&quot;false&quot;)</code>。</li>\n<li><code>number</code>，操作数是一个数字，如<code>1</code>、<code>1.123</code>或者<code>Number(&quot;123&quot;)</code>等。</li>\n<li><code>string</code>，操作数是一个字符串，如<code>&quot;123&quot;</code>或者<code>String(&quot;123&quot;)</code>等。</li>\n<li><code>function</code>，操作数是一个方法，如<code>function () {}</code>或者<code>new Function()</code>等。</li>\n</ol>\n<p>其中一个比较奇怪的是<code>typeof null === &quot;object&quot;</code>，这个貌似从JavaScript诞生以来就是这样，下面是MDN的解释：</p>\n<blockquote>\n<p>在JavaScript最初的实现中,JavaScript中的值是由一个类型标签和一个数值组成的,对象的类型标签是0,由于null代表的是空指针(大多数平台下值为0x00),因此,null的类型标签也成为了0,typeof null就错误的返回了&quot;object&quot;.(该段文字没有具体的出处,正确性有待考证)</p>\n</blockquote>\n<p>使用<code>typeof</code>可以跨iframe判断一个变量是否对象、布尔值、数字、字符串或者方法，这里引用玉伯的代码：</p>\n<pre><code>function isType(type) {\n  return function(obj) {\n    return Object.prototype.toString.call(obj) === &quot;[object &quot; + type + &quot;]&quot;\n  }\n}\nvar isObject = isType(&quot;Object&quot;)\nvar isString = isType(&quot;String&quot;)\nvar isArray = Array.isArray || isType(&quot;Array&quot;)\nvar isFunction = isType(&quot;Function&quot;)\n</code></pre><p>另外，由于当<code>type</code>是<code>undefined</code>或者<code>null</code>的时候，<code>typeof</code>操作都不会报错，所以也免去了对输入参数的非空判断的代码，引入闭包还能减少代码数量，快哉！</p>\n","summaryMarkdownText":"\n\n\n昨天讨论`instanceof`运算符，其中有一个比较坑的限制是，当使用iframe的时候可能会有意想不到的场景：\n\n    var a = [];\n    alert(a instanceof top.Array); // 当这段代码出现在iframe里面的时候是false\n\n原因很简单，就是`window.Array`跟`top.Array`是两个不同的对象。虽然我们写代码的时候不会像上面那样显式地引用`top.Array`，但是在iframe集成的场景下我们可能会这么调用：\n\n    if (isArray(a)) { ... }\n\n而`isArray`可能会这么写：\n\n    function isArray(a) { return top.isArray(a); }\n\n这样就会出现上述的坑爹问题。今天来讨论另外一个检测JavaScript变量的运算符`typeof`，看它是否能解决以上这个坑爹的问题。\n\n> typeof操作符返回一个字符串，代表一个未估值的操作数(unevaluated operand)的类型。\n\n`typeof`接受一个操作数和一对可选的括号，返回表示该操作数的类型的字符串，操作数可以是字符串、对象、数字甚至是未定义的变量等。\n\n`typeof`运算符能返回以下表示操作数类型的字符串：\n\n1. `undefined`，操作数是未定义的变量或者属性，例如`undefined`，或者`var a = {}; alert(typeof a.foo);`。","summaryHtmlText":"<p>昨天讨论<code>instanceof</code>运算符，其中有一个比较坑的限制是，当使用iframe的时候可能会有意想不到的场景：</p>\n<pre><code>var a = [];\nalert(a instanceof top.Array); // 当这段代码出现在iframe里面的时候是false\n</code></pre><p>原因很简单，就是<code>window.Array</code>跟<code>top.Array</code>是两个不同的对象。虽然我们写代码的时候不会像上面那样显式地引用<code>top.Array</code>，但是在iframe集成的场景下我们可能会这么调用：</p>\n<pre><code>if (isArray(a)) { ... }\n</code></pre><p>而<code>isArray</code>可能会这么写：</p>\n<pre><code>function isArray(a) { return top.isArray(a); }\n</code></pre><p>这样就会出现上述的坑爹问题。今天来讨论另外一个检测JavaScript变量的运算符<code>typeof</code>，看它是否能解决以上这个坑爹的问题。</p>\n<blockquote>\n<p>typeof操作符返回一个字符串，代表一个未估值的操作数(unevaluated operand)的类型。</p>\n</blockquote>\n<p><code>typeof</code>接受一个操作数和一对可选的括号，返回表示该操作数的类型的字符串，操作数可以是字符串、对象、数字甚至是未定义的变量等。</p>\n<p><code>typeof</code>运算符能返回以下表示操作数类型的字符串：</p>\n<ol>\n<li><code>undefined</code>，操作数是未定义的变量或者属性，例如<code>undefined</code>，或者<code>var a = {}; alert(typeof a.foo);</code>。</li>\n</ol>\n"}