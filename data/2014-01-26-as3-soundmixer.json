{"year":"2014","month":"01","day":"26","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2014/01/26/as3-soundmixer.html","fileName":"as3-soundmixer","layout":"post","title":"全局声音控制：SoundMixer","description":"","tags":["Flash"],"markdownText":"\n\n\n之前讨论的`MovieClip`实例中的`soundTransform`可以控制这个视频剪辑的声音播放以及声音大小的控制。但不是所有从`Loader`中加载的`swf`都是`MovieClip`实例，例如使用早期Flash创作工具创作的`swf`文件，它并没有`soundTransform`这个属性。这时候，我们只能通过全局声音来控制这个视频剪辑的声音播放。\n\n在AS3中，全局声音控制是通过`SoundMixer`类提供的静态属性和方法来控制的。这个类有两个静态属性：\n\n1. `bufferTime`，表示预加载到缓冲区中所用的秒数。\n2. `soundTransform`，是`SoundTransform`的实例，通过控制这个属性的`volumn`方法就可以控制声音播放的大小。\n\n这个类还提供了几个静态工具方法：\n\n1. `areSoundsInaccessible`，确定是否因安全限制而无法访问任何声音，例如播放的声音所在的服务器没有授权所在域访问的URL策略文件等。\n2. `computeSpectrum`，用来获取当前声音波形的快照。使用获取到的数据可以绘制出当前声音播放的波形。\n3. `stopAll`，停止当前正在播放的声音。默认情况下，只会停止与调用此方法的对象在相同安全沙箱中的声音。注，没有恢复功能，只能调用`Sound`实例的`play`方法恢复声音播放。\n\n由于普通的应用不会出现同时播放两种声音的情况，所以大多数情况下我们可以使用这个全局的声音控制方法为我们的`swf`应用提供静音功能：\n\n    var soundtrans:SoundTransform = new SoundTransform(0, 0);\n    SoundMixer.soundTransform = soundtrans;\n","htmlText":"<p>之前讨论的<code>MovieClip</code>实例中的<code>soundTransform</code>可以控制这个视频剪辑的声音播放以及声音大小的控制。但不是所有从<code>Loader</code>中加载的<code>swf</code>都是<code>MovieClip</code>实例，例如使用早期Flash创作工具创作的<code>swf</code>文件，它并没有<code>soundTransform</code>这个属性。这时候，我们只能通过全局声音来控制这个视频剪辑的声音播放。</p>\n<p>在AS3中，全局声音控制是通过<code>SoundMixer</code>类提供的静态属性和方法来控制的。这个类有两个静态属性：</p>\n<ol>\n<li><code>bufferTime</code>，表示预加载到缓冲区中所用的秒数。</li>\n<li><code>soundTransform</code>，是<code>SoundTransform</code>的实例，通过控制这个属性的<code>volumn</code>方法就可以控制声音播放的大小。</li>\n</ol>\n<p>这个类还提供了几个静态工具方法：</p>\n<ol>\n<li><code>areSoundsInaccessible</code>，确定是否因安全限制而无法访问任何声音，例如播放的声音所在的服务器没有授权所在域访问的URL策略文件等。</li>\n<li><code>computeSpectrum</code>，用来获取当前声音波形的快照。使用获取到的数据可以绘制出当前声音播放的波形。</li>\n<li><code>stopAll</code>，停止当前正在播放的声音。默认情况下，只会停止与调用此方法的对象在相同安全沙箱中的声音。注，没有恢复功能，只能调用<code>Sound</code>实例的<code>play</code>方法恢复声音播放。</li>\n</ol>\n<p>由于普通的应用不会出现同时播放两种声音的情况，所以大多数情况下我们可以使用这个全局的声音控制方法为我们的<code>swf</code>应用提供静音功能：</p>\n<pre><code>var soundtrans:SoundTransform = new SoundTransform(0, 0);\nSoundMixer.soundTransform = soundtrans;\n</code></pre>","summaryMarkdownText":"\n\n\n之前讨论的`MovieClip`实例中的`soundTransform`可以控制这个视频剪辑的声音播放以及声音大小的控制。但不是所有从`Loader`中加载的`swf`都是`MovieClip`实例，例如使用早期Flash创作工具创作的`swf`文件，它并没有`soundTransform`这个属性。这时候，我们只能通过全局声音来控制这个视频剪辑的声音播放。\n\n在AS3中，全局声音控制是通过`SoundMixer`类提供的静态属性和方法来控制的。这个类有两个静态属性：\n\n1. `bufferTime`，表示预加载到缓冲区中所用的秒数。\n2. `soundTransform`，是`SoundTransform`的实例，通过控制这个属性的`volumn`方法就可以控制声音播放的大小。\n\n这个类还提供了几个静态工具方法：\n\n1. `areSoundsInaccessible`，确定是否因安全限制而无法访问任何声音，例如播放的声音所在的服务器没有授权所在域访问的URL策略文件等。\n2. `computeSpectrum`，用来获取当前声音波形的快照。使用获取到的数据可以绘制出当前声音播放的波形。\n3. `stopAll`，停止当前正在播放的声音。默认情况下，只会停止与调用此方法的对象在相同安全沙箱中的声音。注，没有恢复功能，只能调用`Sound`实例的`play`方法恢复声音播放。\n\n由于普通的应用不会出现同时播放两种声音的情况，所以大多数情况下我们可以使用这个全局的声音控制方法为我们的`swf`应用提供静音功能：\n\n    var soundtrans:SoundTransform = new SoundTransform(0, 0);\n    SoundMixer.soundTransform = soundtrans;\n","summaryHtmlText":"<p>之前讨论的<code>MovieClip</code>实例中的<code>soundTransform</code>可以控制这个视频剪辑的声音播放以及声音大小的控制。但不是所有从<code>Loader</code>中加载的<code>swf</code>都是<code>MovieClip</code>实例，例如使用早期Flash创作工具创作的<code>swf</code>文件，它并没有<code>soundTransform</code>这个属性。这时候，我们只能通过全局声音来控制这个视频剪辑的声音播放。</p>\n<p>在AS3中，全局声音控制是通过<code>SoundMixer</code>类提供的静态属性和方法来控制的。这个类有两个静态属性：</p>\n<ol>\n<li><code>bufferTime</code>，表示预加载到缓冲区中所用的秒数。</li>\n<li><code>soundTransform</code>，是<code>SoundTransform</code>的实例，通过控制这个属性的<code>volumn</code>方法就可以控制声音播放的大小。</li>\n</ol>\n<p>这个类还提供了几个静态工具方法：</p>\n<ol>\n<li><code>areSoundsInaccessible</code>，确定是否因安全限制而无法访问任何声音，例如播放的声音所在的服务器没有授权所在域访问的URL策略文件等。</li>\n<li><code>computeSpectrum</code>，用来获取当前声音波形的快照。使用获取到的数据可以绘制出当前声音播放的波形。</li>\n<li><code>stopAll</code>，停止当前正在播放的声音。默认情况下，只会停止与调用此方法的对象在相同安全沙箱中的声音。注，没有恢复功能，只能调用<code>Sound</code>实例的<code>play</code>方法恢复声音播放。</li>\n</ol>\n<p>由于普通的应用不会出现同时播放两种声音的情况，所以大多数情况下我们可以使用这个全局的声音控制方法为我们的<code>swf</code>应用提供静音功能：</p>\n<pre><code>var soundtrans:SoundTransform = new SoundTransform(0, 0);\nSoundMixer.soundTransform = soundtrans;\n</code></pre>"}