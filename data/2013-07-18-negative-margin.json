{"year":"2013","month":"07","day":"18","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/07/18/negative-margin.html","fileName":"negative-margin","layout":"post","title":"神奇的负边距","description":"","tags":["css"],"markdownText":"\n\n\n之前写过一篇[《经典三列布局之如何让中间的列先显示出来》](http://dafeizizhu.github.io/2013/07/08/three-column-layout-middle-first/)，里面讲的就是使用浮动、相对定位和负边距来做的一套布局。写那篇文章的时候还没太搞懂负边距是怎么回事，今天简单分析一下对不同元素（正常、浮动、绝对定位等）的负边距是如何起作用的。\n\n首先明确几点：\n\n1. 负边距是完全合法的CSS写法，W3允许边距的值是负值。\n2. 负边距不属于CSS hack。\n3. a负边距不会使元素脱离文档流。\n4. 所有现代浏览器都支持负边距（IE6也部分支持，太棒了！）。\n\n简单看看负边距的工作原理：\n\n1. 在`top`和`left`方向上应用负边距，该元素会向指定的方向移动，随后的元素也会跟着一起移动。\n2. 在`bottom`和`right`方向上应用负边距，该元素的位置不会发生任何移动，但是随后的元素会挤压过来，看上去的效果就是该元素占的空间变小了。\n3. 当该元素没有应用宽度（`width: auto`也算），为该元素设置`left`和`right`方向上的负边距会让元素的宽度边大。\n\n负边距有什么用呢？其中最重要的一个作用我认为是把DOM树中较后出现的元素显示在页面较前的位置。我们知道HTML解析DOM树的时候是根据书写的顺序解析的。而文档的解析顺序是从上到下，从左到右（当然方向是`ltr`）的，那么正常书写的N列布局肯定是第一列写在最前边，但是可能我们需要中间第n列先解析，这时候就要把第n列的内容书写在前边，通过负边距调整位置，达到理想的效果。\n\n现在分析一下之前写过的那篇文章中，左列的CSS究竟是如何达到最后的效果的。现来看看左列的CSS代码。\n\n    #left {\n        position: relative; // 1\n        left: -100px;       // 2\n        float: left;        // 3\n        margin-left: -100%; // 4   \n    }\n\n这个元素分别使用了浮动、相对定位和负边距三种方式进行布局。现在按负边距、浮动、相对定位的顺序加上CSS，效果为：\n\n1. 加上负边距，该元素向左移动，移动的距离跟父元素的宽度一致。注意，这里的宽度是指**内容宽度**，即不算`padding`、`border`和`margin`的宽度。\n2. 加上浮动，该元素与`middle`两个元素都变成浮动元素，负边距使得该元素沿着浮动方向位移了父元素的宽度，效果是该元素的左边界与`middle`的左边界重合。\n3. 最后加上相对定位，让该元素相对于其现有位置再向左移动与其宽度相等的距离。最后的效果就是该元素移动到`middle`元素的左侧。\n\n利用负边距，还能做出很多有趣的效果，例如一些层叠效果，如标签页、印章等。与其他CSS样式结合起来更是有趣。\n\n今天在工作中也利用了之前写的三列布局的知识。用心沉淀，再返回到实践中，这种感觉真好。\n","htmlText":"<p>之前写过一篇<a href=\"http://dafeizizhu.github.io/2013/07/08/three-column-layout-middle-first/\">《经典三列布局之如何让中间的列先显示出来》</a>，里面讲的就是使用浮动、相对定位和负边距来做的一套布局。写那篇文章的时候还没太搞懂负边距是怎么回事，今天简单分析一下对不同元素（正常、浮动、绝对定位等）的负边距是如何起作用的。</p>\n<p>首先明确几点：</p>\n<ol>\n<li>负边距是完全合法的CSS写法，W3允许边距的值是负值。</li>\n<li>负边距不属于CSS hack。</li>\n<li>a负边距不会使元素脱离文档流。</li>\n<li>所有现代浏览器都支持负边距（IE6也部分支持，太棒了！）。</li>\n</ol>\n<p>简单看看负边距的工作原理：</p>\n<ol>\n<li>在<code>top</code>和<code>left</code>方向上应用负边距，该元素会向指定的方向移动，随后的元素也会跟着一起移动。</li>\n<li>在<code>bottom</code>和<code>right</code>方向上应用负边距，该元素的位置不会发生任何移动，但是随后的元素会挤压过来，看上去的效果就是该元素占的空间变小了。</li>\n<li>当该元素没有应用宽度（<code>width: auto</code>也算），为该元素设置<code>left</code>和<code>right</code>方向上的负边距会让元素的宽度边大。</li>\n</ol>\n<p>负边距有什么用呢？其中最重要的一个作用我认为是把DOM树中较后出现的元素显示在页面较前的位置。我们知道HTML解析DOM树的时候是根据书写的顺序解析的。而文档的解析顺序是从上到下，从左到右（当然方向是<code>ltr</code>）的，那么正常书写的N列布局肯定是第一列写在最前边，但是可能我们需要中间第n列先解析，这时候就要把第n列的内容书写在前边，通过负边距调整位置，达到理想的效果。</p>\n<p>现在分析一下之前写过的那篇文章中，左列的CSS究竟是如何达到最后的效果的。现来看看左列的CSS代码。</p>\n<pre><code>#left {\n    position: relative; // 1\n    left: -100px;       // 2\n    float: left;        // 3\n    margin-left: -100%; // 4   \n}\n</code></pre><p>这个元素分别使用了浮动、相对定位和负边距三种方式进行布局。现在按负边距、浮动、相对定位的顺序加上CSS，效果为：</p>\n<ol>\n<li>加上负边距，该元素向左移动，移动的距离跟父元素的宽度一致。注意，这里的宽度是指<strong>内容宽度</strong>，即不算<code>padding</code>、<code>border</code>和<code>margin</code>的宽度。</li>\n<li>加上浮动，该元素与<code>middle</code>两个元素都变成浮动元素，负边距使得该元素沿着浮动方向位移了父元素的宽度，效果是该元素的左边界与<code>middle</code>的左边界重合。</li>\n<li>最后加上相对定位，让该元素相对于其现有位置再向左移动与其宽度相等的距离。最后的效果就是该元素移动到<code>middle</code>元素的左侧。</li>\n</ol>\n<p>利用负边距，还能做出很多有趣的效果，例如一些层叠效果，如标签页、印章等。与其他CSS样式结合起来更是有趣。</p>\n<p>今天在工作中也利用了之前写的三列布局的知识。用心沉淀，再返回到实践中，这种感觉真好。</p>\n","summaryMarkdownText":"\n\n\n之前写过一篇[《经典三列布局之如何让中间的列先显示出来》](http://dafeizizhu.github.io/2013/07/08/three-column-layout-middle-first/)，里面讲的就是使用浮动、相对定位和负边距来做的一套布局。写那篇文章的时候还没太搞懂负边距是怎么回事，今天简单分析一下对不同元素（正常、浮动、绝对定位等）的负边距是如何起作用的。\n\n首先明确几点：\n\n1. 负边距是完全合法的CSS写法，W3允许边距的值是负值。\n2. 负边距不属于CSS hack。\n3. a负边距不会使元素脱离文档流。\n4. 所有现代浏览器都支持负边距（IE6也部分支持，太棒了！）。\n\n简单看看负边距的工作原理：\n\n1. 在`top`和`left`方向上应用负边距，该元素会向指定的方向移动，随后的元素也会跟着一起移动。\n2. 在`bottom`和`right`方向上应用负边距，该元素的位置不会发生任何移动，但是随后的元素会挤压过来，看上去的效果就是该元素占的空间变小了。\n3. 当该元素没有应用宽度（`width: auto`也算），为该元素设置`left`和`right`方向上的负边距会让元素的宽度边大。\n\n负边距有什么用呢？其中最重要的一个作用我认为是把DOM树中较后出现的元素显示在页面较前的位置。我们知道HTML解析DOM树的时候是根据书写的顺序解析的。而文档的解析顺序是从上到下，从左到右（当然方向是`ltr`）的，那么正常书写的N列布局肯定是第一列写在最前边，但是可能我们需要中间第n列先解析，这时候就要把第n列的内容书写在前边，通过负边距调整位置，达到理想的效果。\n\n现在分析一下之前写过的那篇文章中，左列的CSS究竟是如何达到最后的效果的。现来看看左列的CSS代码。\n\n    #left {\n        position: relative; // 1\n        left: -100px;       // 2","summaryHtmlText":"<p>之前写过一篇<a href=\"http://dafeizizhu.github.io/2013/07/08/three-column-layout-middle-first/\">《经典三列布局之如何让中间的列先显示出来》</a>，里面讲的就是使用浮动、相对定位和负边距来做的一套布局。写那篇文章的时候还没太搞懂负边距是怎么回事，今天简单分析一下对不同元素（正常、浮动、绝对定位等）的负边距是如何起作用的。</p>\n<p>首先明确几点：</p>\n<ol>\n<li>负边距是完全合法的CSS写法，W3允许边距的值是负值。</li>\n<li>负边距不属于CSS hack。</li>\n<li>a负边距不会使元素脱离文档流。</li>\n<li>所有现代浏览器都支持负边距（IE6也部分支持，太棒了！）。</li>\n</ol>\n<p>简单看看负边距的工作原理：</p>\n<ol>\n<li>在<code>top</code>和<code>left</code>方向上应用负边距，该元素会向指定的方向移动，随后的元素也会跟着一起移动。</li>\n<li>在<code>bottom</code>和<code>right</code>方向上应用负边距，该元素的位置不会发生任何移动，但是随后的元素会挤压过来，看上去的效果就是该元素占的空间变小了。</li>\n<li>当该元素没有应用宽度（<code>width: auto</code>也算），为该元素设置<code>left</code>和<code>right</code>方向上的负边距会让元素的宽度边大。</li>\n</ol>\n<p>负边距有什么用呢？其中最重要的一个作用我认为是把DOM树中较后出现的元素显示在页面较前的位置。我们知道HTML解析DOM树的时候是根据书写的顺序解析的。而文档的解析顺序是从上到下，从左到右（当然方向是<code>ltr</code>）的，那么正常书写的N列布局肯定是第一列写在最前边，但是可能我们需要中间第n列先解析，这时候就要把第n列的内容书写在前边，通过负边距调整位置，达到理想的效果。</p>\n<p>现在分析一下之前写过的那篇文章中，左列的CSS究竟是如何达到最后的效果的。现来看看左列的CSS代码。</p>\n<pre><code>#left {\n    position: relative; // 1\n    left: -100px;       // 2\n</code></pre>"}