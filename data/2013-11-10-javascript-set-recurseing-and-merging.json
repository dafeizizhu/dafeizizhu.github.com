{"year":"2013","month":"11","day":"10","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/11/10/javascript-set-recurseing-and-merging.html","fileName":"javascript-set-recurseing-and-merging","layout":"post","title":"Secrets of the JavaScript Ninja 读书笔记之 递归与合并","description":"","tags":["JavaScript"],"markdownText":"\n\n\nCSS选择器引擎需要递归访问元素及其子孙元素，然后合并多个匹配的结果，返回完整的结果。但是我们需要保证这个结果的结合里面没有重复的元素。由于调用类似`getElementsByTagName`这样的API，如果在子孙元素上调用的时候会返回相同的结果，例如：\n\n    <div id=\"outer\">Outer\n      <div id=\"middle\">Middle\n        <div id=\"inner\">Inner</div>\n      </div>\n    </div>\n\n如果这么调用：\n\n    document.getElementById(\"outer\").getElementsByTagName(\"div\"); // middle and inner\n    document.getElementById(\"middle\").getElementsByTagName(\"div\"); // inner\n\n可以看到两个都返回了`inner`，这样的重复明显是不必要的，所以我们需要一些额外的机制去判断这个元素是否已经存在在集合当中了：\n\n    this.unique = function(array) {\n      var ret = [];\n      run++;\n      for (var i = 0, length = array.length; i < length; i++) {\n        var elem = array[i];\n        if (elem.uniqueID !== run) {\n          elem.uniqueID = run;\n          ret.push(array[i]);\n        }\n      }\n      return ret;\n    }\n\n其中`run`是一个计数器，生成全局唯一的标识。使用这个方法可以从集合中过滤出重复的元素，返回的集合里面就没有重复的元素了。\n","htmlText":"<p>CSS选择器引擎需要递归访问元素及其子孙元素，然后合并多个匹配的结果，返回完整的结果。但是我们需要保证这个结果的结合里面没有重复的元素。由于调用类似<code>getElementsByTagName</code>这样的API，如果在子孙元素上调用的时候会返回相同的结果，例如：</p>\n<pre><code>&lt;div id=&quot;outer&quot;&gt;Outer\n  &lt;div id=&quot;middle&quot;&gt;Middle\n    &lt;div id=&quot;inner&quot;&gt;Inner&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>如果这么调用：</p>\n<pre><code>document.getElementById(&quot;outer&quot;).getElementsByTagName(&quot;div&quot;); // middle and inner\ndocument.getElementById(&quot;middle&quot;).getElementsByTagName(&quot;div&quot;); // inner\n</code></pre><p>可以看到两个都返回了<code>inner</code>，这样的重复明显是不必要的，所以我们需要一些额外的机制去判断这个元素是否已经存在在集合当中了：</p>\n<pre><code>this.unique = function(array) {\n  var ret = [];\n  run++;\n  for (var i = 0, length = array.length; i &lt; length; i++) {\n    var elem = array[i];\n    if (elem.uniqueID !== run) {\n      elem.uniqueID = run;\n      ret.push(array[i]);\n    }\n  }\n  return ret;\n}\n</code></pre><p>其中<code>run</code>是一个计数器，生成全局唯一的标识。使用这个方法可以从集合中过滤出重复的元素，返回的集合里面就没有重复的元素了。</p>\n","summaryMarkdownText":"\n\n\nCSS选择器引擎需要递归访问元素及其子孙元素，然后合并多个匹配的结果，返回完整的结果。但是我们需要保证这个结果的结合里面没有重复的元素。由于调用类似`getElementsByTagName`这样的API，如果在子孙元素上调用的时候会返回相同的结果，例如：\n\n    <div id=\"outer\">Outer\n      <div id=\"middle\">Middle\n        <div id=\"inner\">Inner</div>\n      </div>\n    </div>\n\n如果这么调用：\n\n    document.getElementById(\"outer\").getElementsByTagName(\"div\"); // middle and inner\n    document.getElementById(\"middle\").getElementsByTagName(\"div\"); // inner\n\n可以看到两个都返回了`inner`，这样的重复明显是不必要的，所以我们需要一些额外的机制去判断这个元素是否已经存在在集合当中了：\n\n    this.unique = function(array) {\n      var ret = [];\n      run++;\n      for (var i = 0, length = array.length; i < length; i++) {\n        var elem = array[i];\n        if (elem.uniqueID !== run) {\n          elem.uniqueID = run;","summaryHtmlText":"<p>CSS选择器引擎需要递归访问元素及其子孙元素，然后合并多个匹配的结果，返回完整的结果。但是我们需要保证这个结果的结合里面没有重复的元素。由于调用类似<code>getElementsByTagName</code>这样的API，如果在子孙元素上调用的时候会返回相同的结果，例如：</p>\n<pre><code>&lt;div id=&quot;outer&quot;&gt;Outer\n  &lt;div id=&quot;middle&quot;&gt;Middle\n    &lt;div id=&quot;inner&quot;&gt;Inner&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>如果这么调用：</p>\n<pre><code>document.getElementById(&quot;outer&quot;).getElementsByTagName(&quot;div&quot;); // middle and inner\ndocument.getElementById(&quot;middle&quot;).getElementsByTagName(&quot;div&quot;); // inner\n</code></pre><p>可以看到两个都返回了<code>inner</code>，这样的重复明显是不必要的，所以我们需要一些额外的机制去判断这个元素是否已经存在在集合当中了：</p>\n<pre><code>this.unique = function(array) {\n  var ret = [];\n  run++;\n  for (var i = 0, length = array.length; i &lt; length; i++) {\n    var elem = array[i];\n    if (elem.uniqueID !== run) {\n      elem.uniqueID = run;\n</code></pre>"}