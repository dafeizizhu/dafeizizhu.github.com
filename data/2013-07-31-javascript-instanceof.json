{"year":"2013","month":"07","day":"31","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/07/31/javascript-instanceof.html","fileName":"javascript-instanceof","layout":"post","title":"JavaScript instanceof操作符","description":"","tags":["JavaScript"],"markdownText":"\n\n\nJavaScript中的`instanceof`操作符通常是用来判断一个对象是否具体“类型”的“实例”，比较常见的用法是：\n\n    if (obj instanceof Array) { ... }\n\n大家有没有想过这个`instanceof`操作符是怎么判断一个对象是否一个“类型”的实例呢？\n\n> instanceof运算符可以用来判断某个构造函数的prototype属性是否存在另外一个要检测对象的原型链上。\n\n通常来说，一个`obj instanceof c`中，会比较`obj`的`__proto__`是否存在于`c`的原型链上。在[JavaScript instanceof 运算符深入剖析](http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/)中有一段JavaScript代码模拟了`instanceof`的执行过程：\n    \t\t\t\t\n    function instance_of(L, R) {//L 表示左表达式，R 表示右表达式\n      var O = R.prototype;// 取 R 的显示原型\n      L = L.__proto__;// 取 L 的隐式原型\n      while (true) { \n        if (L === null) \n          return false; \n        if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true \n          return true; \n        L = L.__proto__; \n      } \n    } \n\n注意哦，同一个对象对同一个构造函数作`instanceof`运算的结果不是一成不变的。构造函数的原型链是可以发生改变的，例如：\n\n    function A () {}\n    function B () {}\n    function C () {}\n    B.prototype = new A();\n    var b = new B();\n    alert(b instanceof B); // true\n    B.prototype = new C();\n    alert(b instanceof B); // false\n    alert(b instanceof A); // true!\n\n例子[参考这里](http://jsfiddle.net/Lzsba/3/)。由于`B`的原型链发生变化，令后一个`instanceof`的结果发生变化。奇怪的是为什么最后一个`instanceof`还是返回的`true`？原因是在实例化的时候，`b`的原型链指向的是一个`A`的实例，即使后面`B`的原型指向另一个对象，也不影响已经实例化的`b`原型链上的对象，所以沿着`b`的原型链还是可以找到`A`。而改变原型链可以影响到已经实例化的对象的前提是**往原型对象上附加属性或者更改已有的属性，而不能把原型对象的引用指向一个新的对象**。\n\n即使修改`b`的`constructor`属性，也不能改变`instanceof`的结果，如以下代码：\n\n    b.constructor = C;\n    alert(b instanceof C); // still false\n\n这应该说明了在进行`instanceof`计算的时候，即使手工改变一个对象上的`constructor`或者`__proto__`不会影响`instanceof`的结果。详细的例子[参考这里](http://jsfiddle.net/vkk8L/)。\n","htmlText":"<p>JavaScript中的<code>instanceof</code>操作符通常是用来判断一个对象是否具体“类型”的“实例”，比较常见的用法是：</p>\n<pre><code>if (obj instanceof Array) { ... }\n</code></pre><p>大家有没有想过这个<code>instanceof</code>操作符是怎么判断一个对象是否一个“类型”的实例呢？</p>\n<blockquote>\n<p>instanceof运算符可以用来判断某个构造函数的prototype属性是否存在另外一个要检测对象的原型链上。</p>\n</blockquote>\n<p>通常来说，一个<code>obj instanceof c</code>中，会比较<code>obj</code>的<code>__proto__</code>是否存在于<code>c</code>的原型链上。在<a href=\"http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/\">JavaScript instanceof 运算符深入剖析</a>中有一段JavaScript代码模拟了<code>instanceof</code>的执行过程：</p>\n<pre><code>function instance_of(L, R) {//L 表示左表达式，R 表示右表达式\n  var O = R.prototype;// 取 R 的显示原型\n  L = L.__proto__;// 取 L 的隐式原型\n  while (true) { \n    if (L === null) \n      return false; \n    if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true \n      return true; \n    L = L.__proto__; \n  } \n} \n</code></pre><p>注意哦，同一个对象对同一个构造函数作<code>instanceof</code>运算的结果不是一成不变的。构造函数的原型链是可以发生改变的，例如：</p>\n<pre><code>function A () {}\nfunction B () {}\nfunction C () {}\nB.prototype = new A();\nvar b = new B();\nalert(b instanceof B); // true\nB.prototype = new C();\nalert(b instanceof B); // false\nalert(b instanceof A); // true!\n</code></pre><p>例子<a href=\"http://jsfiddle.net/Lzsba/3/\">参考这里</a>。由于<code>B</code>的原型链发生变化，令后一个<code>instanceof</code>的结果发生变化。奇怪的是为什么最后一个<code>instanceof</code>还是返回的<code>true</code>？原因是在实例化的时候，<code>b</code>的原型链指向的是一个<code>A</code>的实例，即使后面<code>B</code>的原型指向另一个对象，也不影响已经实例化的<code>b</code>原型链上的对象，所以沿着<code>b</code>的原型链还是可以找到<code>A</code>。而改变原型链可以影响到已经实例化的对象的前提是<strong>往原型对象上附加属性或者更改已有的属性，而不能把原型对象的引用指向一个新的对象</strong>。</p>\n<p>即使修改<code>b</code>的<code>constructor</code>属性，也不能改变<code>instanceof</code>的结果，如以下代码：</p>\n<pre><code>b.constructor = C;\nalert(b instanceof C); // still false\n</code></pre><p>这应该说明了在进行<code>instanceof</code>计算的时候，即使手工改变一个对象上的<code>constructor</code>或者<code>__proto__</code>不会影响<code>instanceof</code>的结果。详细的例子<a href=\"http://jsfiddle.net/vkk8L/\">参考这里</a>。</p>\n","summaryMarkdownText":"\n\n\nJavaScript中的`instanceof`操作符通常是用来判断一个对象是否具体“类型”的“实例”，比较常见的用法是：\n\n    if (obj instanceof Array) { ... }\n\n大家有没有想过这个`instanceof`操作符是怎么判断一个对象是否一个“类型”的实例呢？\n\n> instanceof运算符可以用来判断某个构造函数的prototype属性是否存在另外一个要检测对象的原型链上。\n\n通常来说，一个`obj instanceof c`中，会比较`obj`的`__proto__`是否存在于`c`的原型链上。在[JavaScript instanceof 运算符深入剖析](http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/)中有一段JavaScript代码模拟了`instanceof`的执行过程：\n    \t\t\t\t\n    function instance_of(L, R) {//L 表示左表达式，R 表示右表达式\n      var O = R.prototype;// 取 R 的显示原型\n      L = L.__proto__;// 取 L 的隐式原型\n      while (true) { \n        if (L === null) \n          return false; \n        if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true \n          return true; \n        L = L.__proto__; \n      } \n    } \n","summaryHtmlText":"<p>JavaScript中的<code>instanceof</code>操作符通常是用来判断一个对象是否具体“类型”的“实例”，比较常见的用法是：</p>\n<pre><code>if (obj instanceof Array) { ... }\n</code></pre><p>大家有没有想过这个<code>instanceof</code>操作符是怎么判断一个对象是否一个“类型”的实例呢？</p>\n<blockquote>\n<p>instanceof运算符可以用来判断某个构造函数的prototype属性是否存在另外一个要检测对象的原型链上。</p>\n</blockquote>\n<p>通常来说，一个<code>obj instanceof c</code>中，会比较<code>obj</code>的<code>__proto__</code>是否存在于<code>c</code>的原型链上。在<a href=\"http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/\">JavaScript instanceof 运算符深入剖析</a>中有一段JavaScript代码模拟了<code>instanceof</code>的执行过程：</p>\n<pre><code>function instance_of(L, R) {//L 表示左表达式，R 表示右表达式\n  var O = R.prototype;// 取 R 的显示原型\n  L = L.__proto__;// 取 L 的隐式原型\n  while (true) { \n    if (L === null) \n      return false; \n    if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true \n      return true; \n    L = L.__proto__; \n  } \n} \n</code></pre>"}