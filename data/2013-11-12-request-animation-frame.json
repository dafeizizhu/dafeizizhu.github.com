{"year":"2013","month":"11","day":"12","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/11/12/request-animation-frame.html","fileName":"request-animation-frame","layout":"post","title":"window.requestAnimationFrame","description":"","tags":["JavaScript"],"markdownText":"\n\n\n基于脚本的动画，我们通常会使用`setTimeout`或者`setInterval`去做：\n\n    setInterval(step, interval);\n\n但是有没有想过当中的`interval`要设置多少才合适呢？为了动画的流畅，我们可能会把这个时间设置成尽可能的小，例如`10`。这样，动画就会每10毫秒绘制一祯。但是，由于显示的时候还是有一个频率的（例如60HZ），过小的时间间隔会造成某些祯处于显示的间隔时间，这样这些祯就显示不出来。而且设置这么小的时间间隔也会加大浏览器对CPU的消耗。\n\n这时候，可以使用`window.requestAnimationFrame`来替代以前基于`setTimeout`的实现：\n\n> The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint.\n\n这个方法告诉浏览器现在需要为一个动画重绘一祯，浏览器会自行计算调用的时间，调用传入的回调函数。回调函数的单位时间调用次数跟显示设备的刷新频率有关，不过不用担心，这些东西浏览器都会帮我们算好的。回调函数接受一个参数，就是这次调用的时间间隔。调用这个方法之后跟`setTimeout`一样，会返回一个`id`，调用`window.cancelAnimationFrame`也可以终止下一个回调函数的执行，跟`clearTimeout`是一致的。\n\n很可惜，`window.requestAnimationFrame`不是所有IE都支持，只有IE10才支持这个方法。但是由于这个方法的调用方式跟`setTimeout`是一致的，我们其实可以比较方便地在IE上做一个退化方案：\n\n    function reqAnimationFrame(callback) {\n      if (typeof requestAnimationFrame == \"function\") {\n        return requestAnimationFrame(callback);\n      } else {\n        return setTimeout(callback, 60); // Default interval\n      }\n    }\n    function cancel(id) {\n      if (typeof requestAnimationFrame == \"function\") {\n        cancelAnimationFrame(id);\n      } else {\n        clearTimeout(id);\n    }\n\n在不支持`requestAnimationFrame`的实现中需要一个默认的时间间隔，基本能满足需求。以后要做动画，记得要使用这个API哦亲！\n","htmlText":"<p>基于脚本的动画，我们通常会使用<code>setTimeout</code>或者<code>setInterval</code>去做：</p>\n<pre><code>setInterval(step, interval);\n</code></pre><p>但是有没有想过当中的<code>interval</code>要设置多少才合适呢？为了动画的流畅，我们可能会把这个时间设置成尽可能的小，例如<code>10</code>。这样，动画就会每10毫秒绘制一祯。但是，由于显示的时候还是有一个频率的（例如60HZ），过小的时间间隔会造成某些祯处于显示的间隔时间，这样这些祯就显示不出来。而且设置这么小的时间间隔也会加大浏览器对CPU的消耗。</p>\n<p>这时候，可以使用<code>window.requestAnimationFrame</code>来替代以前基于<code>setTimeout</code>的实现：</p>\n<blockquote>\n<p>The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint.</p>\n</blockquote>\n<p>这个方法告诉浏览器现在需要为一个动画重绘一祯，浏览器会自行计算调用的时间，调用传入的回调函数。回调函数的单位时间调用次数跟显示设备的刷新频率有关，不过不用担心，这些东西浏览器都会帮我们算好的。回调函数接受一个参数，就是这次调用的时间间隔。调用这个方法之后跟<code>setTimeout</code>一样，会返回一个<code>id</code>，调用<code>window.cancelAnimationFrame</code>也可以终止下一个回调函数的执行，跟<code>clearTimeout</code>是一致的。</p>\n<p>很可惜，<code>window.requestAnimationFrame</code>不是所有IE都支持，只有IE10才支持这个方法。但是由于这个方法的调用方式跟<code>setTimeout</code>是一致的，我们其实可以比较方便地在IE上做一个退化方案：</p>\n<pre><code>function reqAnimationFrame(callback) {\n  if (typeof requestAnimationFrame == &quot;function&quot;) {\n    return requestAnimationFrame(callback);\n  } else {\n    return setTimeout(callback, 60); // Default interval\n  }\n}\nfunction cancel(id) {\n  if (typeof requestAnimationFrame == &quot;function&quot;) {\n    cancelAnimationFrame(id);\n  } else {\n    clearTimeout(id);\n}\n</code></pre><p>在不支持<code>requestAnimationFrame</code>的实现中需要一个默认的时间间隔，基本能满足需求。以后要做动画，记得要使用这个API哦亲！</p>\n","summaryMarkdownText":"\n\n\n基于脚本的动画，我们通常会使用`setTimeout`或者`setInterval`去做：\n\n    setInterval(step, interval);\n\n但是有没有想过当中的`interval`要设置多少才合适呢？为了动画的流畅，我们可能会把这个时间设置成尽可能的小，例如`10`。这样，动画就会每10毫秒绘制一祯。但是，由于显示的时候还是有一个频率的（例如60HZ），过小的时间间隔会造成某些祯处于显示的间隔时间，这样这些祯就显示不出来。而且设置这么小的时间间隔也会加大浏览器对CPU的消耗。\n\n这时候，可以使用`window.requestAnimationFrame`来替代以前基于`setTimeout`的实现：\n\n> The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint.\n\n这个方法告诉浏览器现在需要为一个动画重绘一祯，浏览器会自行计算调用的时间，调用传入的回调函数。回调函数的单位时间调用次数跟显示设备的刷新频率有关，不过不用担心，这些东西浏览器都会帮我们算好的。回调函数接受一个参数，就是这次调用的时间间隔。调用这个方法之后跟`setTimeout`一样，会返回一个`id`，调用`window.cancelAnimationFrame`也可以终止下一个回调函数的执行，跟`clearTimeout`是一致的。\n\n很可惜，`window.requestAnimationFrame`不是所有IE都支持，只有IE10才支持这个方法。但是由于这个方法的调用方式跟`setTimeout`是一致的，我们其实可以比较方便地在IE上做一个退化方案：\n\n    function reqAnimationFrame(callback) {\n      if (typeof requestAnimationFrame == \"function\") {\n        return requestAnimationFrame(callback);\n      } else {\n        return setTimeout(callback, 60); // Default interval\n      }\n    }\n    function cancel(id) {","summaryHtmlText":"<p>基于脚本的动画，我们通常会使用<code>setTimeout</code>或者<code>setInterval</code>去做：</p>\n<pre><code>setInterval(step, interval);\n</code></pre><p>但是有没有想过当中的<code>interval</code>要设置多少才合适呢？为了动画的流畅，我们可能会把这个时间设置成尽可能的小，例如<code>10</code>。这样，动画就会每10毫秒绘制一祯。但是，由于显示的时候还是有一个频率的（例如60HZ），过小的时间间隔会造成某些祯处于显示的间隔时间，这样这些祯就显示不出来。而且设置这么小的时间间隔也会加大浏览器对CPU的消耗。</p>\n<p>这时候，可以使用<code>window.requestAnimationFrame</code>来替代以前基于<code>setTimeout</code>的实现：</p>\n<blockquote>\n<p>The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint.</p>\n</blockquote>\n<p>这个方法告诉浏览器现在需要为一个动画重绘一祯，浏览器会自行计算调用的时间，调用传入的回调函数。回调函数的单位时间调用次数跟显示设备的刷新频率有关，不过不用担心，这些东西浏览器都会帮我们算好的。回调函数接受一个参数，就是这次调用的时间间隔。调用这个方法之后跟<code>setTimeout</code>一样，会返回一个<code>id</code>，调用<code>window.cancelAnimationFrame</code>也可以终止下一个回调函数的执行，跟<code>clearTimeout</code>是一致的。</p>\n<p>很可惜，<code>window.requestAnimationFrame</code>不是所有IE都支持，只有IE10才支持这个方法。但是由于这个方法的调用方式跟<code>setTimeout</code>是一致的，我们其实可以比较方便地在IE上做一个退化方案：</p>\n<pre><code>function reqAnimationFrame(callback) {\n  if (typeof requestAnimationFrame == &quot;function&quot;) {\n    return requestAnimationFrame(callback);\n  } else {\n    return setTimeout(callback, 60); // Default interval\n  }\n}\nfunction cancel(id) {\n</code></pre>"}