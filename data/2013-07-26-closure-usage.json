{"year":"2013","month":"07","day":"26","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/07/26/closure-usage.html","fileName":"closure-usage","layout":"post","title":"Secrets of the JavaScript Ninja 读书笔记之 闭包（一）","description":"","tags":["JavaScript"],"markdownText":"\n\n\n又到读书笔记的时候了！闭包，是JavaScript的重要特性之一，这里不聊什么是闭包，这篇文章主要关注闭包的作用。\n\n### 绑定函数的执行上下文\n\n我们知道，为一个DOM元素绑定事件，无论使用原生的`addEventListener`或者jQuery的`on`，事件处理程序里面的上下文`this`都是DOM元素本身。如果把一个对象的方法作为事件处理程序绑定到DOM元素的某个事件上，而这个方法又使用了`this`引用这个对象的其他方法，这样触发事件执行处理程序的时候必然会出错。所以我们需要手动把事件处理程序的执行上下文`this`改变成这个对象本身，如：\n\n    if (!Function.prototype.bind) {\n      Function.prototype.bind = function (context){\n        var fn = this;\n        return function(){                                \n          return fn.apply(context,arguments);  \n        };                                                \n      }\n    ｝\n\n这里我作了一些小改动，在JavaScript 1.8.5中，`bind`已经是`Function`原型的方法了。通过闭包把原来的方法记录下来，在返回的匿名函数中调用原来方法的`apply`改变执行上下文`this`指向的对象，这样就可以手动地改变事件处理程序中的`this`。\n\n我个人更偏好于使用jQuery的`proxy`方法来做这个事情，如：\n\n    $(\"#id\").on(\"click\", $.proxy(obj.func, obj));\n\n保持对象（或者“类”的“实例”）方法中`this`的指向永远是该对象本身，对于面向对象的JavaScript来说我认为是十分必要的，可以增加一个“类”中代码的可读性与可维护性。\n\n### 柯里化\n\n柯里化就是把一个函数的某些参数预置好，返回一个新的函数，接受没有预置的参数。实现的方式有很多种，如果不通过闭包可以将函数进行二次封装而产生新的函数。纯粹地预置参数，这样做未免有些冗余，如果使用闭包，只需要调用某个`curry`函数，传入预置的参数，就可以返回一个新的函数了。这里分享一个比较有意思的实现，它能预置一个函数中任意位置的参数：\n\n    Function.prototype.partial = function() {\n      var fn = this, args = Array.prototype.slice.call(arguments);\n      return function() {\n        var arg = 0;\n        for (var i = 0; i < args.length && arg < arguments.length; i++) {\n          if (args[i] === undefined) {\n            args[i] = arguments[arg++];\n          }\n        }\n        return fn.apply(this, args);\n      };\n    };\n\n通过柯里化过程中传入`undefined`的位置，预留给结果函数来传入非预置的参数。传给结果函数的参数会像填坑一样把那些之前标识为`undefined`的参数填充起来。\n\n今天就先到这里，闭包的作用还有很多很多，明天继续！\n","htmlText":"<p>又到读书笔记的时候了！闭包，是JavaScript的重要特性之一，这里不聊什么是闭包，这篇文章主要关注闭包的作用。</p>\n<h3 id=\"-\">绑定函数的执行上下文</h3>\n<p>我们知道，为一个DOM元素绑定事件，无论使用原生的<code>addEventListener</code>或者jQuery的<code>on</code>，事件处理程序里面的上下文<code>this</code>都是DOM元素本身。如果把一个对象的方法作为事件处理程序绑定到DOM元素的某个事件上，而这个方法又使用了<code>this</code>引用这个对象的其他方法，这样触发事件执行处理程序的时候必然会出错。所以我们需要手动把事件处理程序的执行上下文<code>this</code>改变成这个对象本身，如：</p>\n<pre><code>if (!Function.prototype.bind) {\n  Function.prototype.bind = function (context){\n    var fn = this;\n    return function(){                                \n      return fn.apply(context,arguments);  \n    };                                                \n  }\n｝\n</code></pre><p>这里我作了一些小改动，在JavaScript 1.8.5中，<code>bind</code>已经是<code>Function</code>原型的方法了。通过闭包把原来的方法记录下来，在返回的匿名函数中调用原来方法的<code>apply</code>改变执行上下文<code>this</code>指向的对象，这样就可以手动地改变事件处理程序中的<code>this</code>。</p>\n<p>我个人更偏好于使用jQuery的<code>proxy</code>方法来做这个事情，如：</p>\n<pre><code>$(&quot;#id&quot;).on(&quot;click&quot;, $.proxy(obj.func, obj));\n</code></pre><p>保持对象（或者“类”的“实例”）方法中<code>this</code>的指向永远是该对象本身，对于面向对象的JavaScript来说我认为是十分必要的，可以增加一个“类”中代码的可读性与可维护性。</p>\n<h3 id=\"-\">柯里化</h3>\n<p>柯里化就是把一个函数的某些参数预置好，返回一个新的函数，接受没有预置的参数。实现的方式有很多种，如果不通过闭包可以将函数进行二次封装而产生新的函数。纯粹地预置参数，这样做未免有些冗余，如果使用闭包，只需要调用某个<code>curry</code>函数，传入预置的参数，就可以返回一个新的函数了。这里分享一个比较有意思的实现，它能预置一个函数中任意位置的参数：</p>\n<pre><code>Function.prototype.partial = function() {\n  var fn = this, args = Array.prototype.slice.call(arguments);\n  return function() {\n    var arg = 0;\n    for (var i = 0; i &lt; args.length &amp;&amp; arg &lt; arguments.length; i++) {\n      if (args[i] === undefined) {\n        args[i] = arguments[arg++];\n      }\n    }\n    return fn.apply(this, args);\n  };\n};\n</code></pre><p>通过柯里化过程中传入<code>undefined</code>的位置，预留给结果函数来传入非预置的参数。传给结果函数的参数会像填坑一样把那些之前标识为<code>undefined</code>的参数填充起来。</p>\n<p>今天就先到这里，闭包的作用还有很多很多，明天继续！</p>\n","summaryMarkdownText":"\n\n\n又到读书笔记的时候了！闭包，是JavaScript的重要特性之一，这里不聊什么是闭包，这篇文章主要关注闭包的作用。\n\n### 绑定函数的执行上下文\n\n我们知道，为一个DOM元素绑定事件，无论使用原生的`addEventListener`或者jQuery的`on`，事件处理程序里面的上下文`this`都是DOM元素本身。如果把一个对象的方法作为事件处理程序绑定到DOM元素的某个事件上，而这个方法又使用了`this`引用这个对象的其他方法，这样触发事件执行处理程序的时候必然会出错。所以我们需要手动把事件处理程序的执行上下文`this`改变成这个对象本身，如：\n\n    if (!Function.prototype.bind) {\n      Function.prototype.bind = function (context){\n        var fn = this;\n        return function(){                                \n          return fn.apply(context,arguments);  \n        };                                                \n      }\n    ｝\n\n这里我作了一些小改动，在JavaScript 1.8.5中，`bind`已经是`Function`原型的方法了。通过闭包把原来的方法记录下来，在返回的匿名函数中调用原来方法的`apply`改变执行上下文`this`指向的对象，这样就可以手动地改变事件处理程序中的`this`。\n\n我个人更偏好于使用jQuery的`proxy`方法来做这个事情，如：\n\n    $(\"#id\").on(\"click\", $.proxy(obj.func, obj));\n\n保持对象（或者“类”的“实例”）方法中`this`的指向永远是该对象本身，对于面向对象的JavaScript来说我认为是十分必要的，可以增加一个“类”中代码的可读性与可维护性。","summaryHtmlText":"<p>又到读书笔记的时候了！闭包，是JavaScript的重要特性之一，这里不聊什么是闭包，这篇文章主要关注闭包的作用。</p>\n<h3 id=\"-\">绑定函数的执行上下文</h3>\n<p>我们知道，为一个DOM元素绑定事件，无论使用原生的<code>addEventListener</code>或者jQuery的<code>on</code>，事件处理程序里面的上下文<code>this</code>都是DOM元素本身。如果把一个对象的方法作为事件处理程序绑定到DOM元素的某个事件上，而这个方法又使用了<code>this</code>引用这个对象的其他方法，这样触发事件执行处理程序的时候必然会出错。所以我们需要手动把事件处理程序的执行上下文<code>this</code>改变成这个对象本身，如：</p>\n<pre><code>if (!Function.prototype.bind) {\n  Function.prototype.bind = function (context){\n    var fn = this;\n    return function(){                                \n      return fn.apply(context,arguments);  \n    };                                                \n  }\n｝\n</code></pre><p>这里我作了一些小改动，在JavaScript 1.8.5中，<code>bind</code>已经是<code>Function</code>原型的方法了。通过闭包把原来的方法记录下来，在返回的匿名函数中调用原来方法的<code>apply</code>改变执行上下文<code>this</code>指向的对象，这样就可以手动地改变事件处理程序中的<code>this</code>。</p>\n<p>我个人更偏好于使用jQuery的<code>proxy</code>方法来做这个事情，如：</p>\n<pre><code>$(&quot;#id&quot;).on(&quot;click&quot;, $.proxy(obj.func, obj));\n</code></pre><p>保持对象（或者“类”的“实例”）方法中<code>this</code>的指向永远是该对象本身，对于面向对象的JavaScript来说我认为是十分必要的，可以增加一个“类”中代码的可读性与可维护性。</p>\n"}