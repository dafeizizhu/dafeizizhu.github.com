{"year":"2014","month":"01","day":"07","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2014/01/07/flash-application-domain.html","fileName":"flash-application-domain","layout":"post","title":"使用应用程序域","description":"","tags":["Flash"],"markdownText":"\n\n\n应用程序域`ApplicationDomain`的用途是存储ActionScript 3.0的定义表。`swf`文件中的所有代码都被定义在应用程序域中。通过不同的应用程序域，可以允许同一个类有多个定义，并且还允许子级重用父级定义。\n\n在使用`Loader`的`load`方法的时候，通过`context`这个参数可以指定加载内容的应用程序域，例如：\n\n    ldr = new Loader(); \n    var req:URLRequest = new URLRequest(\"Greeter.swf\"); \n    var ldrContext:LoaderContext = new LoaderContext(false, ApplicationDomain.currentDomain); \n    ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler); \n    ldr.load(req, ldrContext);\n\n以上的代码把加载的`swf`文件放入到当前`swf`文件的应用程序域中。在使用应用程序域时，要记住以下几点：\n\n1. `swf`文件中的所有代码都会被定义在该应用程序域中。\n2. 已加载的类尽在其父级中没有相关定义时才进行定义，不能用较新的定义覆盖已加载类的定义。\n\n在加载其他`swf`文件的时候，我们可以通过创建系统域的子与划分子级`swf`文件：\n\n    var appDomainA:ApplicationDomain = new ApplicationDomain(); \n    var contextA:LoaderContext = new LoaderContext(false, appDomainA); \n    var loaderA:Loader = new Loader(); \n    loaderA.load(new URLRequest(\"application2.swf\"), contextA);\n\n也可以使用`Application.currentDomain`，这样可以将新的类定义添加到应用程序当前的一组类定义中，这样加载的`swf`被视为运行时共享库：\n\n    var appDomainB:ApplicationDomain = ApplicationDomain.currentDomain; \n    var contextB:LoaderContext = new LoaderContext(false, appDomainB); \n    var loaderB:Loader = new Loader(); \n    loaderB.load(new URLRequest(\"module1.swf\"), contextB);\n\n最后一种方式是通过创建当前域的新子域，使用父级的类定义：\n\n    var appDomainC:ApplicationDomain = new ApplicationDomain(ApplicationDomain.currentDomain);  \n    var contextC:LoaderContext = new LoaderContext(false, appDomainC); \n    var loaderC:Loader = new Loader(); \n    loaderC.load(new URLRequest(\"module3.swf\"), contextC);\n","htmlText":"<p>应用程序域<code>ApplicationDomain</code>的用途是存储ActionScript 3.0的定义表。<code>swf</code>文件中的所有代码都被定义在应用程序域中。通过不同的应用程序域，可以允许同一个类有多个定义，并且还允许子级重用父级定义。</p>\n<p>在使用<code>Loader</code>的<code>load</code>方法的时候，通过<code>context</code>这个参数可以指定加载内容的应用程序域，例如：</p>\n<pre><code>ldr = new Loader(); \nvar req:URLRequest = new URLRequest(&quot;Greeter.swf&quot;); \nvar ldrContext:LoaderContext = new LoaderContext(false, ApplicationDomain.currentDomain); \nldr.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler); \nldr.load(req, ldrContext);\n</code></pre><p>以上的代码把加载的<code>swf</code>文件放入到当前<code>swf</code>文件的应用程序域中。在使用应用程序域时，要记住以下几点：</p>\n<ol>\n<li><code>swf</code>文件中的所有代码都会被定义在该应用程序域中。</li>\n<li>已加载的类尽在其父级中没有相关定义时才进行定义，不能用较新的定义覆盖已加载类的定义。</li>\n</ol>\n<p>在加载其他<code>swf</code>文件的时候，我们可以通过创建系统域的子与划分子级<code>swf</code>文件：</p>\n<pre><code>var appDomainA:ApplicationDomain = new ApplicationDomain(); \nvar contextA:LoaderContext = new LoaderContext(false, appDomainA); \nvar loaderA:Loader = new Loader(); \nloaderA.load(new URLRequest(&quot;application2.swf&quot;), contextA);\n</code></pre><p>也可以使用<code>Application.currentDomain</code>，这样可以将新的类定义添加到应用程序当前的一组类定义中，这样加载的<code>swf</code>被视为运行时共享库：</p>\n<pre><code>var appDomainB:ApplicationDomain = ApplicationDomain.currentDomain; \nvar contextB:LoaderContext = new LoaderContext(false, appDomainB); \nvar loaderB:Loader = new Loader(); \nloaderB.load(new URLRequest(&quot;module1.swf&quot;), contextB);\n</code></pre><p>最后一种方式是通过创建当前域的新子域，使用父级的类定义：</p>\n<pre><code>var appDomainC:ApplicationDomain = new ApplicationDomain(ApplicationDomain.currentDomain);  \nvar contextC:LoaderContext = new LoaderContext(false, appDomainC); \nvar loaderC:Loader = new Loader(); \nloaderC.load(new URLRequest(&quot;module3.swf&quot;), contextC);\n</code></pre>","summaryMarkdownText":"\n\n\n应用程序域`ApplicationDomain`的用途是存储ActionScript 3.0的定义表。`swf`文件中的所有代码都被定义在应用程序域中。通过不同的应用程序域，可以允许同一个类有多个定义，并且还允许子级重用父级定义。\n\n在使用`Loader`的`load`方法的时候，通过`context`这个参数可以指定加载内容的应用程序域，例如：\n\n    ldr = new Loader(); \n    var req:URLRequest = new URLRequest(\"Greeter.swf\"); \n    var ldrContext:LoaderContext = new LoaderContext(false, ApplicationDomain.currentDomain); \n    ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler); \n    ldr.load(req, ldrContext);\n\n以上的代码把加载的`swf`文件放入到当前`swf`文件的应用程序域中。在使用应用程序域时，要记住以下几点：\n\n1. `swf`文件中的所有代码都会被定义在该应用程序域中。\n2. 已加载的类尽在其父级中没有相关定义时才进行定义，不能用较新的定义覆盖已加载类的定义。\n\n在加载其他`swf`文件的时候，我们可以通过创建系统域的子与划分子级`swf`文件：\n\n    var appDomainA:ApplicationDomain = new ApplicationDomain(); \n    var contextA:LoaderContext = new LoaderContext(false, appDomainA); \n    var loaderA:Loader = new Loader(); \n    loaderA.load(new URLRequest(\"application2.swf\"), contextA);\n","summaryHtmlText":"<p>应用程序域<code>ApplicationDomain</code>的用途是存储ActionScript 3.0的定义表。<code>swf</code>文件中的所有代码都被定义在应用程序域中。通过不同的应用程序域，可以允许同一个类有多个定义，并且还允许子级重用父级定义。</p>\n<p>在使用<code>Loader</code>的<code>load</code>方法的时候，通过<code>context</code>这个参数可以指定加载内容的应用程序域，例如：</p>\n<pre><code>ldr = new Loader(); \nvar req:URLRequest = new URLRequest(&quot;Greeter.swf&quot;); \nvar ldrContext:LoaderContext = new LoaderContext(false, ApplicationDomain.currentDomain); \nldr.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler); \nldr.load(req, ldrContext);\n</code></pre><p>以上的代码把加载的<code>swf</code>文件放入到当前<code>swf</code>文件的应用程序域中。在使用应用程序域时，要记住以下几点：</p>\n<ol>\n<li><code>swf</code>文件中的所有代码都会被定义在该应用程序域中。</li>\n<li>已加载的类尽在其父级中没有相关定义时才进行定义，不能用较新的定义覆盖已加载类的定义。</li>\n</ol>\n<p>在加载其他<code>swf</code>文件的时候，我们可以通过创建系统域的子与划分子级<code>swf</code>文件：</p>\n<pre><code>var appDomainA:ApplicationDomain = new ApplicationDomain(); \nvar contextA:LoaderContext = new LoaderContext(false, appDomainA); \nvar loaderA:Loader = new Loader(); \nloaderA.load(new URLRequest(&quot;application2.swf&quot;), contextA);\n</code></pre>"}