{"year":"2013","month":"11","day":"01","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/11/01/ie-ondataavailable-event.html","fileName":"ie-ondataavailable-event","layout":"post","title":"IE的dataavailable事件","description":"","tags":["JavaScript"],"markdownText":"\n\n\n虽然`postMessage`已经是跨`iframe`通讯的一个比较完善的解决方案了，但是，如果，要IE8及以上的版本才支持这个方法。如果这两个`iframe`是同域的话，其实是可以直接通过脚本操作两个`window`，直接调用其内部方法就行通讯：\n\n    // outer\n    var innerWin = document.getElemenetById(\"iframe\").contentWindow;\n    innerWin.doSomething();\n    // inner\n    function doSomething() {\n      alert(\"outer message!\");\n    }\n\n其实还有一个方法，就是`dataavailable`事件。这个事件是IE特有的事件，当数据源对象的数据准备好之后，可以触发这个事件来通知其他对象。\n\n这个事件像其他标准事件一样，可以使用以下几个方式来绑定：\n\n1. 在HTML里面：`<element ondataavailable=\"handler\"></element>`。\n2. 作为属性：`object.ondataavailable = handler;`。\n3. 使用`attachEvent`：`object.attachEvent(\"ondataavailible\", handler);`。\n4. 在IE9还可以使用`addEventListener`：`object.addEventListener(\"dataavailible\", handler, useCapture);`。\n\n由于这个事件不是用户触发的，我们需要使用脚本在特定的对象上触发这个事件：\n\n    var event = document.createEventObject();\n    object.fireEvent(\"ondataavailable\", event);\n\n值得开心的是，连IE6都支持这个事件。通过这个事件，我们可以做一个跨`iframe`通讯的函数：\n\n    var Messenger = function (targetWin) {\n      var me = this;\n      document.attachEvent(\"ondataavailable\", function (event) {\n        if (!event.eventType ||\n            event.eventType !== \"message\" ||\n            event.eventSource != targetWin)\n          return;\n        $(me).trigger(\"onmessage\", event.eventData);\n      };\n      this.send = function (msg) {\n        var event = targetWin.document.createEventObject();\n        event.eventType = \"message\";\n        event.eventSource = window;\n        event.eventData = msg;\n        targetWind.document.fireEvent(\"ondataavailible\", event);\n      }\n    };\n\n以上代码构造了一个双向通讯的一对一的管道，我们可以透过这个管道在两个`iframe`之间交换信息。\n\n既然是同域的，为什么不直接互相调用两个`window`里面的方法，而要使用这个事件呢？我自己觉得最主要的一点是不需要在两个`window`附加额外的全局函数（例如最上面的`doSomething`）。而且IE6都支持，何乐而不为呢？\n\n如果跨域`iframe`之间的通讯，就不能用这个事件了，因为`targetWin.document`是不让访问的，这时候就要求助于`window.name`了。\n","htmlText":"<p>虽然<code>postMessage</code>已经是跨<code>iframe</code>通讯的一个比较完善的解决方案了，但是，如果，要IE8及以上的版本才支持这个方法。如果这两个<code>iframe</code>是同域的话，其实是可以直接通过脚本操作两个<code>window</code>，直接调用其内部方法就行通讯：</p>\n<pre><code>// outer\nvar innerWin = document.getElemenetById(&quot;iframe&quot;).contentWindow;\ninnerWin.doSomething();\n// inner\nfunction doSomething() {\n  alert(&quot;outer message!&quot;);\n}\n</code></pre><p>其实还有一个方法，就是<code>dataavailable</code>事件。这个事件是IE特有的事件，当数据源对象的数据准备好之后，可以触发这个事件来通知其他对象。</p>\n<p>这个事件像其他标准事件一样，可以使用以下几个方式来绑定：</p>\n<ol>\n<li>在HTML里面：<code>&lt;element ondataavailable=&quot;handler&quot;&gt;&lt;/element&gt;</code>。</li>\n<li>作为属性：<code>object.ondataavailable = handler;</code>。</li>\n<li>使用<code>attachEvent</code>：<code>object.attachEvent(&quot;ondataavailible&quot;, handler);</code>。</li>\n<li>在IE9还可以使用<code>addEventListener</code>：<code>object.addEventListener(&quot;dataavailible&quot;, handler, useCapture);</code>。</li>\n</ol>\n<p>由于这个事件不是用户触发的，我们需要使用脚本在特定的对象上触发这个事件：</p>\n<pre><code>var event = document.createEventObject();\nobject.fireEvent(&quot;ondataavailable&quot;, event);\n</code></pre><p>值得开心的是，连IE6都支持这个事件。通过这个事件，我们可以做一个跨<code>iframe</code>通讯的函数：</p>\n<pre><code>var Messenger = function (targetWin) {\n  var me = this;\n  document.attachEvent(&quot;ondataavailable&quot;, function (event) {\n    if (!event.eventType ||\n        event.eventType !== &quot;message&quot; ||\n        event.eventSource != targetWin)\n      return;\n    $(me).trigger(&quot;onmessage&quot;, event.eventData);\n  };\n  this.send = function (msg) {\n    var event = targetWin.document.createEventObject();\n    event.eventType = &quot;message&quot;;\n    event.eventSource = window;\n    event.eventData = msg;\n    targetWind.document.fireEvent(&quot;ondataavailible&quot;, event);\n  }\n};\n</code></pre><p>以上代码构造了一个双向通讯的一对一的管道，我们可以透过这个管道在两个<code>iframe</code>之间交换信息。</p>\n<p>既然是同域的，为什么不直接互相调用两个<code>window</code>里面的方法，而要使用这个事件呢？我自己觉得最主要的一点是不需要在两个<code>window</code>附加额外的全局函数（例如最上面的<code>doSomething</code>）。而且IE6都支持，何乐而不为呢？</p>\n<p>如果跨域<code>iframe</code>之间的通讯，就不能用这个事件了，因为<code>targetWin.document</code>是不让访问的，这时候就要求助于<code>window.name</code>了。</p>\n","summaryMarkdownText":"\n\n\n虽然`postMessage`已经是跨`iframe`通讯的一个比较完善的解决方案了，但是，如果，要IE8及以上的版本才支持这个方法。如果这两个`iframe`是同域的话，其实是可以直接通过脚本操作两个`window`，直接调用其内部方法就行通讯：\n\n    // outer\n    var innerWin = document.getElemenetById(\"iframe\").contentWindow;\n    innerWin.doSomething();\n    // inner\n    function doSomething() {\n      alert(\"outer message!\");\n    }\n\n其实还有一个方法，就是`dataavailable`事件。这个事件是IE特有的事件，当数据源对象的数据准备好之后，可以触发这个事件来通知其他对象。\n\n这个事件像其他标准事件一样，可以使用以下几个方式来绑定：\n\n1. 在HTML里面：`<element ondataavailable=\"handler\"></element>`。\n2. 作为属性：`object.ondataavailable = handler;`。\n3. 使用`attachEvent`：`object.attachEvent(\"ondataavailible\", handler);`。\n4. 在IE9还可以使用`addEventListener`：`object.addEventListener(\"dataavailible\", handler, useCapture);`。\n\n由于这个事件不是用户触发的，我们需要使用脚本在特定的对象上触发这个事件：\n\n    var event = document.createEventObject();","summaryHtmlText":"<p>虽然<code>postMessage</code>已经是跨<code>iframe</code>通讯的一个比较完善的解决方案了，但是，如果，要IE8及以上的版本才支持这个方法。如果这两个<code>iframe</code>是同域的话，其实是可以直接通过脚本操作两个<code>window</code>，直接调用其内部方法就行通讯：</p>\n<pre><code>// outer\nvar innerWin = document.getElemenetById(&quot;iframe&quot;).contentWindow;\ninnerWin.doSomething();\n// inner\nfunction doSomething() {\n  alert(&quot;outer message!&quot;);\n}\n</code></pre><p>其实还有一个方法，就是<code>dataavailable</code>事件。这个事件是IE特有的事件，当数据源对象的数据准备好之后，可以触发这个事件来通知其他对象。</p>\n<p>这个事件像其他标准事件一样，可以使用以下几个方式来绑定：</p>\n<ol>\n<li>在HTML里面：<code>&lt;element ondataavailable=&quot;handler&quot;&gt;&lt;/element&gt;</code>。</li>\n<li>作为属性：<code>object.ondataavailable = handler;</code>。</li>\n<li>使用<code>attachEvent</code>：<code>object.attachEvent(&quot;ondataavailible&quot;, handler);</code>。</li>\n<li>在IE9还可以使用<code>addEventListener</code>：<code>object.addEventListener(&quot;dataavailible&quot;, handler, useCapture);</code>。</li>\n</ol>\n<p>由于这个事件不是用户触发的，我们需要使用脚本在特定的对象上触发这个事件：</p>\n<pre><code>var event = document.createEventObject();\n</code></pre>"}