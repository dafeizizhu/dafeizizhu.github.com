{"year":"2013","month":"08","day":"10","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/08/10/javascript-oo-gotchas.html","fileName":"javascript-oo-gotchas","layout":"post","title":"Secrets of the JavaScript Ninja 读书笔记之 面向对象陷阱","description":"","tags":["JavaScript"],"markdownText":"\n\n\n又到了周末读书的时间了。今天跟大家分享一下书中关于原型、实例化和继承的一些陷阱。\n\n### 扩展`Object`\n\n先来看看扩展`Object.prototype`可能会发生什么潜在的问题。假如我们为`Object`的原型增加一个获取对象上键值的个数，可能会这么写：\n\n    Object.prototype.keys = function() {      \n      var keys = [];\n      for (var p in this) keys.push(p);\n      return keys;\n    };\n    var obj = { a: 1, b: 2, c: 3 };              \n    alert(obj.keys());\n\n结果返回了`[a, b, c, keys]`。这种遍历方式甚至把我们刚才扩展`Object.prototype`的那个`keys`方法都遍历出来了！一般情况下，我们对一个对象进行遍历，是不需要把对象上的方法遍历出来的。解决上面的问题，一种方案是判断遍历的值是否是方法，另一种方案就是使用`hasOwnProperty`来判断对象是否拥有这个属性，过滤掉原型链中的其他属性。\n\n### 扩展`Number`\n\n为`Number.prototype`做扩展要注意的是，在其文档中要说明如何使用这个扩展。假设我们为`Number.prototype`增加了一个`add`方法，那只能按以下的方式调用：\n\n    var n = 5;\n    n.add(2);\n\n或者\n\n    (5).add(2);\n\n而不能\n\n    5.add(2);\n\n最后一行代码有语法错误，会导致JavaScript脚本无法顺利执行。所以最好的解决方案是**不要对`Number.prototype`进行扩展**。\n\n### 派生内置“类”\n\n假如我们需要数组的功能，例如`push`、`pop`等，又想在不增加原来`Array`的功能，那我们可以使用以下的代码，继承`Array`，派生一个自定义的“类”：\n\n    function MyArray() {}\n    MyArray.prototype = new Array();\n\n这段代码在FireFox和Chrome上都是好使的，但在IE下就会有问题，因为IE对数组的`length`的处理是不同的。这种场景对应的解决方案是使用拷贝数组中有用的功能，重新构造一个“类”。\n\n*注：测试发现IE7、8、9中以上的代码都是没问题的，不知道问题是否只存在于IE6……例子可以[参考这里](http://jsfiddle.net/ERcFg/3/)。*\n\n### 实例化\n\n假如有以下一个函数：\n\n    function User(first, last){\n      this.name = first + \" \" + last;\n    }\n\n这个明显是一个构造函数，正确的调用方法应该是这样：\n\n    var user = new User(\"Ichigo\", \"Kurosaki\");\n\n但是值得注意的是这个函数也可以像普通函数那样直接执行（即省略`new`）。当省略`new`之后，不仅`user`会是`undefined`，更严重的影响可能是在全局作用域中增加了一个`name`属性（`this` === `window`）。虽然这种调用我们可以通过文档来说明调用的方式，但是还有更健壮的实现：\n\n    function User(first, last) {\n      if (!(this instanceof arguments.callee)) { \n        return new User(first,last);                  \n      }                                                \n      this.name = first + \" \" + last;\n    }\n\n这里先使用`instanceof`来判断`this`是否这个“类”的实例，如果不是则自动以构造函数的方式再调用一次。这种实现的好处无疑是增加了健壮性，无论用户如何调用这个方法，都会返回一个`User`的实例。但是使用这个实现的时候还需要考虑以下几点：\n\n1. `arguments.callee`在往后的JavaScript标准中已经被废弃了，而且在严格模式下使用这个属性是会报错的。可以硬编码成`User`，牺牲少许灵活性。\n2. 这样做导致一个功能有两种调用形式，这对API的一致性是不利的。\n3. a这样做也限制了用户把这个函数当成普通函数执行的权力。\n\n关于JavaScript OO的各种陷阱还有很多，日常编码的时候一定要注意多在不同的设备、不同的平台、不同的浏览器进行测试。在考虑实现的时候也要想想这个功能是否真需要用OO来实现，毕竟JavaScript只是一个基于对象的语言，而不是一个完整的面向对象的语言。\n","htmlText":"<p>又到了周末读书的时间了。今天跟大家分享一下书中关于原型、实例化和继承的一些陷阱。</p>\n<h3 id=\"-object-\">扩展<code>Object</code></h3>\n<p>先来看看扩展<code>Object.prototype</code>可能会发生什么潜在的问题。假如我们为<code>Object</code>的原型增加一个获取对象上键值的个数，可能会这么写：</p>\n<pre><code>Object.prototype.keys = function() {      \n  var keys = [];\n  for (var p in this) keys.push(p);\n  return keys;\n};\nvar obj = { a: 1, b: 2, c: 3 };              \nalert(obj.keys());\n</code></pre><p>结果返回了<code>[a, b, c, keys]</code>。这种遍历方式甚至把我们刚才扩展<code>Object.prototype</code>的那个<code>keys</code>方法都遍历出来了！一般情况下，我们对一个对象进行遍历，是不需要把对象上的方法遍历出来的。解决上面的问题，一种方案是判断遍历的值是否是方法，另一种方案就是使用<code>hasOwnProperty</code>来判断对象是否拥有这个属性，过滤掉原型链中的其他属性。</p>\n<h3 id=\"-number-\">扩展<code>Number</code></h3>\n<p>为<code>Number.prototype</code>做扩展要注意的是，在其文档中要说明如何使用这个扩展。假设我们为<code>Number.prototype</code>增加了一个<code>add</code>方法，那只能按以下的方式调用：</p>\n<pre><code>var n = 5;\nn.add(2);\n</code></pre><p>或者</p>\n<pre><code>(5).add(2);\n</code></pre><p>而不能</p>\n<pre><code>5.add(2);\n</code></pre><p>最后一行代码有语法错误，会导致JavaScript脚本无法顺利执行。所以最好的解决方案是<strong>不要对<code>Number.prototype</code>进行扩展</strong>。</p>\n<h3 id=\"-\">派生内置“类”</h3>\n<p>假如我们需要数组的功能，例如<code>push</code>、<code>pop</code>等，又想在不增加原来<code>Array</code>的功能，那我们可以使用以下的代码，继承<code>Array</code>，派生一个自定义的“类”：</p>\n<pre><code>function MyArray() {}\nMyArray.prototype = new Array();\n</code></pre><p>这段代码在FireFox和Chrome上都是好使的，但在IE下就会有问题，因为IE对数组的<code>length</code>的处理是不同的。这种场景对应的解决方案是使用拷贝数组中有用的功能，重新构造一个“类”。</p>\n<p><em>注：测试发现IE7、8、9中以上的代码都是没问题的，不知道问题是否只存在于IE6……例子可以<a href=\"http://jsfiddle.net/ERcFg/3/\">参考这里</a>。</em></p>\n<h3 id=\"-\">实例化</h3>\n<p>假如有以下一个函数：</p>\n<pre><code>function User(first, last){\n  this.name = first + &quot; &quot; + last;\n}\n</code></pre><p>这个明显是一个构造函数，正确的调用方法应该是这样：</p>\n<pre><code>var user = new User(&quot;Ichigo&quot;, &quot;Kurosaki&quot;);\n</code></pre><p>但是值得注意的是这个函数也可以像普通函数那样直接执行（即省略<code>new</code>）。当省略<code>new</code>之后，不仅<code>user</code>会是<code>undefined</code>，更严重的影响可能是在全局作用域中增加了一个<code>name</code>属性（<code>this</code> === <code>window</code>）。虽然这种调用我们可以通过文档来说明调用的方式，但是还有更健壮的实现：</p>\n<pre><code>function User(first, last) {\n  if (!(this instanceof arguments.callee)) { \n    return new User(first,last);                  \n  }                                                \n  this.name = first + &quot; &quot; + last;\n}\n</code></pre><p>这里先使用<code>instanceof</code>来判断<code>this</code>是否这个“类”的实例，如果不是则自动以构造函数的方式再调用一次。这种实现的好处无疑是增加了健壮性，无论用户如何调用这个方法，都会返回一个<code>User</code>的实例。但是使用这个实现的时候还需要考虑以下几点：</p>\n<ol>\n<li><code>arguments.callee</code>在往后的JavaScript标准中已经被废弃了，而且在严格模式下使用这个属性是会报错的。可以硬编码成<code>User</code>，牺牲少许灵活性。</li>\n<li>这样做导致一个功能有两种调用形式，这对API的一致性是不利的。</li>\n<li>a这样做也限制了用户把这个函数当成普通函数执行的权力。</li>\n</ol>\n<p>关于JavaScript OO的各种陷阱还有很多，日常编码的时候一定要注意多在不同的设备、不同的平台、不同的浏览器进行测试。在考虑实现的时候也要想想这个功能是否真需要用OO来实现，毕竟JavaScript只是一个基于对象的语言，而不是一个完整的面向对象的语言。</p>\n","summaryMarkdownText":"\n\n\n又到了周末读书的时间了。今天跟大家分享一下书中关于原型、实例化和继承的一些陷阱。\n\n### 扩展`Object`\n\n先来看看扩展`Object.prototype`可能会发生什么潜在的问题。假如我们为`Object`的原型增加一个获取对象上键值的个数，可能会这么写：\n\n    Object.prototype.keys = function() {      \n      var keys = [];\n      for (var p in this) keys.push(p);\n      return keys;\n    };\n    var obj = { a: 1, b: 2, c: 3 };              \n    alert(obj.keys());\n\n结果返回了`[a, b, c, keys]`。这种遍历方式甚至把我们刚才扩展`Object.prototype`的那个`keys`方法都遍历出来了！一般情况下，我们对一个对象进行遍历，是不需要把对象上的方法遍历出来的。解决上面的问题，一种方案是判断遍历的值是否是方法，另一种方案就是使用`hasOwnProperty`来判断对象是否拥有这个属性，过滤掉原型链中的其他属性。\n\n### 扩展`Number`\n\n为`Number.prototype`做扩展要注意的是，在其文档中要说明如何使用这个扩展。假设我们为`Number.prototype`增加了一个`add`方法，那只能按以下的方式调用：\n\n    var n = 5;\n    n.add(2);","summaryHtmlText":"<p>又到了周末读书的时间了。今天跟大家分享一下书中关于原型、实例化和继承的一些陷阱。</p>\n<h3 id=\"-object-\">扩展<code>Object</code></h3>\n<p>先来看看扩展<code>Object.prototype</code>可能会发生什么潜在的问题。假如我们为<code>Object</code>的原型增加一个获取对象上键值的个数，可能会这么写：</p>\n<pre><code>Object.prototype.keys = function() {      \n  var keys = [];\n  for (var p in this) keys.push(p);\n  return keys;\n};\nvar obj = { a: 1, b: 2, c: 3 };              \nalert(obj.keys());\n</code></pre><p>结果返回了<code>[a, b, c, keys]</code>。这种遍历方式甚至把我们刚才扩展<code>Object.prototype</code>的那个<code>keys</code>方法都遍历出来了！一般情况下，我们对一个对象进行遍历，是不需要把对象上的方法遍历出来的。解决上面的问题，一种方案是判断遍历的值是否是方法，另一种方案就是使用<code>hasOwnProperty</code>来判断对象是否拥有这个属性，过滤掉原型链中的其他属性。</p>\n<h3 id=\"-number-\">扩展<code>Number</code></h3>\n<p>为<code>Number.prototype</code>做扩展要注意的是，在其文档中要说明如何使用这个扩展。假设我们为<code>Number.prototype</code>增加了一个<code>add</code>方法，那只能按以下的方式调用：</p>\n<pre><code>var n = 5;\nn.add(2);\n</code></pre>"}