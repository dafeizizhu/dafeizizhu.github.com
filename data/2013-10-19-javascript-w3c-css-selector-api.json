{"year":"2013","month":"10","day":"19","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/10/19/javascript-w3c-css-selector-api.html","fileName":"javascript-w3c-css-selector-api","layout":"post","title":"Secrets of the JavaScript Ninja 读书笔记之 W3C CSS选择器API","description":"","tags":["JavaScript"],"markdownText":"\n\n\n由于jQuery的风靡，W3C在规范中加入了浏览器内置的CSS选择器引擎，来减少我们去实现一个纯JavaScript的CSS选择器引擎所导致的额外工作量。所有现代浏览器都已经实现了对应的API，并且如果该浏览器完全支持CSS3的话，所有CSS选择器都是可用的。\n\n浏览器提供了以下两个API供我们使用CSS选择器去选择我们要操作的DOM：\n\n1. `querySelector`，该方法接受一个CSS选择器，并返回匹配的**第一个**DOM元素。\n2. `querySelectorAll`，该方法接受一个CSS选择器，返回一个包含所有匹配的DOM元素的一个`NodeList`。\n\n这两个方法在所有`document`、`documentFragment`和DOM元素上都有。在哪个对象上调用这些API即视该DOM为根元素，会在该对象的子孙寻找匹配的元素。\n\n恐怕这些API最大的局限性就是浏览器对CSS选择器的支持程度，而纯JavaScript实现的CSS选择器则不会受到浏览器默认实现的影响。而且还有一个可能看起来比较别扭的使用场景：\n\n    <div id=\"test\">\n      <b>Hello</b>, I'm a ninja!\n    </div>\n    <script type=\"text/javascript\">\n      window.onload = function () {\n      var b = document.getElementById(\"test\").querySelector(\"div b\");\n      assert(b, \"Only the last part of the selector matters.\");\n    };\n    </script>\n\n在这个例子里面，选择器的愿意是寻找`div`子孙中的`b`。但是由于`querySelector`是在`div`上调用的，而这个元素是不计入选择器的匹配范围的，即上面的代码是找`div`下面的`div`下面的`b`，所以自然就匹配不上了。\n\n为了能让选择器能从根元素上开始匹配，我们需要编写另外一个API去实现这个功能：\n\n    (function() {                       \n      var count = 1;\n      this.rootedQuerySelectorAll = function (elem, query) { \n        var oldID = elem.id;                                 \n        elem.id = \"rooted\" + (count++);          \n        try {\n          return elem.querySelectorAll(\"#\" + elem.id + \" \" + query);\n        }\n        catch (e) {\n          throw e;\n        }\n        finally {\n          elem.id = oldID;             \n        }\n      };\n    });\n\n通过加入一个`id`选择器（该`id`就是根元素的`id`，是我们临时设置的）去实现从根上进行匹配的API。\n\n使用浏览器提供的API，可以让现在的JavaScript库中关于DOM选择的一大段代码变成一行代码。随着浏览器对CSS支持的完善，还有旧浏览器的退出市场，浏览器提供的CSS选择器的用武之地必然会大大提高！\n","htmlText":"<p>由于jQuery的风靡，W3C在规范中加入了浏览器内置的CSS选择器引擎，来减少我们去实现一个纯JavaScript的CSS选择器引擎所导致的额外工作量。所有现代浏览器都已经实现了对应的API，并且如果该浏览器完全支持CSS3的话，所有CSS选择器都是可用的。</p>\n<p>浏览器提供了以下两个API供我们使用CSS选择器去选择我们要操作的DOM：</p>\n<ol>\n<li><code>querySelector</code>，该方法接受一个CSS选择器，并返回匹配的<strong>第一个</strong>DOM元素。</li>\n<li><code>querySelectorAll</code>，该方法接受一个CSS选择器，返回一个包含所有匹配的DOM元素的一个<code>NodeList</code>。</li>\n</ol>\n<p>这两个方法在所有<code>document</code>、<code>documentFragment</code>和DOM元素上都有。在哪个对象上调用这些API即视该DOM为根元素，会在该对象的子孙寻找匹配的元素。</p>\n<p>恐怕这些API最大的局限性就是浏览器对CSS选择器的支持程度，而纯JavaScript实现的CSS选择器则不会受到浏览器默认实现的影响。而且还有一个可能看起来比较别扭的使用场景：</p>\n<pre><code>&lt;div id=&quot;test&quot;&gt;\n  &lt;b&gt;Hello&lt;/b&gt;, I&#39;m a ninja!\n&lt;/div&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n  window.onload = function () {\n  var b = document.getElementById(&quot;test&quot;).querySelector(&quot;div b&quot;);\n  assert(b, &quot;Only the last part of the selector matters.&quot;);\n};\n&lt;/script&gt;\n</code></pre><p>在这个例子里面，选择器的愿意是寻找<code>div</code>子孙中的<code>b</code>。但是由于<code>querySelector</code>是在<code>div</code>上调用的，而这个元素是不计入选择器的匹配范围的，即上面的代码是找<code>div</code>下面的<code>div</code>下面的<code>b</code>，所以自然就匹配不上了。</p>\n<p>为了能让选择器能从根元素上开始匹配，我们需要编写另外一个API去实现这个功能：</p>\n<pre><code>(function() {                       \n  var count = 1;\n  this.rootedQuerySelectorAll = function (elem, query) { \n    var oldID = elem.id;                                 \n    elem.id = &quot;rooted&quot; + (count++);          \n    try {\n      return elem.querySelectorAll(&quot;#&quot; + elem.id + &quot; &quot; + query);\n    }\n    catch (e) {\n      throw e;\n    }\n    finally {\n      elem.id = oldID;             \n    }\n  };\n});\n</code></pre><p>通过加入一个<code>id</code>选择器（该<code>id</code>就是根元素的<code>id</code>，是我们临时设置的）去实现从根上进行匹配的API。</p>\n<p>使用浏览器提供的API，可以让现在的JavaScript库中关于DOM选择的一大段代码变成一行代码。随着浏览器对CSS支持的完善，还有旧浏览器的退出市场，浏览器提供的CSS选择器的用武之地必然会大大提高！</p>\n","summaryMarkdownText":"\n\n\n由于jQuery的风靡，W3C在规范中加入了浏览器内置的CSS选择器引擎，来减少我们去实现一个纯JavaScript的CSS选择器引擎所导致的额外工作量。所有现代浏览器都已经实现了对应的API，并且如果该浏览器完全支持CSS3的话，所有CSS选择器都是可用的。\n\n浏览器提供了以下两个API供我们使用CSS选择器去选择我们要操作的DOM：\n\n1. `querySelector`，该方法接受一个CSS选择器，并返回匹配的**第一个**DOM元素。\n2. `querySelectorAll`，该方法接受一个CSS选择器，返回一个包含所有匹配的DOM元素的一个`NodeList`。\n\n这两个方法在所有`document`、`documentFragment`和DOM元素上都有。在哪个对象上调用这些API即视该DOM为根元素，会在该对象的子孙寻找匹配的元素。\n\n恐怕这些API最大的局限性就是浏览器对CSS选择器的支持程度，而纯JavaScript实现的CSS选择器则不会受到浏览器默认实现的影响。而且还有一个可能看起来比较别扭的使用场景：\n\n    <div id=\"test\">\n      <b>Hello</b>, I'm a ninja!\n    </div>\n    <script type=\"text/javascript\">\n      window.onload = function () {\n      var b = document.getElementById(\"test\").querySelector(\"div b\");\n      assert(b, \"Only the last part of the selector matters.\");\n    };\n    </script>\n\n在这个例子里面，选择器的愿意是寻找`div`子孙中的`b`。但是由于`querySelector`是在`div`上调用的，而这个元素是不计入选择器的匹配范围的，即上面的代码是找`div`下面的`div`下面的`b`，所以自然就匹配不上了。","summaryHtmlText":"<p>由于jQuery的风靡，W3C在规范中加入了浏览器内置的CSS选择器引擎，来减少我们去实现一个纯JavaScript的CSS选择器引擎所导致的额外工作量。所有现代浏览器都已经实现了对应的API，并且如果该浏览器完全支持CSS3的话，所有CSS选择器都是可用的。</p>\n<p>浏览器提供了以下两个API供我们使用CSS选择器去选择我们要操作的DOM：</p>\n<ol>\n<li><code>querySelector</code>，该方法接受一个CSS选择器，并返回匹配的<strong>第一个</strong>DOM元素。</li>\n<li><code>querySelectorAll</code>，该方法接受一个CSS选择器，返回一个包含所有匹配的DOM元素的一个<code>NodeList</code>。</li>\n</ol>\n<p>这两个方法在所有<code>document</code>、<code>documentFragment</code>和DOM元素上都有。在哪个对象上调用这些API即视该DOM为根元素，会在该对象的子孙寻找匹配的元素。</p>\n<p>恐怕这些API最大的局限性就是浏览器对CSS选择器的支持程度，而纯JavaScript实现的CSS选择器则不会受到浏览器默认实现的影响。而且还有一个可能看起来比较别扭的使用场景：</p>\n<pre><code>&lt;div id=&quot;test&quot;&gt;\n  &lt;b&gt;Hello&lt;/b&gt;, I&#39;m a ninja!\n&lt;/div&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n  window.onload = function () {\n  var b = document.getElementById(&quot;test&quot;).querySelector(&quot;div b&quot;);\n  assert(b, &quot;Only the last part of the selector matters.&quot;);\n};\n&lt;/script&gt;\n</code></pre><p>在这个例子里面，选择器的愿意是寻找<code>div</code>子孙中的<code>b</code>。但是由于<code>querySelector</code>是在<code>div</code>上调用的，而这个元素是不计入选择器的匹配范围的，即上面的代码是找<code>div</code>下面的<code>div</code>下面的<code>b</code>，所以自然就匹配不上了。</p>\n"}