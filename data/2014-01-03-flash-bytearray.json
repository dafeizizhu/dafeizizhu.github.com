{"year":"2014","month":"01","day":"03","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2014/01/03/flash-bytearray.html","fileName":"flash-bytearray","layout":"post","title":"使用ByteArray","description":"","tags":["Flash"],"markdownText":"\n\n\n在Flash中，我们可以使用`ByteArray`来操作二进制数据：\n\n    var stream:ByteArray = new ByteArray();\n\n使用`ByteArray`，可以把数据按照流的形式组织成一个`ByteArray`。`ByteArray`提供了`readXXX`和对应的`writeXXX`方法，按照同样调用顺序把数据读取和写入到`ByteArray`中，实现对数据的序列化。例如，我们可以这么写：\n\n    bytes.writeUTFBytes(\"someString\");\n    bytes.writeFloat(1);\n\n可以这么读：\n\n    var str:String = bytes.readUTFBytes();\n    var float:Float = bytes.readFloat();\n\n`ByteArray`的`position`属性记录当前指针的位置，初始值为`0`。当读取或者写入`ByteArray`的时候，会更新`position`属性以指向上次读取或者写入字节后的位置：\n\n    bytes.writeUTFBytes(\"Hello World!\");\n\t// position + 12\n\n可以更改这个`position`属性的值实现随机读写的功能。\n\n`ByteArray`还提供了两个属性指示其长度。其中`bytesAvailable`表示当前位置（`position`）到结尾处还剩多少个字节，而`length`则表示整个`ByteArray`的长度。\n\n使用`ByteArray`的`readObject`和`writeObject`还可以方便地把一个对象序列化到一个`ByteArray`或者从一个`ByteArray`中反序列化出来：\n\n    var myXML:XML = {...};\n    bytes.writeObject(myXML); \n    bytes.position = 0;        //reset position to beginning \n    bytes.compress(CompressionAlgorithm.DEFLATE);    // compress ByteArray \n    writeBytesToFile(\"order.xml\", bytes); \n\n这样就把`obj`写入到一个`ByteArray`里面了，可以把它存到一个文件或者提交到服务端持久话起来。从文件或者服务端读取出来以后：\n\n    readFileIntoByteArray(\"order\", inBytes);\n    inBytes.position = 0; // reset position to beginning \n    inBytes.uncompress(CompressionAlgorithm.DEFLATE); \n    inBytes.position = 0;    //reset position to beginning \n    // read XML Object \n    var orderXML:XML = inBytes.readObject(); \n","htmlText":"<p>在Flash中，我们可以使用<code>ByteArray</code>来操作二进制数据：</p>\n<pre><code>var stream:ByteArray = new ByteArray();\n</code></pre><p>使用<code>ByteArray</code>，可以把数据按照流的形式组织成一个<code>ByteArray</code>。<code>ByteArray</code>提供了<code>readXXX</code>和对应的<code>writeXXX</code>方法，按照同样调用顺序把数据读取和写入到<code>ByteArray</code>中，实现对数据的序列化。例如，我们可以这么写：</p>\n<pre><code>bytes.writeUTFBytes(&quot;someString&quot;);\nbytes.writeFloat(1);\n</code></pre><p>可以这么读：</p>\n<pre><code>var str:String = bytes.readUTFBytes();\nvar float:Float = bytes.readFloat();\n</code></pre><p><code>ByteArray</code>的<code>position</code>属性记录当前指针的位置，初始值为<code>0</code>。当读取或者写入<code>ByteArray</code>的时候，会更新<code>position</code>属性以指向上次读取或者写入字节后的位置：</p>\n<pre><code>bytes.writeUTFBytes(&quot;Hello World!&quot;);\n// position + 12\n</code></pre><p>可以更改这个<code>position</code>属性的值实现随机读写的功能。</p>\n<p><code>ByteArray</code>还提供了两个属性指示其长度。其中<code>bytesAvailable</code>表示当前位置（<code>position</code>）到结尾处还剩多少个字节，而<code>length</code>则表示整个<code>ByteArray</code>的长度。</p>\n<p>使用<code>ByteArray</code>的<code>readObject</code>和<code>writeObject</code>还可以方便地把一个对象序列化到一个<code>ByteArray</code>或者从一个<code>ByteArray</code>中反序列化出来：</p>\n<pre><code>var myXML:XML = {...};\nbytes.writeObject(myXML); \nbytes.position = 0;        //reset position to beginning \nbytes.compress(CompressionAlgorithm.DEFLATE);    // compress ByteArray \nwriteBytesToFile(&quot;order.xml&quot;, bytes); \n</code></pre><p>这样就把<code>obj</code>写入到一个<code>ByteArray</code>里面了，可以把它存到一个文件或者提交到服务端持久话起来。从文件或者服务端读取出来以后：</p>\n<pre><code>readFileIntoByteArray(&quot;order&quot;, inBytes);\ninBytes.position = 0; // reset position to beginning \ninBytes.uncompress(CompressionAlgorithm.DEFLATE); \ninBytes.position = 0;    //reset position to beginning \n// read XML Object \nvar orderXML:XML = inBytes.readObject(); \n</code></pre>","summaryMarkdownText":"\n\n\n在Flash中，我们可以使用`ByteArray`来操作二进制数据：\n\n    var stream:ByteArray = new ByteArray();\n\n使用`ByteArray`，可以把数据按照流的形式组织成一个`ByteArray`。`ByteArray`提供了`readXXX`和对应的`writeXXX`方法，按照同样调用顺序把数据读取和写入到`ByteArray`中，实现对数据的序列化。例如，我们可以这么写：\n\n    bytes.writeUTFBytes(\"someString\");\n    bytes.writeFloat(1);\n\n可以这么读：\n\n    var str:String = bytes.readUTFBytes();\n    var float:Float = bytes.readFloat();\n\n`ByteArray`的`position`属性记录当前指针的位置，初始值为`0`。当读取或者写入`ByteArray`的时候，会更新`position`属性以指向上次读取或者写入字节后的位置：\n\n    bytes.writeUTFBytes(\"Hello World!\");\n\t// position + 12\n\n可以更改这个`position`属性的值实现随机读写的功能。\n\n`ByteArray`还提供了两个属性指示其长度。其中`bytesAvailable`表示当前位置（`position`）到结尾处还剩多少个字节，而`length`则表示整个`ByteArray`的长度。","summaryHtmlText":"<p>在Flash中，我们可以使用<code>ByteArray</code>来操作二进制数据：</p>\n<pre><code>var stream:ByteArray = new ByteArray();\n</code></pre><p>使用<code>ByteArray</code>，可以把数据按照流的形式组织成一个<code>ByteArray</code>。<code>ByteArray</code>提供了<code>readXXX</code>和对应的<code>writeXXX</code>方法，按照同样调用顺序把数据读取和写入到<code>ByteArray</code>中，实现对数据的序列化。例如，我们可以这么写：</p>\n<pre><code>bytes.writeUTFBytes(&quot;someString&quot;);\nbytes.writeFloat(1);\n</code></pre><p>可以这么读：</p>\n<pre><code>var str:String = bytes.readUTFBytes();\nvar float:Float = bytes.readFloat();\n</code></pre><p><code>ByteArray</code>的<code>position</code>属性记录当前指针的位置，初始值为<code>0</code>。当读取或者写入<code>ByteArray</code>的时候，会更新<code>position</code>属性以指向上次读取或者写入字节后的位置：</p>\n<pre><code>bytes.writeUTFBytes(&quot;Hello World!&quot;);\n// position + 12\n</code></pre><p>可以更改这个<code>position</code>属性的值实现随机读写的功能。</p>\n<p><code>ByteArray</code>还提供了两个属性指示其长度。其中<code>bytesAvailable</code>表示当前位置（<code>position</code>）到结尾处还剩多少个字节，而<code>length</code>则表示整个<code>ByteArray</code>的长度。</p>\n"}