{"year":"2013","month":"11","day":"24","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/11/24/hp-html-collections.html","fileName":"hp-html-collections","layout":"post","title":"High Performance JavaScript 读书笔记之 访问和修改DOM（二）","description":"","tags":["JavaScript"],"markdownText":"\n\n\n今天讨论一下`HTMLCollection`。`HTMLCollection`是一个类似数组的东西，里面包含了一组DOM对象。下面的API返回的结果都是一个`HTMLCollection`：\n\n1. `document.getElementsByName`。\n2. `document.getElementsByClassName`。\n3. `document.getElementsByTagName`。\n\n而下面的这些`document`的属性也会返回一个`HTMLCollection`：\n\n1. `document.images`，返回文档中所有`img`。\n2. `document.links`，返回文档中所有带`href`特性的`a`。\n3. `document.forms`，返回文档中所有`form`。\n4. `document.forms[0].elements`，返回第一个表单中的所有表单域。\n\n`HTMLCollection`不是数组，所以它没有`push`或者`slice`等方法。但是它有`length`属性，也可以通过下标访问，所以它是一个“类数组”。值得注意的是，`HTMLCollection`是“活”的，即在访问这个集合的时候，该集合的状态是当前文档的状态。例如这样的代码可能会进入一个死循环：\n\n    var alldivs = document.getElementsByTagName(\"div\");\n    for (var i = 0; i < alldivs.length; i++) {\n      document.body.appendChild(\n        document.createElement(\"div\"));\n    }\n\n由于在循环中不断加入`div`，导致`alldiv.length`不断被增大，退出条件永远都不会成立。\n\n除了这些逻辑上的问题，每次去访问这个集合的时候，浏览器都需要在文档中重新查询，这样会导致性能问题。为了防止这种查询，在进行DOM操作之前，我们可以先用一个数组缓存`HTMLCollection`的内容：\n\n    for(var i = 0, a = [], len = alldivs.length; i < len; i++) {\n      a[i] = alldivs[i];\n    }\n\n操作`a`就可以避免每次去查询文档。更简单的办法就是用一个变量去记录`length`属性，防止每次访问`length`的时候浏览器重新查询文档内容。\n","htmlText":"<p>今天讨论一下<code>HTMLCollection</code>。<code>HTMLCollection</code>是一个类似数组的东西，里面包含了一组DOM对象。下面的API返回的结果都是一个<code>HTMLCollection</code>：</p>\n<ol>\n<li><code>document.getElementsByName</code>。</li>\n<li><code>document.getElementsByClassName</code>。</li>\n<li><code>document.getElementsByTagName</code>。</li>\n</ol>\n<p>而下面的这些<code>document</code>的属性也会返回一个<code>HTMLCollection</code>：</p>\n<ol>\n<li><code>document.images</code>，返回文档中所有<code>img</code>。</li>\n<li><code>document.links</code>，返回文档中所有带<code>href</code>特性的<code>a</code>。</li>\n<li><code>document.forms</code>，返回文档中所有<code>form</code>。</li>\n<li><code>document.forms[0].elements</code>，返回第一个表单中的所有表单域。</li>\n</ol>\n<p><code>HTMLCollection</code>不是数组，所以它没有<code>push</code>或者<code>slice</code>等方法。但是它有<code>length</code>属性，也可以通过下标访问，所以它是一个“类数组”。值得注意的是，<code>HTMLCollection</code>是“活”的，即在访问这个集合的时候，该集合的状态是当前文档的状态。例如这样的代码可能会进入一个死循环：</p>\n<pre><code>var alldivs = document.getElementsByTagName(&quot;div&quot;);\nfor (var i = 0; i &lt; alldivs.length; i++) {\n  document.body.appendChild(\n    document.createElement(&quot;div&quot;));\n}\n</code></pre><p>由于在循环中不断加入<code>div</code>，导致<code>alldiv.length</code>不断被增大，退出条件永远都不会成立。</p>\n<p>除了这些逻辑上的问题，每次去访问这个集合的时候，浏览器都需要在文档中重新查询，这样会导致性能问题。为了防止这种查询，在进行DOM操作之前，我们可以先用一个数组缓存<code>HTMLCollection</code>的内容：</p>\n<pre><code>for(var i = 0, a = [], len = alldivs.length; i &lt; len; i++) {\n  a[i] = alldivs[i];\n}\n</code></pre><p>操作<code>a</code>就可以避免每次去查询文档。更简单的办法就是用一个变量去记录<code>length</code>属性，防止每次访问<code>length</code>的时候浏览器重新查询文档内容。</p>\n","summaryMarkdownText":"\n\n\n今天讨论一下`HTMLCollection`。`HTMLCollection`是一个类似数组的东西，里面包含了一组DOM对象。下面的API返回的结果都是一个`HTMLCollection`：\n\n1. `document.getElementsByName`。\n2. `document.getElementsByClassName`。\n3. `document.getElementsByTagName`。\n\n而下面的这些`document`的属性也会返回一个`HTMLCollection`：\n\n1. `document.images`，返回文档中所有`img`。\n2. `document.links`，返回文档中所有带`href`特性的`a`。\n3. `document.forms`，返回文档中所有`form`。\n4. `document.forms[0].elements`，返回第一个表单中的所有表单域。\n\n`HTMLCollection`不是数组，所以它没有`push`或者`slice`等方法。但是它有`length`属性，也可以通过下标访问，所以它是一个“类数组”。值得注意的是，`HTMLCollection`是“活”的，即在访问这个集合的时候，该集合的状态是当前文档的状态。例如这样的代码可能会进入一个死循环：\n\n    var alldivs = document.getElementsByTagName(\"div\");\n    for (var i = 0; i < alldivs.length; i++) {\n      document.body.appendChild(\n        document.createElement(\"div\"));\n    }\n\n由于在循环中不断加入`div`，导致`alldiv.length`不断被增大，退出条件永远都不会成立。","summaryHtmlText":"<p>今天讨论一下<code>HTMLCollection</code>。<code>HTMLCollection</code>是一个类似数组的东西，里面包含了一组DOM对象。下面的API返回的结果都是一个<code>HTMLCollection</code>：</p>\n<ol>\n<li><code>document.getElementsByName</code>。</li>\n<li><code>document.getElementsByClassName</code>。</li>\n<li><code>document.getElementsByTagName</code>。</li>\n</ol>\n<p>而下面的这些<code>document</code>的属性也会返回一个<code>HTMLCollection</code>：</p>\n<ol>\n<li><code>document.images</code>，返回文档中所有<code>img</code>。</li>\n<li><code>document.links</code>，返回文档中所有带<code>href</code>特性的<code>a</code>。</li>\n<li><code>document.forms</code>，返回文档中所有<code>form</code>。</li>\n<li><code>document.forms[0].elements</code>，返回第一个表单中的所有表单域。</li>\n</ol>\n<p><code>HTMLCollection</code>不是数组，所以它没有<code>push</code>或者<code>slice</code>等方法。但是它有<code>length</code>属性，也可以通过下标访问，所以它是一个“类数组”。值得注意的是，<code>HTMLCollection</code>是“活”的，即在访问这个集合的时候，该集合的状态是当前文档的状态。例如这样的代码可能会进入一个死循环：</p>\n<pre><code>var alldivs = document.getElementsByTagName(&quot;div&quot;);\nfor (var i = 0; i &lt; alldivs.length; i++) {\n  document.body.appendChild(\n    document.createElement(&quot;div&quot;));\n}\n</code></pre><p>由于在循环中不断加入<code>div</code>，导致<code>alldiv.length</code>不断被增大，退出条件永远都不会成立。</p>\n"}