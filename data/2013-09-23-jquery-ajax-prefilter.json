{"year":"2013","month":"09","day":"23","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/09/23/jquery-ajax-prefilter.html","fileName":"jquery-ajax-prefilter","layout":"post","title":"jQuery扫盲之jQuery.ajaxPrefilter","description":"","tags":["JavaScript","jQuery"],"markdownText":"\n\n\n除了`jQuery.ajax`这个比较底层的接口之外，jQuery还提供了其他的接口供我们去控制Ajax的行为。今天就先讨论一下`jQuery.ajaxPrefilter`。\n\n> Handle custom Ajax options or modify existing options before each request is sent and before they are processed by $.ajax().\n\n在请求被`jQuery.ajax`处理之前，可以通过这个接口去干涉每一个请求的配置。这个方法接受两个参数：\n\n1. `dataType`，可选的，如果提供则需要请求配置中的`dataType`是否匹配这个参数指定的值。\n2. `handler`，在`jQuery.ajax`处理之前经过的过滤器，接受三个参数：\n    1. `options`，Ajax请求的配置。\n    2. `originalOptions`，调用`jQuery.ajax`时传入的配置。这个配置是没有`ajaxSetting`中的默认配置的。\n    3. `jqXHR`，这个请求的jqXHR对象。\n\n通过这个方法，可以做一些有趣的东西，例如jQuery文档中的这个例子：\n\n    var currentRequests = {};\n \n    $.ajaxPrefilter(function( options, originalOptions, jqXHR ) {\n      if ( options.abortOnRetry ) {\n        if ( currentRequests[ options.url ] ) {\n          currentRequests[ options.url ].abort();\n        }\n        currentRequests[ options.url ] = jqXHR;\n      }\n    });\n\n例子取消了重复发送的Ajax请求，这个在我们日常测试场景中也非常常见，例如疯狂点击会发送请求的按钮。\n\n修改过滤器传入的第一个参数后，`jQuery.ajax`处理的就是我们修改过之后的参数了。以下是一个简单的URL重定向功能：\n\n    $.ajaxPrefilter(function( options ) {\n      if ( options.crossDomain ) {\n        options.url = \"http://mydomain.net/proxy/\" + encodeURIComponent( options.url );\n        options.crossDomain = false;\n      }\n    });\n\n当传入第一个参数的时候，对应的过滤器只会在特定的数据类型中触发。可以传入多个数据类型，中间用空格隔开。\n\n过滤器返回的值可以修改请求的数据类型，例如：\n\n    $.ajaxPrefilter(function( options ) {\n      if ( isActuallyScript( options.url ) ) {\n        return \"script\";\n      }\n    });\n\n当`isActuallyScript`返回`true`的时候，这个请求返回的数据类型就是`script`。这样可以保证符合规则的请求都会被当成脚本处理哦！\n","htmlText":"<p>除了<code>jQuery.ajax</code>这个比较底层的接口之外，jQuery还提供了其他的接口供我们去控制Ajax的行为。今天就先讨论一下<code>jQuery.ajaxPrefilter</code>。</p>\n<blockquote>\n<p>Handle custom Ajax options or modify existing options before each request is sent and before they are processed by $.ajax().</p>\n</blockquote>\n<p>在请求被<code>jQuery.ajax</code>处理之前，可以通过这个接口去干涉每一个请求的配置。这个方法接受两个参数：</p>\n<ol>\n<li><code>dataType</code>，可选的，如果提供则需要请求配置中的<code>dataType</code>是否匹配这个参数指定的值。</li>\n<li><code>handler</code>，在<code>jQuery.ajax</code>处理之前经过的过滤器，接受三个参数：<ol>\n<li><code>options</code>，Ajax请求的配置。</li>\n<li><code>originalOptions</code>，调用<code>jQuery.ajax</code>时传入的配置。这个配置是没有<code>ajaxSetting</code>中的默认配置的。</li>\n<li><code>jqXHR</code>，这个请求的jqXHR对象。</li>\n</ol>\n</li>\n</ol>\n<p>通过这个方法，可以做一些有趣的东西，例如jQuery文档中的这个例子：</p>\n<pre><code>var currentRequests = {};\n\n$.ajaxPrefilter(function( options, originalOptions, jqXHR ) {\n  if ( options.abortOnRetry ) {\n    if ( currentRequests[ options.url ] ) {\n      currentRequests[ options.url ].abort();\n    }\n    currentRequests[ options.url ] = jqXHR;\n  }\n});\n</code></pre><p>例子取消了重复发送的Ajax请求，这个在我们日常测试场景中也非常常见，例如疯狂点击会发送请求的按钮。</p>\n<p>修改过滤器传入的第一个参数后，<code>jQuery.ajax</code>处理的就是我们修改过之后的参数了。以下是一个简单的URL重定向功能：</p>\n<pre><code>$.ajaxPrefilter(function( options ) {\n  if ( options.crossDomain ) {\n    options.url = &quot;http://mydomain.net/proxy/&quot; + encodeURIComponent( options.url );\n    options.crossDomain = false;\n  }\n});\n</code></pre><p>当传入第一个参数的时候，对应的过滤器只会在特定的数据类型中触发。可以传入多个数据类型，中间用空格隔开。</p>\n<p>过滤器返回的值可以修改请求的数据类型，例如：</p>\n<pre><code>$.ajaxPrefilter(function( options ) {\n  if ( isActuallyScript( options.url ) ) {\n    return &quot;script&quot;;\n  }\n});\n</code></pre><p>当<code>isActuallyScript</code>返回<code>true</code>的时候，这个请求返回的数据类型就是<code>script</code>。这样可以保证符合规则的请求都会被当成脚本处理哦！</p>\n","summaryMarkdownText":"\n\n\n除了`jQuery.ajax`这个比较底层的接口之外，jQuery还提供了其他的接口供我们去控制Ajax的行为。今天就先讨论一下`jQuery.ajaxPrefilter`。\n\n> Handle custom Ajax options or modify existing options before each request is sent and before they are processed by $.ajax().\n\n在请求被`jQuery.ajax`处理之前，可以通过这个接口去干涉每一个请求的配置。这个方法接受两个参数：\n\n1. `dataType`，可选的，如果提供则需要请求配置中的`dataType`是否匹配这个参数指定的值。\n2. `handler`，在`jQuery.ajax`处理之前经过的过滤器，接受三个参数：\n    1. `options`，Ajax请求的配置。\n    2. `originalOptions`，调用`jQuery.ajax`时传入的配置。这个配置是没有`ajaxSetting`中的默认配置的。\n    3. `jqXHR`，这个请求的jqXHR对象。\n\n通过这个方法，可以做一些有趣的东西，例如jQuery文档中的这个例子：\n\n    var currentRequests = {};\n \n    $.ajaxPrefilter(function( options, originalOptions, jqXHR ) {\n      if ( options.abortOnRetry ) {\n        if ( currentRequests[ options.url ] ) {\n          currentRequests[ options.url ].abort();\n        }\n        currentRequests[ options.url ] = jqXHR;","summaryHtmlText":"<p>除了<code>jQuery.ajax</code>这个比较底层的接口之外，jQuery还提供了其他的接口供我们去控制Ajax的行为。今天就先讨论一下<code>jQuery.ajaxPrefilter</code>。</p>\n<blockquote>\n<p>Handle custom Ajax options or modify existing options before each request is sent and before they are processed by $.ajax().</p>\n</blockquote>\n<p>在请求被<code>jQuery.ajax</code>处理之前，可以通过这个接口去干涉每一个请求的配置。这个方法接受两个参数：</p>\n<ol>\n<li><code>dataType</code>，可选的，如果提供则需要请求配置中的<code>dataType</code>是否匹配这个参数指定的值。</li>\n<li><code>handler</code>，在<code>jQuery.ajax</code>处理之前经过的过滤器，接受三个参数：<ol>\n<li><code>options</code>，Ajax请求的配置。</li>\n<li><code>originalOptions</code>，调用<code>jQuery.ajax</code>时传入的配置。这个配置是没有<code>ajaxSetting</code>中的默认配置的。</li>\n<li><code>jqXHR</code>，这个请求的jqXHR对象。</li>\n</ol>\n</li>\n</ol>\n<p>通过这个方法，可以做一些有趣的东西，例如jQuery文档中的这个例子：</p>\n<pre><code>var currentRequests = {};\n\n$.ajaxPrefilter(function( options, originalOptions, jqXHR ) {\n  if ( options.abortOnRetry ) {\n    if ( currentRequests[ options.url ] ) {\n      currentRequests[ options.url ].abort();\n    }\n    currentRequests[ options.url ] = jqXHR;\n</code></pre>"}