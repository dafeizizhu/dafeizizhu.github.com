{"year":"2013","month":"10","day":"04","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/10/04/javascript-inject-html-to-dom-3.html","fileName":"javascript-inject-html-to-dom-3","layout":"post","title":"Secrets of the JavaScript Ninja 读书笔记之 执行内联脚本","description":"","tags":["JavaScript"],"markdownText":"\n\n\n执行HTML字符串中的内联脚本也是一个非常常见的需求，特别是服务器返回的HTML字符串，其中包括一些有关于这段HTML字符串的行为，需要内联在这些HTML字符串中一并传到前端。执行这些内联的脚本大概可以分成两个步骤。\n\n### 收集内联脚本\n____\n\n无论是直接内联的脚本，还是外部引入的脚本，都是用`script`标签的形式引入到HTML中。所以，假设现在已经从HTML字符串中生成了一个DOM的集合`ret`，从该集合收集内联脚本可以分成以下几个步骤：\n\n1. a遍历这个集合。\n2. a如果是`script`，而且`type=\"text/javascript\"`，则认为这个是内联脚本，放入到结果集中。\n3. a如果是普通的DOM，则调用该DOM对象的`getElementsByTagName`就可以获取到这个对象中的`script`标签。\n\n当收集完所有内联的脚本之后，并且DOM已经被插入到文档中，就可以执行这些内联的脚本了。\n\n### 执行内联脚本\n____\n\n这些内联的脚本要在全局中执行，即所有在最外边定义的变量和方法都是全局的。这里使用动态插入`script`的方式来执行这些代码：\n\n    function globalEval(data) {\n      data = data.replace(/^\\s+|\\s+$/g, \"\");\n      if (data) {\n        var head = document.getElementsByTagName(\"head\")[0] ||\n            document.documentElement,\n        script = document.createElement(\"script\");\n        script.type = \"text/javascript\";\n        script.text = data;\n        head.insertBefore(script, head.firstChild);\n        head.removeChild(script);\n      }\n    }\n\n这里只执行了那些直接写在`script`标签里面的代码，那些外部代码需要根据`src`，先去获取脚本的内容，在执行它们。这里是使用jQuery实现的一个例子：\n\n    function evalScript(elem) {\n      if (elem.src)\n        jQuery.ajax({\n          url:elem.src,\n          async:false,\n          dataType:\"script\"\n        });\n      else\n        jQuery.globalEval(elem.text || \"\");\n      if (elem.parentNode)\n        elem.parentNode.removeChild(elem);\n    }\n\n这里注意的是我们加入到文档中的任何元素（例如`script`标签），都要在脚本执行完毕后删除。\n","htmlText":"<p>执行HTML字符串中的内联脚本也是一个非常常见的需求，特别是服务器返回的HTML字符串，其中包括一些有关于这段HTML字符串的行为，需要内联在这些HTML字符串中一并传到前端。执行这些内联的脚本大概可以分成两个步骤。</p>\n<h3 id=\"-\">收集内联脚本</h3>\n<hr>\n<p>无论是直接内联的脚本，还是外部引入的脚本，都是用<code>script</code>标签的形式引入到HTML中。所以，假设现在已经从HTML字符串中生成了一个DOM的集合<code>ret</code>，从该集合收集内联脚本可以分成以下几个步骤：</p>\n<ol>\n<li>a遍历这个集合。</li>\n<li>a如果是<code>script</code>，而且<code>type=&quot;text/javascript&quot;</code>，则认为这个是内联脚本，放入到结果集中。</li>\n<li>a如果是普通的DOM，则调用该DOM对象的<code>getElementsByTagName</code>就可以获取到这个对象中的<code>script</code>标签。</li>\n</ol>\n<p>当收集完所有内联的脚本之后，并且DOM已经被插入到文档中，就可以执行这些内联的脚本了。</p>\n<h3 id=\"-\">执行内联脚本</h3>\n<hr>\n<p>这些内联的脚本要在全局中执行，即所有在最外边定义的变量和方法都是全局的。这里使用动态插入<code>script</code>的方式来执行这些代码：</p>\n<pre><code>function globalEval(data) {\n  data = data.replace(/^\\s+|\\s+$/g, &quot;&quot;);\n  if (data) {\n    var head = document.getElementsByTagName(&quot;head&quot;)[0] ||\n        document.documentElement,\n    script = document.createElement(&quot;script&quot;);\n    script.type = &quot;text/javascript&quot;;\n    script.text = data;\n    head.insertBefore(script, head.firstChild);\n    head.removeChild(script);\n  }\n}\n</code></pre><p>这里只执行了那些直接写在<code>script</code>标签里面的代码，那些外部代码需要根据<code>src</code>，先去获取脚本的内容，在执行它们。这里是使用jQuery实现的一个例子：</p>\n<pre><code>function evalScript(elem) {\n  if (elem.src)\n    jQuery.ajax({\n      url:elem.src,\n      async:false,\n      dataType:&quot;script&quot;\n    });\n  else\n    jQuery.globalEval(elem.text || &quot;&quot;);\n  if (elem.parentNode)\n    elem.parentNode.removeChild(elem);\n}\n</code></pre><p>这里注意的是我们加入到文档中的任何元素（例如<code>script</code>标签），都要在脚本执行完毕后删除。</p>\n","summaryMarkdownText":"\n\n\n执行HTML字符串中的内联脚本也是一个非常常见的需求，特别是服务器返回的HTML字符串，其中包括一些有关于这段HTML字符串的行为，需要内联在这些HTML字符串中一并传到前端。执行这些内联的脚本大概可以分成两个步骤。\n\n### 收集内联脚本\n____\n\n无论是直接内联的脚本，还是外部引入的脚本，都是用`script`标签的形式引入到HTML中。所以，假设现在已经从HTML字符串中生成了一个DOM的集合`ret`，从该集合收集内联脚本可以分成以下几个步骤：\n\n1. a遍历这个集合。\n2. a如果是`script`，而且`type=\"text/javascript\"`，则认为这个是内联脚本，放入到结果集中。\n3. a如果是普通的DOM，则调用该DOM对象的`getElementsByTagName`就可以获取到这个对象中的`script`标签。\n\n当收集完所有内联的脚本之后，并且DOM已经被插入到文档中，就可以执行这些内联的脚本了。\n\n### 执行内联脚本\n____\n\n这些内联的脚本要在全局中执行，即所有在最外边定义的变量和方法都是全局的。这里使用动态插入`script`的方式来执行这些代码：\n\n    function globalEval(data) {\n      data = data.replace(/^\\s+|\\s+$/g, \"\");\n      if (data) {\n        var head = document.getElementsByTagName(\"head\")[0] ||","summaryHtmlText":"<p>执行HTML字符串中的内联脚本也是一个非常常见的需求，特别是服务器返回的HTML字符串，其中包括一些有关于这段HTML字符串的行为，需要内联在这些HTML字符串中一并传到前端。执行这些内联的脚本大概可以分成两个步骤。</p>\n<h3 id=\"-\">收集内联脚本</h3>\n<hr>\n<p>无论是直接内联的脚本，还是外部引入的脚本，都是用<code>script</code>标签的形式引入到HTML中。所以，假设现在已经从HTML字符串中生成了一个DOM的集合<code>ret</code>，从该集合收集内联脚本可以分成以下几个步骤：</p>\n<ol>\n<li>a遍历这个集合。</li>\n<li>a如果是<code>script</code>，而且<code>type=&quot;text/javascript&quot;</code>，则认为这个是内联脚本，放入到结果集中。</li>\n<li>a如果是普通的DOM，则调用该DOM对象的<code>getElementsByTagName</code>就可以获取到这个对象中的<code>script</code>标签。</li>\n</ol>\n<p>当收集完所有内联的脚本之后，并且DOM已经被插入到文档中，就可以执行这些内联的脚本了。</p>\n<h3 id=\"-\">执行内联脚本</h3>\n<hr>\n<p>这些内联的脚本要在全局中执行，即所有在最外边定义的变量和方法都是全局的。这里使用动态插入<code>script</code>的方式来执行这些代码：</p>\n<pre><code>function globalEval(data) {\n  data = data.replace(/^\\s+|\\s+$/g, &quot;&quot;);\n  if (data) {\n    var head = document.getElementsByTagName(&quot;head&quot;)[0] ||\n</code></pre>"}