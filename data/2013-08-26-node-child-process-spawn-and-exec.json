{"year":"2013","month":"08","day":"26","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/08/26/node-child-process-spawn-and-exec.html","fileName":"node-child-process-spawn-and-exec","layout":"post","title":"Node中spawn和exec的区别","description":"","tags":["node"],"markdownText":"\n\n\n今天试着结合SPM和Grunt来做项目的构建，在Node中使用子进程调用SPM命令的时候，看文档先用了`spawn`，发现老是抛出一个错误。后来使用`exec`就没有什么问题。这两个方法都可以在Node中创建一个子进程执行一些操作系统的命令（bat或者shell脚本），究竟这两者有什么不一样呢？\n\n### child_process.spawn\n____\n\n`spawn`应该是创建子进程的一个基本的方法。该方法接受三个参数：\n\n1. `command`，表示要执行命令的字符串。\n2. `args`，表示执行命令的命令行参数，如果不提供默认值是一个空数组。\n3. `options`，可选配置。\n\n其中`options`可以配置的属性有：\n\n1. `cwd`，配置该命令执行的目录。\n2. `stdio`，配置子进程跟父进程直接的输入输出方式。\n3. `env`，配额子进程中的环境变量。\n4. `detached`，配置子进程是否独立的。默认情况下父进程是需要等待子进程结束才能结束，当这个配置为`true`时，父进程不需要等待子进程结束，子进程会在后台继续执行。（子进程使用了父进程的io则这个配置始终都是默认情况。）\n5. `uid`，配置执行子进程的用户id。\n6. `gid`，配置执行子进程的用户组id。\n\n`options`的默认值为：\n\n    {\n      cwd: undefined,\n      env: process.env\n    }\n\n执行该方法后会返回一个`ChildProcess`实例。\n\n### ChildProcess\n____\n\n这个类的实例有以下几个事件：\n\n1. `error`，不能派生子进程、不能杀死子进程或者`sendMessage`失败等。\n2. `exit`，子进程正常退出或者父进程发送消息主动结束子进程。\n3. `close`，同`exit`，不一样的是`close`会等待使用的`stdio`全部结束后才会触发（多个子进程可能共享`stdio`）。\n4. `disconnect`，再调用`disconnect`方法之后触发，触发之后不能再发送消息。\n5. `message`，接收到消息的时候触发。\n\n这个对象还有几个关于标准输入输出的流：`stdin`、`stdout`、`stderr`，分别对应输入、输出和错误流，可以监听这些流的`data`事件捕获子进程的标准输入输出（一般是控制台的输入输出流），如：\n\n    var spawn = require('child_process').spawn,\n    ls = spawn('ls', ['-lh', '/usr']);\n\n    ls.stdout.on('data', function (data) {\n      console.log('stdout: ' + data);\n    });\n\n### child_process.exec\n____\n\n看Node上面的文档，容易看出来`exec`是`spawn`的简化版本。该方法也接受三个参数：\n\n1. `command`，要执行的命令的字符串。\n2. `options`，可选的配置。\n3. `callback`，一个回调函数。当子进程结束的时候会被调用。\n\n`options`跟`spawn`类似，有`cwd`、`env`，其他的配置如下：\n\n1. `encoding`，输出流的编码，默认是`utf8`。\n2. `timeout`，子进程执行的超时时间，默认是`0`,表示没有超时时间。\n3. `maxBuffer`，输出流的缓冲区大小，默认是`200×1024`，注意，**当输出的内容超过缓冲区的大小子进程会被杀掉**。\n4. `killSignal`，子进程被杀的信号，默认是`SIGTERM`。\n\n其中回调函数有三个输入参数：`error`、`stdout`和`error`，分别对应错误输出、正常输出和执行的错误对象。由于这个回调函数封装了两个输出的内容和错误对象，有大部分的场景都可以不去使用返回的`ChildProcess`对象，直接使用这个回调函数即可。\n\n### 陷阱\n____\n\n查看了一些资料，发现这两者之间还有一些区别。\n\n> 大家都知道在linux下, ls命令对应的是一个文件, 而在windows下是做为cmd的内置命令的. 所以像我那样写是会报错.\n\n> 所以想使用内置命令可以直接使用exec或者把spawn改成spawn(\"cmd.exe\",[\"\\s\", \"\\c\", \"dir\"]);\n\n> 总结起来就是spawn是调用一个文件! 不要被docs上的child_process.spawn(command, [args], [options])中的command给骗了 \n\n总结，在windows下面就是坑！\n","htmlText":"<p>今天试着结合SPM和Grunt来做项目的构建，在Node中使用子进程调用SPM命令的时候，看文档先用了<code>spawn</code>，发现老是抛出一个错误。后来使用<code>exec</code>就没有什么问题。这两个方法都可以在Node中创建一个子进程执行一些操作系统的命令（bat或者shell脚本），究竟这两者有什么不一样呢？</p>\n<h3 id=\"child_process-spawn\">child_process.spawn</h3>\n<hr>\n<p><code>spawn</code>应该是创建子进程的一个基本的方法。该方法接受三个参数：</p>\n<ol>\n<li><code>command</code>，表示要执行命令的字符串。</li>\n<li><code>args</code>，表示执行命令的命令行参数，如果不提供默认值是一个空数组。</li>\n<li><code>options</code>，可选配置。</li>\n</ol>\n<p>其中<code>options</code>可以配置的属性有：</p>\n<ol>\n<li><code>cwd</code>，配置该命令执行的目录。</li>\n<li><code>stdio</code>，配置子进程跟父进程直接的输入输出方式。</li>\n<li><code>env</code>，配额子进程中的环境变量。</li>\n<li><code>detached</code>，配置子进程是否独立的。默认情况下父进程是需要等待子进程结束才能结束，当这个配置为<code>true</code>时，父进程不需要等待子进程结束，子进程会在后台继续执行。（子进程使用了父进程的io则这个配置始终都是默认情况。）</li>\n<li><code>uid</code>，配置执行子进程的用户id。</li>\n<li><code>gid</code>，配置执行子进程的用户组id。</li>\n</ol>\n<p><code>options</code>的默认值为：</p>\n<pre><code>{\n  cwd: undefined,\n  env: process.env\n}\n</code></pre><p>执行该方法后会返回一个<code>ChildProcess</code>实例。</p>\n<h3 id=\"childprocess\">ChildProcess</h3>\n<hr>\n<p>这个类的实例有以下几个事件：</p>\n<ol>\n<li><code>error</code>，不能派生子进程、不能杀死子进程或者<code>sendMessage</code>失败等。</li>\n<li><code>exit</code>，子进程正常退出或者父进程发送消息主动结束子进程。</li>\n<li><code>close</code>，同<code>exit</code>，不一样的是<code>close</code>会等待使用的<code>stdio</code>全部结束后才会触发（多个子进程可能共享<code>stdio</code>）。</li>\n<li><code>disconnect</code>，再调用<code>disconnect</code>方法之后触发，触发之后不能再发送消息。</li>\n<li><code>message</code>，接收到消息的时候触发。</li>\n</ol>\n<p>这个对象还有几个关于标准输入输出的流：<code>stdin</code>、<code>stdout</code>、<code>stderr</code>，分别对应输入、输出和错误流，可以监听这些流的<code>data</code>事件捕获子进程的标准输入输出（一般是控制台的输入输出流），如：</p>\n<pre><code>var spawn = require(&#39;child_process&#39;).spawn,\nls = spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;/usr&#39;]);\n\nls.stdout.on(&#39;data&#39;, function (data) {\n  console.log(&#39;stdout: &#39; + data);\n});\n</code></pre><h3 id=\"child_process-exec\">child_process.exec</h3>\n<hr>\n<p>看Node上面的文档，容易看出来<code>exec</code>是<code>spawn</code>的简化版本。该方法也接受三个参数：</p>\n<ol>\n<li><code>command</code>，要执行的命令的字符串。</li>\n<li><code>options</code>，可选的配置。</li>\n<li><code>callback</code>，一个回调函数。当子进程结束的时候会被调用。</li>\n</ol>\n<p><code>options</code>跟<code>spawn</code>类似，有<code>cwd</code>、<code>env</code>，其他的配置如下：</p>\n<ol>\n<li><code>encoding</code>，输出流的编码，默认是<code>utf8</code>。</li>\n<li><code>timeout</code>，子进程执行的超时时间，默认是<code>0</code>,表示没有超时时间。</li>\n<li><code>maxBuffer</code>，输出流的缓冲区大小，默认是<code>200×1024</code>，注意，<strong>当输出的内容超过缓冲区的大小子进程会被杀掉</strong>。</li>\n<li><code>killSignal</code>，子进程被杀的信号，默认是<code>SIGTERM</code>。</li>\n</ol>\n<p>其中回调函数有三个输入参数：<code>error</code>、<code>stdout</code>和<code>error</code>，分别对应错误输出、正常输出和执行的错误对象。由于这个回调函数封装了两个输出的内容和错误对象，有大部分的场景都可以不去使用返回的<code>ChildProcess</code>对象，直接使用这个回调函数即可。</p>\n<h3 id=\"-\">陷阱</h3>\n<hr>\n<p>查看了一些资料，发现这两者之间还有一些区别。</p>\n<blockquote>\n<p>大家都知道在linux下, ls命令对应的是一个文件, 而在windows下是做为cmd的内置命令的. 所以像我那样写是会报错.</p>\n<p>所以想使用内置命令可以直接使用exec或者把spawn改成spawn(&quot;cmd.exe&quot;,[&quot;\\s&quot;, &quot;\\c&quot;, &quot;dir&quot;]);</p>\n<p>总结起来就是spawn是调用一个文件! 不要被docs上的child_process.spawn(command, [args], [options])中的command给骗了 </p>\n</blockquote>\n<p>总结，在windows下面就是坑！</p>\n","summaryMarkdownText":"\n\n\n今天试着结合SPM和Grunt来做项目的构建，在Node中使用子进程调用SPM命令的时候，看文档先用了`spawn`，发现老是抛出一个错误。后来使用`exec`就没有什么问题。这两个方法都可以在Node中创建一个子进程执行一些操作系统的命令（bat或者shell脚本），究竟这两者有什么不一样呢？\n\n### child_process.spawn\n____\n\n`spawn`应该是创建子进程的一个基本的方法。该方法接受三个参数：\n\n1. `command`，表示要执行命令的字符串。\n2. `args`，表示执行命令的命令行参数，如果不提供默认值是一个空数组。\n3. `options`，可选配置。\n\n其中`options`可以配置的属性有：\n\n1. `cwd`，配置该命令执行的目录。\n2. `stdio`，配置子进程跟父进程直接的输入输出方式。\n3. `env`，配额子进程中的环境变量。\n4. `detached`，配置子进程是否独立的。默认情况下父进程是需要等待子进程结束才能结束，当这个配置为`true`时，父进程不需要等待子进程结束，子进程会在后台继续执行。（子进程使用了父进程的io则这个配置始终都是默认情况。）\n5. `uid`，配置执行子进程的用户id。\n6. `gid`，配置执行子进程的用户组id。\n\n`options`的默认值为：\n","summaryHtmlText":"<p>今天试着结合SPM和Grunt来做项目的构建，在Node中使用子进程调用SPM命令的时候，看文档先用了<code>spawn</code>，发现老是抛出一个错误。后来使用<code>exec</code>就没有什么问题。这两个方法都可以在Node中创建一个子进程执行一些操作系统的命令（bat或者shell脚本），究竟这两者有什么不一样呢？</p>\n<h3 id=\"child_process-spawn\">child_process.spawn</h3>\n<hr>\n<p><code>spawn</code>应该是创建子进程的一个基本的方法。该方法接受三个参数：</p>\n<ol>\n<li><code>command</code>，表示要执行命令的字符串。</li>\n<li><code>args</code>，表示执行命令的命令行参数，如果不提供默认值是一个空数组。</li>\n<li><code>options</code>，可选配置。</li>\n</ol>\n<p>其中<code>options</code>可以配置的属性有：</p>\n<ol>\n<li><code>cwd</code>，配置该命令执行的目录。</li>\n<li><code>stdio</code>，配置子进程跟父进程直接的输入输出方式。</li>\n<li><code>env</code>，配额子进程中的环境变量。</li>\n<li><code>detached</code>，配置子进程是否独立的。默认情况下父进程是需要等待子进程结束才能结束，当这个配置为<code>true</code>时，父进程不需要等待子进程结束，子进程会在后台继续执行。（子进程使用了父进程的io则这个配置始终都是默认情况。）</li>\n<li><code>uid</code>，配置执行子进程的用户id。</li>\n<li><code>gid</code>，配置执行子进程的用户组id。</li>\n</ol>\n<p><code>options</code>的默认值为：</p>\n"}