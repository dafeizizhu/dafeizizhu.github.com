{"year":"2013","month":"11","day":"02","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/11/02/javascript-parsing-selector.html","fileName":"javascript-parsing-selector","layout":"post","title":"Secrets of the JavaScript Ninja 读书笔记之 解析选择器","description":"","tags":["JavaScript"],"markdownText":"\n\n\n之前的纯JavaScript实现的CSS选择器引擎中，只是简单地使用标签选择器，所以解析起来十分简单，就是按空格`split`就好了。但是，CSS选择器有很多种，例如特性选择器（`[name=\"value\"]`等）就没有办法通过空格去解析。\n\n一个完整的实现需要有很多解析的规则，去处理所有合法的CSS选择器。这时候使用正则表达式就最合适不过了：\n\n    var selector = \"div.class > span:not(:first-child) a[href]\"\n    var chunker = /((?:\\([^\\)]+\\)|\\[[^\\]]+\\]|[^ ,\\(\\[]+)+)(\\s*,\\s*)?/g;\n    var parts = [];\n    chunker.lastIndex = 0;                        \n    while ((m = chunker.exec(selector)) !== null) {     \n      parts.push(m[1]);\n      if (m[2]) {                         \n        extra = RegExp.rightContext;\n        break;\n      }\n    }\n\n使用书中提供的这个正则表达式就可以解析出上面那个这么复杂的选择器了！\n\n这个例子只是完整的实现的其中一部分，还有一些其他我们要支持的CSS选择器需要增加自己的规则。某些选择器引擎使用一个Map把正则表达式映射到一个函数，当一个正则表达式匹配的时候，对应的函数就会执行，解析其中的CSS选择器。\n\n如果大家有兴趣去查看完整的CSS选择器是如何实现的，可以去查看[jQuery的源码](https://github.com/jquery/jquery)。\n","htmlText":"<p>之前的纯JavaScript实现的CSS选择器引擎中，只是简单地使用标签选择器，所以解析起来十分简单，就是按空格<code>split</code>就好了。但是，CSS选择器有很多种，例如特性选择器（<code>[name=&quot;value&quot;]</code>等）就没有办法通过空格去解析。</p>\n<p>一个完整的实现需要有很多解析的规则，去处理所有合法的CSS选择器。这时候使用正则表达式就最合适不过了：</p>\n<pre><code>var selector = &quot;div.class &gt; span:not(:first-child) a[href]&quot;\nvar chunker = /((?:\\([^\\)]+\\)|\\[[^\\]]+\\]|[^ ,\\(\\[]+)+)(\\s*,\\s*)?/g;\nvar parts = [];\nchunker.lastIndex = 0;                        \nwhile ((m = chunker.exec(selector)) !== null) {     \n  parts.push(m[1]);\n  if (m[2]) {                         \n    extra = RegExp.rightContext;\n    break;\n  }\n}\n</code></pre><p>使用书中提供的这个正则表达式就可以解析出上面那个这么复杂的选择器了！</p>\n<p>这个例子只是完整的实现的其中一部分，还有一些其他我们要支持的CSS选择器需要增加自己的规则。某些选择器引擎使用一个Map把正则表达式映射到一个函数，当一个正则表达式匹配的时候，对应的函数就会执行，解析其中的CSS选择器。</p>\n<p>如果大家有兴趣去查看完整的CSS选择器是如何实现的，可以去查看<a href=\"https://github.com/jquery/jquery\">jQuery的源码</a>。</p>\n","summaryMarkdownText":"\n\n\n之前的纯JavaScript实现的CSS选择器引擎中，只是简单地使用标签选择器，所以解析起来十分简单，就是按空格`split`就好了。但是，CSS选择器有很多种，例如特性选择器（`[name=\"value\"]`等）就没有办法通过空格去解析。\n\n一个完整的实现需要有很多解析的规则，去处理所有合法的CSS选择器。这时候使用正则表达式就最合适不过了：\n\n    var selector = \"div.class > span:not(:first-child) a[href]\"\n    var chunker = /((?:\\([^\\)]+\\)|\\[[^\\]]+\\]|[^ ,\\(\\[]+)+)(\\s*,\\s*)?/g;\n    var parts = [];\n    chunker.lastIndex = 0;                        \n    while ((m = chunker.exec(selector)) !== null) {     \n      parts.push(m[1]);\n      if (m[2]) {                         \n        extra = RegExp.rightContext;\n        break;\n      }\n    }\n\n使用书中提供的这个正则表达式就可以解析出上面那个这么复杂的选择器了！\n\n这个例子只是完整的实现的其中一部分，还有一些其他我们要支持的CSS选择器需要增加自己的规则。某些选择器引擎使用一个Map把正则表达式映射到一个函数，当一个正则表达式匹配的时候，对应的函数就会执行，解析其中的CSS选择器。\n\n如果大家有兴趣去查看完整的CSS选择器是如何实现的，可以去查看[jQuery的源码](https://github.com/jquery/jquery)。\n","summaryHtmlText":"<p>之前的纯JavaScript实现的CSS选择器引擎中，只是简单地使用标签选择器，所以解析起来十分简单，就是按空格<code>split</code>就好了。但是，CSS选择器有很多种，例如特性选择器（<code>[name=&quot;value&quot;]</code>等）就没有办法通过空格去解析。</p>\n<p>一个完整的实现需要有很多解析的规则，去处理所有合法的CSS选择器。这时候使用正则表达式就最合适不过了：</p>\n<pre><code>var selector = &quot;div.class &gt; span:not(:first-child) a[href]&quot;\nvar chunker = /((?:\\([^\\)]+\\)|\\[[^\\]]+\\]|[^ ,\\(\\[]+)+)(\\s*,\\s*)?/g;\nvar parts = [];\nchunker.lastIndex = 0;                        \nwhile ((m = chunker.exec(selector)) !== null) {     \n  parts.push(m[1]);\n  if (m[2]) {                         \n    extra = RegExp.rightContext;\n    break;\n  }\n}\n</code></pre><p>使用书中提供的这个正则表达式就可以解析出上面那个这么复杂的选择器了！</p>\n<p>这个例子只是完整的实现的其中一部分，还有一些其他我们要支持的CSS选择器需要增加自己的规则。某些选择器引擎使用一个Map把正则表达式映射到一个函数，当一个正则表达式匹配的时候，对应的函数就会执行，解析其中的CSS选择器。</p>\n<p>如果大家有兴趣去查看完整的CSS选择器是如何实现的，可以去查看<a href=\"https://github.com/jquery/jquery\">jQuery的源码</a>。</p>\n"}