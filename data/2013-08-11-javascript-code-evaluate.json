{"year":"2013","month":"08","day":"11","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/08/11/javascript-code-evaluate.html","fileName":"javascript-code-evaluate","layout":"post","title":"Secrets of the JavaScript Ninja 读书笔记之 执行字符串形式的表达式","description":"","tags":["JavaScript"],"markdownText":"\n\n\n周末还是继续读书笔记。今天讨论的是JavaScript中执行字符串形式的表达式的几种方式。\n\n### eval\n\n这个应该是最简单的执行字符串表达式的方法了。`eval`接受一个参数，就是字符串形式的表达式，并返回最后一条语句的返回结果。比较常见的用法就是把JSON格式的字符串转换成JavaScript的对象：\n\n    var o = eval('({ninja: 1})');\n\n如果把圆括号省略，`o`的值是`undefined`，因为参数语句执行时没有返回任何东西。加上圆括号之后，执行该语句会返回这个对象的值，`o`才能正确赋值。\n\n还有一点需要注意的是`eval`中的语句执行的作用域与上下文与调用`eval`所在的作用域和上下文一致。\n\n### Function构造器\n\nFunction构造器的参数列表是可变的。其中最后一个参数是字符串形式的函数逻辑，前面所有参数声明了构造的函数接受哪些参数，如：\n\n    var add = new Function(\"a\", \"b\", \"return a + b;\");\n\n与`eval`不一样的是，使用Function构造器创建的函数**不会产生闭包**，即不能访问外部函数的变量，如：\n\n    (function () {\n      var a = \"outter\";\n      var test = new Function(\"alert(a);\");\n      test();\n    })();\n\n运行结果[参考这里](http://jsfiddle.net/hdLmt/show/)。运行的时候抛出异常`a is not defined`，因为没有创建闭包，导致`test`内部无法访问外部函数的变量`a`。\n\n### Timer\n\n`setTimeout`和`setInterval`的第一个参数除了可以是函数（无论是函数的引用或者是匿名函数），也可以是一个字符串，表示timer触发时执行的逻辑，如：\n\n    var tick = window.setTimeout('alert(\"Hi!\")',100);\n\n除了十分特殊的需求，一般都不需要这么使用timer。就算是需要运行时动态执行的逻辑，也可以通过以上两种方式创建函数的引用，在把它传入到`setTimeout`或者`setInterval`中。\n\n### 在全局作用域中执行\n\n`eval`执行的代码跟执行`eval`所在的作用域是一致的。而有一些时候需要`eval`在全局作用域中执行。使用动态script标签可以解决以上的问题：\n\n    var head = document.getElementsByTagName(\"head\")[0] ||\n                 document.documentElement,\n        script = document.createElement(\"script\"); \n    script.type = \"text/javascript\";\n    script.text = data;\n    head.appendChild(script);               \n    head.removeChild(script); \n\n在`head`中插入一个`script`元素，设置`type`为JavaScript脚本，把`text`设置成需要执行的字符串形式的代码，然后插入到`head`中，再把它删除。这样，`text`中的代码就会放到全局作用域中执行。\n\n### 安全执行\n\n在运行时环境中执行字符串形式的代码通常都会带来安全性的问题。代码的来源是我们最关心的问题，它是否可信？它是否包含高危的代码，把整个页面弄挂，甚至对后台服务器发起攻击？我们需要一种机制去过滤动态执行的代码，Google的Caja是其中一个方式，让代码安全的执行。其思路大概就是把一段动态的代码编译成另外一段更复杂，更难看的代码，实现相同的功能，又能防止该代码执行一些对页面可能有危害的行为。关于Caja，后面会专门写一篇讲述其原理及其使用方法。\n\n在日常工作中，需要使用动态执行字符串形式的代码场景有限（想必应该是十分高雅的实现……）。但是一旦要使用，记得注意采用哪种方式去执行动态代码，注意作用域以及上下文等细节问题哦亲。\n","htmlText":"<p>周末还是继续读书笔记。今天讨论的是JavaScript中执行字符串形式的表达式的几种方式。</p>\n<h3 id=\"eval\">eval</h3>\n<p>这个应该是最简单的执行字符串表达式的方法了。<code>eval</code>接受一个参数，就是字符串形式的表达式，并返回最后一条语句的返回结果。比较常见的用法就是把JSON格式的字符串转换成JavaScript的对象：</p>\n<pre><code>var o = eval(&#39;({ninja: 1})&#39;);\n</code></pre><p>如果把圆括号省略，<code>o</code>的值是<code>undefined</code>，因为参数语句执行时没有返回任何东西。加上圆括号之后，执行该语句会返回这个对象的值，<code>o</code>才能正确赋值。</p>\n<p>还有一点需要注意的是<code>eval</code>中的语句执行的作用域与上下文与调用<code>eval</code>所在的作用域和上下文一致。</p>\n<h3 id=\"function-\">Function构造器</h3>\n<p>Function构造器的参数列表是可变的。其中最后一个参数是字符串形式的函数逻辑，前面所有参数声明了构造的函数接受哪些参数，如：</p>\n<pre><code>var add = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a + b;&quot;);\n</code></pre><p>与<code>eval</code>不一样的是，使用Function构造器创建的函数<strong>不会产生闭包</strong>，即不能访问外部函数的变量，如：</p>\n<pre><code>(function () {\n  var a = &quot;outter&quot;;\n  var test = new Function(&quot;alert(a);&quot;);\n  test();\n})();\n</code></pre><p>运行结果<a href=\"http://jsfiddle.net/hdLmt/show/\">参考这里</a>。运行的时候抛出异常<code>a is not defined</code>，因为没有创建闭包，导致<code>test</code>内部无法访问外部函数的变量<code>a</code>。</p>\n<h3 id=\"timer\">Timer</h3>\n<p><code>setTimeout</code>和<code>setInterval</code>的第一个参数除了可以是函数（无论是函数的引用或者是匿名函数），也可以是一个字符串，表示timer触发时执行的逻辑，如：</p>\n<pre><code>var tick = window.setTimeout(&#39;alert(&quot;Hi!&quot;)&#39;,100);\n</code></pre><p>除了十分特殊的需求，一般都不需要这么使用timer。就算是需要运行时动态执行的逻辑，也可以通过以上两种方式创建函数的引用，在把它传入到<code>setTimeout</code>或者<code>setInterval</code>中。</p>\n<h3 id=\"-\">在全局作用域中执行</h3>\n<p><code>eval</code>执行的代码跟执行<code>eval</code>所在的作用域是一致的。而有一些时候需要<code>eval</code>在全局作用域中执行。使用动态script标签可以解决以上的问题：</p>\n<pre><code>var head = document.getElementsByTagName(&quot;head&quot;)[0] ||\n             document.documentElement,\n    script = document.createElement(&quot;script&quot;); \nscript.type = &quot;text/javascript&quot;;\nscript.text = data;\nhead.appendChild(script);               \nhead.removeChild(script); \n</code></pre><p>在<code>head</code>中插入一个<code>script</code>元素，设置<code>type</code>为JavaScript脚本，把<code>text</code>设置成需要执行的字符串形式的代码，然后插入到<code>head</code>中，再把它删除。这样，<code>text</code>中的代码就会放到全局作用域中执行。</p>\n<h3 id=\"-\">安全执行</h3>\n<p>在运行时环境中执行字符串形式的代码通常都会带来安全性的问题。代码的来源是我们最关心的问题，它是否可信？它是否包含高危的代码，把整个页面弄挂，甚至对后台服务器发起攻击？我们需要一种机制去过滤动态执行的代码，Google的Caja是其中一个方式，让代码安全的执行。其思路大概就是把一段动态的代码编译成另外一段更复杂，更难看的代码，实现相同的功能，又能防止该代码执行一些对页面可能有危害的行为。关于Caja，后面会专门写一篇讲述其原理及其使用方法。</p>\n<p>在日常工作中，需要使用动态执行字符串形式的代码场景有限（想必应该是十分高雅的实现……）。但是一旦要使用，记得注意采用哪种方式去执行动态代码，注意作用域以及上下文等细节问题哦亲。</p>\n","summaryMarkdownText":"\n\n\n周末还是继续读书笔记。今天讨论的是JavaScript中执行字符串形式的表达式的几种方式。\n\n### eval\n\n这个应该是最简单的执行字符串表达式的方法了。`eval`接受一个参数，就是字符串形式的表达式，并返回最后一条语句的返回结果。比较常见的用法就是把JSON格式的字符串转换成JavaScript的对象：\n\n    var o = eval('({ninja: 1})');\n\n如果把圆括号省略，`o`的值是`undefined`，因为参数语句执行时没有返回任何东西。加上圆括号之后，执行该语句会返回这个对象的值，`o`才能正确赋值。\n\n还有一点需要注意的是`eval`中的语句执行的作用域与上下文与调用`eval`所在的作用域和上下文一致。\n\n### Function构造器\n\nFunction构造器的参数列表是可变的。其中最后一个参数是字符串形式的函数逻辑，前面所有参数声明了构造的函数接受哪些参数，如：\n\n    var add = new Function(\"a\", \"b\", \"return a + b;\");\n\n与`eval`不一样的是，使用Function构造器创建的函数**不会产生闭包**，即不能访问外部函数的变量，如：\n\n    (function () {\n      var a = \"outter\";","summaryHtmlText":"<p>周末还是继续读书笔记。今天讨论的是JavaScript中执行字符串形式的表达式的几种方式。</p>\n<h3 id=\"eval\">eval</h3>\n<p>这个应该是最简单的执行字符串表达式的方法了。<code>eval</code>接受一个参数，就是字符串形式的表达式，并返回最后一条语句的返回结果。比较常见的用法就是把JSON格式的字符串转换成JavaScript的对象：</p>\n<pre><code>var o = eval(&#39;({ninja: 1})&#39;);\n</code></pre><p>如果把圆括号省略，<code>o</code>的值是<code>undefined</code>，因为参数语句执行时没有返回任何东西。加上圆括号之后，执行该语句会返回这个对象的值，<code>o</code>才能正确赋值。</p>\n<p>还有一点需要注意的是<code>eval</code>中的语句执行的作用域与上下文与调用<code>eval</code>所在的作用域和上下文一致。</p>\n<h3 id=\"function-\">Function构造器</h3>\n<p>Function构造器的参数列表是可变的。其中最后一个参数是字符串形式的函数逻辑，前面所有参数声明了构造的函数接受哪些参数，如：</p>\n<pre><code>var add = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a + b;&quot;);\n</code></pre><p>与<code>eval</code>不一样的是，使用Function构造器创建的函数<strong>不会产生闭包</strong>，即不能访问外部函数的变量，如：</p>\n<pre><code>(function () {\n  var a = &quot;outter&quot;;\n</code></pre>"}