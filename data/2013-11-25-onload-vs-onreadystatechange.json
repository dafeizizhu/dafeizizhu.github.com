{"year":"2013","month":"11","day":"25","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/11/25/onload-vs-onreadystatechange.html","fileName":"onload-vs-onreadystatechange","layout":"post","title":"Script标签上的onload和onreadystatechange","description":"","tags":["JavaScript"],"markdownText":"\n\n\n之前做一个效果，涉及到动态加载脚本的问题。这个效果需要做成本地文件直接打开可以看到效果，所以下面的代码在Chrome是会报错的：\n\n    $.getScript(\"./js/dynamic.js\", function () {...});\n\n由于本地文件使用的是`file`协议，而`$.getScript`在这个情况下是使用Ajax去请求脚本的内容，Chrome在使用`file`协议的页面进行Ajax请求时会抛出跨域访问的异常。所以只能用动态插入`script`标签的方式去实现：\n\n\tvar done = false;\n    var head = document.getElementsByTagName(\"head\")[0];\n    var s = document.createElement(\"script\");\n    s.type = \"text/javascript\";\n\ts.onload = s.onreadystatechange = function (evt) {\n      if (!done && (!this.readyState || \n        this.readyState == \"loaded\" ||\n        this.readyState == \"complete\")) {\n        // do something with the script\n        s.onload = s.onreadystatechange = null;\n        head.removeChild(s);\n      }\n    }\n    s.src = \"path/to/script.js\";\n    head.appendChild(s);\n\n在Chrome和FireFox上，`onload`会在脚本加载完之后触发，在回调函数中脚本的内容已经加载完全。而这两个浏览器的`script`标签是不支持`onreadystatechange`事件的。\n\n在IE上比较有趣。IE9两个事件都是支持的，而IE8、7、6则只支持`onreadystatechange`。在`onreadystatechange`事件处理程序中还需要判断`script.readyState`属性。经观察之后发现其实当`loaded`的时候，脚本的内容已经可用了。但是在某些情况下，`loaded`之后脚本的内容还没有完全加载。遇到这些情况只能增加一个`setTimeout`了。实验的代码可以参考下面的例子：\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/8HY6k/2/embedded/js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n","htmlText":"<p>之前做一个效果，涉及到动态加载脚本的问题。这个效果需要做成本地文件直接打开可以看到效果，所以下面的代码在Chrome是会报错的：</p>\n<pre><code>$.getScript(&quot;./js/dynamic.js&quot;, function () {...});\n</code></pre><p>由于本地文件使用的是<code>file</code>协议，而<code>$.getScript</code>在这个情况下是使用Ajax去请求脚本的内容，Chrome在使用<code>file</code>协议的页面进行Ajax请求时会抛出跨域访问的异常。所以只能用动态插入<code>script</code>标签的方式去实现：</p>\n<pre><code>var done = false;\nvar head = document.getElementsByTagName(&quot;head&quot;)[0];\nvar s = document.createElement(&quot;script&quot;);\ns.type = &quot;text/javascript&quot;;\ns.onload = s.onreadystatechange = function (evt) {\n  if (!done &amp;&amp; (!this.readyState || \n    this.readyState == &quot;loaded&quot; ||\n    this.readyState == &quot;complete&quot;)) {\n    // do something with the script\n    s.onload = s.onreadystatechange = null;\n    head.removeChild(s);\n  }\n}\ns.src = &quot;path/to/script.js&quot;;\nhead.appendChild(s);\n</code></pre><p>在Chrome和FireFox上，<code>onload</code>会在脚本加载完之后触发，在回调函数中脚本的内容已经加载完全。而这两个浏览器的<code>script</code>标签是不支持<code>onreadystatechange</code>事件的。</p>\n<p>在IE上比较有趣。IE9两个事件都是支持的，而IE8、7、6则只支持<code>onreadystatechange</code>。在<code>onreadystatechange</code>事件处理程序中还需要判断<code>script.readyState</code>属性。经观察之后发现其实当<code>loaded</code>的时候，脚本的内容已经可用了。但是在某些情况下，<code>loaded</code>之后脚本的内容还没有完全加载。遇到这些情况只能增加一个<code>setTimeout</code>了。实验的代码可以参考下面的例子：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/8HY6k/2/embedded/js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n","summaryMarkdownText":"\n\n\n之前做一个效果，涉及到动态加载脚本的问题。这个效果需要做成本地文件直接打开可以看到效果，所以下面的代码在Chrome是会报错的：\n\n    $.getScript(\"./js/dynamic.js\", function () {...});\n\n由于本地文件使用的是`file`协议，而`$.getScript`在这个情况下是使用Ajax去请求脚本的内容，Chrome在使用`file`协议的页面进行Ajax请求时会抛出跨域访问的异常。所以只能用动态插入`script`标签的方式去实现：\n\n\tvar done = false;\n    var head = document.getElementsByTagName(\"head\")[0];\n    var s = document.createElement(\"script\");\n    s.type = \"text/javascript\";\n\ts.onload = s.onreadystatechange = function (evt) {\n      if (!done && (!this.readyState || \n        this.readyState == \"loaded\" ||\n        this.readyState == \"complete\")) {\n        // do something with the script\n        s.onload = s.onreadystatechange = null;\n        head.removeChild(s);\n      }\n    }\n    s.src = \"path/to/script.js\";\n    head.appendChild(s);\n","summaryHtmlText":"<p>之前做一个效果，涉及到动态加载脚本的问题。这个效果需要做成本地文件直接打开可以看到效果，所以下面的代码在Chrome是会报错的：</p>\n<pre><code>$.getScript(&quot;./js/dynamic.js&quot;, function () {...});\n</code></pre><p>由于本地文件使用的是<code>file</code>协议，而<code>$.getScript</code>在这个情况下是使用Ajax去请求脚本的内容，Chrome在使用<code>file</code>协议的页面进行Ajax请求时会抛出跨域访问的异常。所以只能用动态插入<code>script</code>标签的方式去实现：</p>\n<pre><code>var done = false;\nvar head = document.getElementsByTagName(&quot;head&quot;)[0];\nvar s = document.createElement(&quot;script&quot;);\ns.type = &quot;text/javascript&quot;;\ns.onload = s.onreadystatechange = function (evt) {\n  if (!done &amp;&amp; (!this.readyState || \n    this.readyState == &quot;loaded&quot; ||\n    this.readyState == &quot;complete&quot;)) {\n    // do something with the script\n    s.onload = s.onreadystatechange = null;\n    head.removeChild(s);\n  }\n}\ns.src = &quot;path/to/script.js&quot;;\nhead.appendChild(s);\n</code></pre>"}