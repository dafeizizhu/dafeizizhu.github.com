{"year":"2013","month":"08","day":"30","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/08/30/jquery-html-source.html","fileName":"jquery-html-source","layout":"post","title":"jQuery源码解析之jQuery.fn.html","description":"","tags":["JavaScript","jQuery"],"markdownText":"\n\n\n今天来看看`jQuery.fn.html`的源码。jQuery通过一个`access`方法封装了jQuery风格的`getter`和`setter`。今天先不关注`access`是怎么实现的，具体来看看`html`内部的代码逻辑。\n\n首先来看一下这几个正则：\n\n    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n      rtagName = /<([\\w:]+)/,\n      rhtml = /<|&#?\\w+;/,\n      rnoInnerhtml = /<(?:script|style|link)/i,\n\n1. 第一个正则是匹配一些自关闭的HTML标签。\n2. 第二个正则匹配字符串中第一个标签的`tagName`。\n3. 第三个正则匹配这个字符串是否HTML字符串。\n4. 第四个正则匹配这个字符串里面有没有包含样式或者是脚本。\n\n先来看`getter`，这个逻辑非常简单：\n\n    if ( value === undefined && elem.nodeType === 1 ) {\n      return elem.innerHTML;\n    }\n\n`elem`是jQuery对象的第一个元素，如果没有传入任何参数并且jQuery对象的一个元素是HTML元素，则直接返回其`innerHTML`属性。\n\n再来看`setter`，这里有两个分支。要进入第一个分支，需要满足以下几个条件：\n\n1. 传入的参数是一个字符串。\n2. 字符串里面没有样式或者脚本，使用第四个正则表达式去匹配。\n3. `wrapMap`里面没有`key`是使用第二个正则表达式匹配出来的第一个标签的`tagName`。\n\n满足这三个条件之后，jQuery会使用第一个正则表达式匹配不应该自关闭的标签，例如`div`。如果找到这些不应该自关闭的标签，会使用以下这句代码自动替换成一个关闭的空标签：\n\n    value = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n替换完成之后，会遍历jQuery对象里面所有的元素，先使用`cleanData`去掉内部元素的所有数据和事件处理程序：\n\n    jQuery.cleanData( getAll( elem, false ) );\n\n并直接把元素的`innerHTML`属性设置成`value`。全部元素都处理完之后，会把`elem`的值置成`0`，这样第二个分支就不会执行了。注意，在对`innerHTML`赋值的时候可能会抛出异常。抛出异常后`elem`的值是非0的，这个情况下都会进入第二个分支。\n\n第二个分之就是调用`empty`之后再调用`append`来获得跟直接设置`innerHTML`一样的效果：\n\n    this.empty().append( value );\n\n以上就是`html`的主要逻辑。`getter`很简单，就是返回`innerHTML`。而`setter`就比较复杂，如果要单纯使用`innerHTML`这个属性，要判断参数是否适合直接使用`innerHTML`，例如参数里面有脚本或者样式，则需要进入第二个分之，交给`append`去处理。\n","htmlText":"<p>今天来看看<code>jQuery.fn.html</code>的源码。jQuery通过一个<code>access</code>方法封装了jQuery风格的<code>getter</code>和<code>setter</code>。今天先不关注<code>access</code>是怎么实现的，具体来看看<code>html</code>内部的代码逻辑。</p>\n<p>首先来看一下这几个正则：</p>\n<pre><code>var rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^&gt;]*)\\/&gt;/gi,\n  rtagName = /&lt;([\\w:]+)/,\n  rhtml = /&lt;|&amp;#?\\w+;/,\n  rnoInnerhtml = /&lt;(?:script|style|link)/i,\n</code></pre><ol>\n<li>第一个正则是匹配一些自关闭的HTML标签。</li>\n<li>第二个正则匹配字符串中第一个标签的<code>tagName</code>。</li>\n<li>第三个正则匹配这个字符串是否HTML字符串。</li>\n<li>第四个正则匹配这个字符串里面有没有包含样式或者是脚本。</li>\n</ol>\n<p>先来看<code>getter</code>，这个逻辑非常简单：</p>\n<pre><code>if ( value === undefined &amp;&amp; elem.nodeType === 1 ) {\n  return elem.innerHTML;\n}\n</code></pre><p><code>elem</code>是jQuery对象的第一个元素，如果没有传入任何参数并且jQuery对象的一个元素是HTML元素，则直接返回其<code>innerHTML</code>属性。</p>\n<p>再来看<code>setter</code>，这里有两个分支。要进入第一个分支，需要满足以下几个条件：</p>\n<ol>\n<li>传入的参数是一个字符串。</li>\n<li>字符串里面没有样式或者脚本，使用第四个正则表达式去匹配。</li>\n<li><code>wrapMap</code>里面没有<code>key</code>是使用第二个正则表达式匹配出来的第一个标签的<code>tagName</code>。</li>\n</ol>\n<p>满足这三个条件之后，jQuery会使用第一个正则表达式匹配不应该自关闭的标签，例如<code>div</code>。如果找到这些不应该自关闭的标签，会使用以下这句代码自动替换成一个关闭的空标签：</p>\n<pre><code>value = value.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; );\n</code></pre><p>替换完成之后，会遍历jQuery对象里面所有的元素，先使用<code>cleanData</code>去掉内部元素的所有数据和事件处理程序：</p>\n<pre><code>jQuery.cleanData( getAll( elem, false ) );\n</code></pre><p>并直接把元素的<code>innerHTML</code>属性设置成<code>value</code>。全部元素都处理完之后，会把<code>elem</code>的值置成<code>0</code>，这样第二个分支就不会执行了。注意，在对<code>innerHTML</code>赋值的时候可能会抛出异常。抛出异常后<code>elem</code>的值是非0的，这个情况下都会进入第二个分支。</p>\n<p>第二个分之就是调用<code>empty</code>之后再调用<code>append</code>来获得跟直接设置<code>innerHTML</code>一样的效果：</p>\n<pre><code>this.empty().append( value );\n</code></pre><p>以上就是<code>html</code>的主要逻辑。<code>getter</code>很简单，就是返回<code>innerHTML</code>。而<code>setter</code>就比较复杂，如果要单纯使用<code>innerHTML</code>这个属性，要判断参数是否适合直接使用<code>innerHTML</code>，例如参数里面有脚本或者样式，则需要进入第二个分之，交给<code>append</code>去处理。</p>\n","summaryMarkdownText":"\n\n\n今天来看看`jQuery.fn.html`的源码。jQuery通过一个`access`方法封装了jQuery风格的`getter`和`setter`。今天先不关注`access`是怎么实现的，具体来看看`html`内部的代码逻辑。\n\n首先来看一下这几个正则：\n\n    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n      rtagName = /<([\\w:]+)/,\n      rhtml = /<|&#?\\w+;/,\n      rnoInnerhtml = /<(?:script|style|link)/i,\n\n1. 第一个正则是匹配一些自关闭的HTML标签。\n2. 第二个正则匹配字符串中第一个标签的`tagName`。\n3. 第三个正则匹配这个字符串是否HTML字符串。\n4. 第四个正则匹配这个字符串里面有没有包含样式或者是脚本。\n\n先来看`getter`，这个逻辑非常简单：\n\n    if ( value === undefined && elem.nodeType === 1 ) {\n      return elem.innerHTML;\n    }\n\n`elem`是jQuery对象的第一个元素，如果没有传入任何参数并且jQuery对象的一个元素是HTML元素，则直接返回其`innerHTML`属性。\n","summaryHtmlText":"<p>今天来看看<code>jQuery.fn.html</code>的源码。jQuery通过一个<code>access</code>方法封装了jQuery风格的<code>getter</code>和<code>setter</code>。今天先不关注<code>access</code>是怎么实现的，具体来看看<code>html</code>内部的代码逻辑。</p>\n<p>首先来看一下这几个正则：</p>\n<pre><code>var rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^&gt;]*)\\/&gt;/gi,\n  rtagName = /&lt;([\\w:]+)/,\n  rhtml = /&lt;|&amp;#?\\w+;/,\n  rnoInnerhtml = /&lt;(?:script|style|link)/i,\n</code></pre><ol>\n<li>第一个正则是匹配一些自关闭的HTML标签。</li>\n<li>第二个正则匹配字符串中第一个标签的<code>tagName</code>。</li>\n<li>第三个正则匹配这个字符串是否HTML字符串。</li>\n<li>第四个正则匹配这个字符串里面有没有包含样式或者是脚本。</li>\n</ol>\n<p>先来看<code>getter</code>，这个逻辑非常简单：</p>\n<pre><code>if ( value === undefined &amp;&amp; elem.nodeType === 1 ) {\n  return elem.innerHTML;\n}\n</code></pre><p><code>elem</code>是jQuery对象的第一个元素，如果没有传入任何参数并且jQuery对象的一个元素是HTML元素，则直接返回其<code>innerHTML</code>属性。</p>\n"}