{"year":"2013","month":"10","day":"07","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/10/07/javascript-text-content.html","fileName":"javascript-text-content","layout":"post","title":"Secrets of the JavaScript Ninja 读书笔记之 文本内容","description":"","tags":["JavaScript"],"markdownText":"\n\n\n处理文本内容看起来要比处理DOM元素要简单得多，特别是浏览器已经提供了通用的API让我们去处理文本内容。但是，API的行为在不同的浏览器中也有一些小区别需要注意。\n\n最常用的操作就是获取和设置DOM的文本内容。标准浏览器提供了一个`textContent`的属性，可以通过这个属性访问DOM对象中的文本内容，包括其子孙元素的文本内容，如：\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/8hUR5/embedded/html,js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n老版本的IE提供了另外一个属性`innerText`，跟标准的`textContent`的行为是一致的，Webkit核心的浏览器也支持`innerText`。\n\n注意，当设置了`textContent`或者`innerText`之后，DOM对象里面的HTML结构也会被清除哦，只剩下设置的文本内容。这样会导致一些问题。\n\n第一个问题就是内存泄漏。因为直接设置文本内容后，该DOM对象的子孙元素会被删除，但是这些元素上面可能会有绑定的事件处理程序等数据，这些数据占用的内容有可能不能释放。\n\n还有一个问题就是各种浏览器对于空白的处理都不一致，这样导致直接使用浏览器提供的操作文本内容的属性不能产生一致的效果。\n\n所以我们需要额外地编写一些代码以提供跨浏览器表现一致的API。\n\n### 设置文本内容\n____\n\n由于要避免子孙元素的事件处理程序等数据的内存泄漏，需要分成两个步骤去设置文本内容：\n\n1. 删掉该元素所有子孙DOM对象，清除所有附加的数据。\n2. 在清空后的元素中插入文本内容。\n\n在步骤2里面，我们使用了`document.createTextNode`去插入一个文本节点。这个方法创建的文本节点，可以为我们传入的字符串进行HTML编码，防止插入的内容含有HTML片段或者注入脚本，如：\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/b9JEa/embedded/js,html,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n### 获取文本内容\n____\n\n如果我们需要在不同浏览器上表现一致，那么就不能直接使用`textContent`或者`innerHTML`。我们需要遍历DOM对象的所有子孙元素，自行收集所有文本节点，然后组装出一个稳定的结果：\n\n    function getText(elem) {\n      var text = \"\";\n      for (var i = 0; i < elem.childNodes.length; i++) {\n        var cur = elem.childNodes[i];\n        if (cur.nodeType === 3) {\n          text += cur.nodeValue;\n        } else if (cur.nodeType === 1) {\n          text += getText(cur); // 递归\n        }\n      }\n\t  return text;\n    }\n\n这样就可以避免不同浏览器对于空格的处理影响到最后的结果。\n","htmlText":"<p>处理文本内容看起来要比处理DOM元素要简单得多，特别是浏览器已经提供了通用的API让我们去处理文本内容。但是，API的行为在不同的浏览器中也有一些小区别需要注意。</p>\n<p>最常用的操作就是获取和设置DOM的文本内容。标准浏览器提供了一个<code>textContent</code>的属性，可以通过这个属性访问DOM对象中的文本内容，包括其子孙元素的文本内容，如：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/8hUR5/embedded/html,js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<p>老版本的IE提供了另外一个属性<code>innerText</code>，跟标准的<code>textContent</code>的行为是一致的，Webkit核心的浏览器也支持<code>innerText</code>。</p>\n<p>注意，当设置了<code>textContent</code>或者<code>innerText</code>之后，DOM对象里面的HTML结构也会被清除哦，只剩下设置的文本内容。这样会导致一些问题。</p>\n<p>第一个问题就是内存泄漏。因为直接设置文本内容后，该DOM对象的子孙元素会被删除，但是这些元素上面可能会有绑定的事件处理程序等数据，这些数据占用的内容有可能不能释放。</p>\n<p>还有一个问题就是各种浏览器对于空白的处理都不一致，这样导致直接使用浏览器提供的操作文本内容的属性不能产生一致的效果。</p>\n<p>所以我们需要额外地编写一些代码以提供跨浏览器表现一致的API。</p>\n<h3 id=\"-\">设置文本内容</h3>\n<hr>\n<p>由于要避免子孙元素的事件处理程序等数据的内存泄漏，需要分成两个步骤去设置文本内容：</p>\n<ol>\n<li>删掉该元素所有子孙DOM对象，清除所有附加的数据。</li>\n<li>在清空后的元素中插入文本内容。</li>\n</ol>\n<p>在步骤2里面，我们使用了<code>document.createTextNode</code>去插入一个文本节点。这个方法创建的文本节点，可以为我们传入的字符串进行HTML编码，防止插入的内容含有HTML片段或者注入脚本，如：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/b9JEa/embedded/js,html,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<h3 id=\"-\">获取文本内容</h3>\n<hr>\n<p>如果我们需要在不同浏览器上表现一致，那么就不能直接使用<code>textContent</code>或者<code>innerHTML</code>。我们需要遍历DOM对象的所有子孙元素，自行收集所有文本节点，然后组装出一个稳定的结果：</p>\n<pre><code>function getText(elem) {\n  var text = &quot;&quot;;\n  for (var i = 0; i &lt; elem.childNodes.length; i++) {\n    var cur = elem.childNodes[i];\n    if (cur.nodeType === 3) {\n      text += cur.nodeValue;\n    } else if (cur.nodeType === 1) {\n      text += getText(cur); // 递归\n    }\n  }\n  return text;\n}\n</code></pre><p>这样就可以避免不同浏览器对于空格的处理影响到最后的结果。</p>\n","summaryMarkdownText":"\n\n\n处理文本内容看起来要比处理DOM元素要简单得多，特别是浏览器已经提供了通用的API让我们去处理文本内容。但是，API的行为在不同的浏览器中也有一些小区别需要注意。\n\n最常用的操作就是获取和设置DOM的文本内容。标准浏览器提供了一个`textContent`的属性，可以通过这个属性访问DOM对象中的文本内容，包括其子孙元素的文本内容，如：\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/8hUR5/embedded/html,js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n老版本的IE提供了另外一个属性`innerText`，跟标准的`textContent`的行为是一致的，Webkit核心的浏览器也支持`innerText`。\n\n注意，当设置了`textContent`或者`innerText`之后，DOM对象里面的HTML结构也会被清除哦，只剩下设置的文本内容。这样会导致一些问题。\n\n第一个问题就是内存泄漏。因为直接设置文本内容后，该DOM对象的子孙元素会被删除，但是这些元素上面可能会有绑定的事件处理程序等数据，这些数据占用的内容有可能不能释放。\n\n还有一个问题就是各种浏览器对于空白的处理都不一致，这样导致直接使用浏览器提供的操作文本内容的属性不能产生一致的效果。\n\n所以我们需要额外地编写一些代码以提供跨浏览器表现一致的API。\n\n### 设置文本内容\n____\n\n由于要避免子孙元素的事件处理程序等数据的内存泄漏，需要分成两个步骤去设置文本内容：\n\n1. 删掉该元素所有子孙DOM对象，清除所有附加的数据。","summaryHtmlText":"<p>处理文本内容看起来要比处理DOM元素要简单得多，特别是浏览器已经提供了通用的API让我们去处理文本内容。但是，API的行为在不同的浏览器中也有一些小区别需要注意。</p>\n<p>最常用的操作就是获取和设置DOM的文本内容。标准浏览器提供了一个<code>textContent</code>的属性，可以通过这个属性访问DOM对象中的文本内容，包括其子孙元素的文本内容，如：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/8hUR5/embedded/html,js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<p>老版本的IE提供了另外一个属性<code>innerText</code>，跟标准的<code>textContent</code>的行为是一致的，Webkit核心的浏览器也支持<code>innerText</code>。</p>\n<p>注意，当设置了<code>textContent</code>或者<code>innerText</code>之后，DOM对象里面的HTML结构也会被清除哦，只剩下设置的文本内容。这样会导致一些问题。</p>\n<p>第一个问题就是内存泄漏。因为直接设置文本内容后，该DOM对象的子孙元素会被删除，但是这些元素上面可能会有绑定的事件处理程序等数据，这些数据占用的内容有可能不能释放。</p>\n<p>还有一个问题就是各种浏览器对于空白的处理都不一致，这样导致直接使用浏览器提供的操作文本内容的属性不能产生一致的效果。</p>\n<p>所以我们需要额外地编写一些代码以提供跨浏览器表现一致的API。</p>\n<h3 id=\"-\">设置文本内容</h3>\n<hr>\n<p>由于要避免子孙元素的事件处理程序等数据的内存泄漏，需要分成两个步骤去设置文本内容：</p>\n<ol>\n<li>删掉该元素所有子孙DOM对象，清除所有附加的数据。</li>\n</ol>\n"}