[{"link":"/posts/2014/02/24/as3-textfield-htmltext.html","title":"as3 TextField htmlText","summary":"","path":"2014-02-24-as3-textfield-htmltext.json","year":"2014","month":"02","day":"24","tags":[""]},{"link":"/posts/2014/02/17/as3-externalinterface-addcallback.html","title":"在JavaScript中调用AS3的代码","summary":"<p>在信任的容器中，也可以通过JavaScript调用ActionScript的代码。通过<code>ExternalInterface.addCallback</code>这个方法，可以将ActionScript方法注册为容器可用。</p>\n<p>这个方法接受两个参数：</p>\n<ol>\n<li><code>functionName</code>，在容器中注册的方法名。调用这个方法之后，会在Flash的DOM对象中生成一个同样名称的方法，外部容器通过这个方法来访问ActionScript中对应的方法。</li>\n<li><code>closure</code>，注册的方法。</li>\n</ol>\n<p>当成功调用<code>addCallback</code>之后，容器中的JavaScript就可以调用对应的ActionScript的代码：</p>\n<pre><code>var swf = document.getElementById(&quot;id&quot;);\nswf.functionName(...);\n</code></pre><p>跟<code>call</code>一样，调用之前要检查<code>availible</code>属性的值。如果不支持传入调用，会引发<code>Error</code>。</p>\n<p>同样，也要通过代码给对应的<code>swf</code>文件和容器赋予权限：在容器中设置<code>allowScriptAccess</code>参数的值为<code>always</code>；在<code>swf</code>内部调用<code>allowDomain</code>赋予对应域中的容器权限。</p>\n<p>通过<code>allCallback</code>和<code>call</code>，我们可以在ActionScript和外部容器（例如HTML中的JavaScript）进行交互，例如读取页面的URL、读取cookie、调用容器对应功能，如调用<code>alert</code>等方法，非常方便。</p>\n<p>其中要注意的是，在IE6上有部分关键字，例如<code>stop</code>，不能用在<code>functionName</code>，考虑这种情况的话<code>functionName</code>最好是一些比较特别一点的名字，如<code>stopMe</code>（囧）。</p>\n","path":"2014-02-17-as3-externalinterface-addcallback.json","year":"2014","month":"02","day":"17","tags":["Flash"]},{"link":"/posts/2014/02/11/as3-externalinterface-call.html","title":"Flash调用外部JavaScript","summary":"<p><code>ExternalInterface</code>是用来支持ActionScript和<code>swf</code>容器（例如<code>HTML</code>页面）之间进行交互的接口。通过<code>ExternalInterface</code>，可以在<code>swf</code>文件内部的ActionScript代码调用外部HTML页面的JavaScript代码，反之亦然。</p>\n<p>今天先来讨论下<code>swf</code>文件内部是如何访问外部HTML页面的JavaScript代码。在获得授权的情况下，ActionScript可以调用JavaScript的任何全局函数、可以传递任意数量的基本类型的参数、可以接收JavaScript函数的返回值。</p>\n<p>在使用<code>ExternalInterface</code>之前，我们都必须检查这个类的静态属性<code>available</code>的值。这个属性表示外部容器（例如HTML页面）是否支持提供外部接口。当这个属性的值为<code>true</code>的时候，我们可以使用静态方法<code>call</code>来调用HTML的JavaScript函数。</p>\n<p><code>call</code>方法接受可变长度的参数，其中第一个参数是执行的JavaScript函数的名称。注意的是，不仅仅可以传递函数名称，也可以传递一个匿名函数：</p>\n<pre><code>ExternalInterface.call(&quot;function(){alert(1);}&quot;);\n</code></pre><p>这样十分方便，再也不需要担心要在HTML页面暴露出几个全局函数让ActionScript执行了。</p>\n<p>后面可以传递多个参数，这些参数也会传递到JavaScript函数中，会自动把ActionScript的类型转化成JavaScript的类型。</p>\n<p>调用这个方法后，如果调用成功，则返回JavaScript函数的返回值，否则返回<code>null</code>表示调用失败。有很多种场景都会使调用失败，例如该JavaScript函数不可用、在Netscape或者Opera发生递归等。</p>\n<p>这个方法会引发两个异常：</p>\n<ol>\n<li>容器不支持调用，引发<code>Error</code>。</li>\n<li>包含环境属于调用代码无权访问的安全沙箱，引入<code>SecurityError</code>。</li>\n</ol>\n<p>要解决安全问题，需要以下两个步骤：</p>\n","path":"2014-02-11-as3-externalinterface-call.json","year":"2014","month":"02","day":"11","tags":["Flash"]},{"link":"/posts/2014/01/26/as3-soundmixer.html","title":"全局声音控制：SoundMixer","summary":"<p>之前讨论的<code>MovieClip</code>实例中的<code>soundTransform</code>可以控制这个视频剪辑的声音播放以及声音大小的控制。但不是所有从<code>Loader</code>中加载的<code>swf</code>都是<code>MovieClip</code>实例，例如使用早期Flash创作工具创作的<code>swf</code>文件，它并没有<code>soundTransform</code>这个属性。这时候，我们只能通过全局声音来控制这个视频剪辑的声音播放。</p>\n<p>在AS3中，全局声音控制是通过<code>SoundMixer</code>类提供的静态属性和方法来控制的。这个类有两个静态属性：</p>\n<ol>\n<li><code>bufferTime</code>，表示预加载到缓冲区中所用的秒数。</li>\n<li><code>soundTransform</code>，是<code>SoundTransform</code>的实例，通过控制这个属性的<code>volumn</code>方法就可以控制声音播放的大小。</li>\n</ol>\n<p>这个类还提供了几个静态工具方法：</p>\n<ol>\n<li><code>areSoundsInaccessible</code>，确定是否因安全限制而无法访问任何声音，例如播放的声音所在的服务器没有授权所在域访问的URL策略文件等。</li>\n<li><code>computeSpectrum</code>，用来获取当前声音波形的快照。使用获取到的数据可以绘制出当前声音播放的波形。</li>\n<li><code>stopAll</code>，停止当前正在播放的声音。默认情况下，只会停止与调用此方法的对象在相同安全沙箱中的声音。注，没有恢复功能，只能调用<code>Sound</code>实例的<code>play</code>方法恢复声音播放。</li>\n</ol>\n<p>由于普通的应用不会出现同时播放两种声音的情况，所以大多数情况下我们可以使用这个全局的声音控制方法为我们的<code>swf</code>应用提供静音功能：</p>\n<pre><code>var soundtrans:SoundTransform = new SoundTransform(0, 0);\nSoundMixer.soundTransform = soundtrans;\n</code></pre>","path":"2014-01-26-as3-soundmixer.json","year":"2014","month":"01","day":"26","tags":["Flash"]},{"link":"/posts/2014/01/24/as3-sound-transform.html","title":"在Flash中控制声音之SoundTransform","summary":"<p><code>Sprite</code>中有一个属性，<code>soundTransform</code>，就是用于控制这个<code>Sprite</code>的声音播放，包括音量大小和声道等。这个属性是<code>SoundTransform</code>类的一个实例，通过调整<code>soundTransform</code>的对应属性，就可以控制这个<code>Sprite</code>的声音播放。</p>\n<p><code>SoundTransform</code>有以下几个属性可以供我们调整：</p>\n<ol>\n<li><code>leftToLeft</code>，指定左输入在左扬声器播放的量。</li>\n<li><code>leftToRight</code>，指定左输入在右扬声器播放的量。</li>\n<li><code>pan</code>，声音从左到右的平移。</li>\n<li><code>rightToLeft</code>，指定右输入在右扬声器的量。</li>\n<li><code>rightToRight</code>，指定右输入在右扬声器的量。</li>\n<li><code>volume</code>，指定音量范围。</li>\n</ol>\n<p>其实上面的属性，平常只会使用到<code>volume</code>。这个属性的取值范围是<code>0</code>到<code>1</code>,分别表示静音和最大音量。</p>\n<p>这个类只有构造函数一个公共方法，接受两个参数，分别是<code>volume</code>和<code>pan</code>两个属性的值。</p>\n<p>下面的代码演示了如何控制一个<code>Sound</code>实例的声音播放：</p>\n<pre><code>var mySound:Sound = new Sound();\nvar url:URLRequest = new URLRequest(&quot;mySound.mp3&quot;);\nvar channel:SoundChannel;\nvar transform:SoundTransform = new SoundTransform(0.5, 1.0);\n</code></pre>","path":"2014-01-24-as3-sound-transform.json","year":"2014","month":"01","day":"24","tags":["Flash"]},{"link":"/posts/2014/01/23/as3-netstream-play.html","title":"用NetStream播放视频，包括二进制数据哦！","summary":"<p>昨天只是简单地将在Flash中播放视频的最基本的方法介绍了一遍。其实我们可以自己去下载视频的数据，然后通过<code>NetStream</code>的<code>appendBytes</code>方法把获取到的数据添加到流里面。这样，我们可以对数据的传输进行更精确的控制。</p>\n<p><code>play</code>方法最简单的用法就是传入一个本地或者Web URL，后面的数据加载就交给<code>NetStream</code>的内部实现了。我们也可以传入一个<code>null</code>，这时<code>NetStream</code>就启动“数据生成模式”。在这个模式下面，调用<code>appendBytes</code>方法就可以把二进制数据添加到流中。</p>\n<p>要注意的是，在构造<code>NetStream</code>对象的时候需要在调用<code>NetConnection</code>的<code>connect</code>方法传入一个<code>null</code>。</p>\n<p>然后我们就可以从网络或者其他任意地方读取二进制数据，调用<code>appendBytes</code>把它们加入到这个流中播放：</p>\n<pre><code>var MyNC:NetConnection = new NetConnection();\nMyNC.connect(null);\n\nvar MyNS:NetStream = new NetStream(MyNC);\nMyVideo.attachNetStream(MyNS);\nMyNS.play(null);\nMyNS.appendBytes(ba);\n</code></pre><p>注意，在<code>appendBytes</code>执行后续调用之前，字节分析程序可能无法完整地解码对<code>appendBytes</code>的调用。</p>\n<p>通过这种播放方式，我们可以先把视频加载到内从，校验视频内容（MD5等），然后直接把这些二进制数据加载到流中播放，这样播放的时候就不需要再从网络或者本地文件系统中加载数据了。</p>\n","path":"2014-01-23-as3-netstream-play.json","year":"2014","month":"01","day":"23","tags":["Flash"]},{"link":"/posts/2014/01/22/as3-netstream.html","title":"在Flash中播放视频之NetStream","summary":"<p>昨天讨论的<code>Video</code>只是视频的一个容器，真正拉取视频内容，控制视频播放的是<code>NetStream</code>类。使用<code>NetStream</code>可以从本地或者Web服务器播放媒体文件，也可以将视频、音频、数据流发布到远程服务器。今天主要讨论的是如何从一个本地路径或者Web路径播放媒体文件。</p>\n<p>要创建一个<code>NetStream</code>，先要构造一个<code>NetConnection</code>对象。由于是播放本地或者Web上的视频文件，所以在构造<code>NetConnection</code>的时候，需要调用<code>connect</code>方法的时候传入一个<code>null</code>：</p>\n<pre><code>var nc:NetConnection = new NetConnection(); \nnc.connect(null);\n</code></pre><p>当需要连接到Media Server的时候才需要传入一个服务器的地址。然后我们就可以用这个<code>NetConnection</code>对象构造一个<code>NetStream</code>：</p>\n<pre><code>var ns:NetStream = new NetStream(nc); \n</code></pre><p>然后就可以把这个<code>NetStream</code>附加到<code>Video</code>上：</p>\n<pre><code>vid.attachNetStream(ns);\n</code></pre><p>最后调用<code>NetStream</code>的<code>play</code>方法就可以播放视频了：</p>\n<pre><code>ns.play(&quot;video.mp4&quot;);\n</code></pre><p>其中的参数就是视频的地址，可以是一个本地路径或者是一个Web路径，要注意安全策略的限制。</p>\n<p>在<code>play</code>之后，会触发多次<code>NetStatusEvent.NET_STATUS</code>事件，其中<code>info</code>属性声明了这次是什么状态，常用的状态有：</p>\n","path":"2014-01-22-as3-netstream.json","year":"2014","month":"01","day":"22","tags":["Flash"]},{"link":"/posts/2014/01/21/as3-video.html","title":"在Flash中播放视频之Video","summary":"<p>视频广告要播视频了。之前做的是使用<code>Loader</code>去加载<code>swf</code>和图片，播放视频则需要使用另一个类：<code>Video</code>。<code>Video</code>类可以显示实时视频和录制视频，这个视频不需要嵌入到<code>swf</code>文件当中。今天主要讨论的是播放一个已经录制好的视频。</p>\n<p><code>Video</code>类支持<code>flv</code>、<code>mp4</code>等视频文件，它是<code>DisplayObject</code>的子类，所以可以控制各种属性，例如<code>x</code>、<code>y</code>控制<code>Video</code>的位置等。通常要播放一个视频，需要以下几个步骤：</p>\n<ol>\n<li>将视频附加到一个视频流上。视频流是<code>NetStream</code>类的实例。</li>\n<li>调用<code>addChild</code>把<code>Video</code>实例放到舞台上。</li>\n</ol>\n<p>除了从<code>DisplayObject</code>继承来的属性外，还有以下几个属性：</p>\n<ol>\n<li><code>deblocking</code>，表示作为后处理的一部分应用于已解码视频的滤镜类型。</li>\n<li><code>smoothing</code>，指定在缩放视频时是否进行平滑处理。</li>\n<li><code>videoHeight</code>，只读，视频流的高度，单位是像素。</li>\n<li><code>videoWidth</code>，只读，视频流的宽度，单位是像素。</li>\n</ol>\n<p>方法：</p>\n<ol>\n<li><code>attachCamera</code>，附加来自摄像头的视频流。</li>\n<li><code>attachNetStream</code>，附加一个来自网络的视频流，这个也是我们比较常用的方法，播放外部视频。</li>\n<li><code>clear</code>，清除<code>Video</code>对象中当前显示的图像，但不会停止播放。视频流对象才能控制播放和停止。</li>\n</ol>\n<p>构造方法接受两个参数，就是<code>Video</code>的默认宽和高。这两个参数是可选的，如果不指定，默认的宽度是<code>320</code>像素，默认的高度是<code>240</code>像素。</p>\n","path":"2014-01-21-as3-video.json","year":"2014","month":"01","day":"21","tags":["Flash"]},{"link":"/posts/2014/01/20/as3-displayobject-mask.html","title":"内容不要超过容器！","summary":"<p>在HTML中，我当元素的内容超过容器的大小时，我们需要使用css中的<code>overflow</code>来指定该如何显示。在Flash中，一般当元素的内容超过容器的大小时，超出容器的部分还是会显示出来的，如果要达到设置<code>overflow: hidden</code>的效果，我们需要设置显示对象的<code>mask</code>属性，指定对象的遮罩，这样超出遮罩的部分就不会显示了。</p>\n<p>通常我们会指定一个<code>DisplayObject</code>的实例作为遮罩，例如<code>Sprite</code>、<code>Shape</code>等都可以作为遮罩：</p>\n<pre><code>var mask:Shape = new Shape();\nmask.graphics.beginDraw(0, 0);\nmask.drawRect(0, 0, 200, 200);\ndisplayObject.mask = mask;\n</code></pre><p>被遮罩的显示对象显示在用作遮罩的显示对象的全部不透明区域内。如上例中，<code>displayObject</code>这个显示对象就只会显示一个200 × 200的矩形区域，超过该矩形区域的部分就不会显示出来了。</p>\n<p>要取消遮罩的话只要把<code>mask</code>对象设置成<code>null</code>就可以了。要注意的是：</p>\n<ol>\n<li>不能使用一个遮罩对象来遮罩另一个遮罩对象。</li>\n<li>单个遮罩对象不能用于多个执行调用的显示对象。在将遮罩对象分配给第二个显示对象时，会撤销第一个显示对象的遮罩，第一个显示对象的遮罩会被置为<code>null</code>。</li>\n<li>只有填充可用于作为遮罩的显示对象中，笔触都会被忽略。</li>\n</ol>\n<p>在使用Flash创作工作制作Flash影片的时候，经常会有内容超出场景<code>Stage</code>的场景，例如做一些飞出飞入的动画。当我们需要加载这些影片的时候要注意加上遮罩，不然超出影片<code>Stage</code>大小的部分也会显示出来，这一般不是我们想要看到的。</p>\n","path":"2014-01-20-as3-displayobject-mask.json","year":"2014","month":"01","day":"20","tags":["Flash"]},{"link":"/posts/2014/01/15/as3-timer.html","title":"在Flash中使用计时器","summary":"<p>如同在JavaScript中使用<code>setTimeout</code>和<code>setInterval</code>中使用计时器，在ActionScript中也能使用计时器达到同样的目的，例如定时、超时等功能。</p>\n<p>虽然在ActionScript里面也有<code>setTimeout</code>和<code>setInterval</code>两个工具函数，但是ActionScript封装了一个工具类<code>Timer</code>，让我们能更灵活地使用定时器，以上两个工具函数也是<code>Timer</code>的一个封装。</p>\n<p><code>Timer</code>类的构造函数接受两个参数：</p>\n<ol>\n<li><code>delay</code>，声明计时器事件间的延迟，以毫秒为单位。当指定的时间经过之后，<code>Timer</code>实例会触发事件，我们可以为这个事件注册事件处理程序在指定的时间延迟之后执行一段代码。建议这个值不要低于<code>20</code>毫秒，因为计时器的频率不得超过<code>60</code>帧每秒，而计时器事件执行的频率必须是帧率的整数倍，所以少于<code>16.6</code>毫秒的延迟可能会导致延迟不准确。</li>\n<li><code>repeatCount</code>，可选，声明重复次数。默认是<code>0</code>，计时器会不断地重复执行，最长可以执行<code>int.MAX_VALUE + 1</code>（大概24天）。如果不为<code>0</code>,则计时器执行到指定的次数之后会自动停止。</li>\n</ol>\n<p>注意，与JavaScript中的计时器一样，指定的延迟会根据<code>swf</code>文件的帧速率或者其他因素，运行时调度事件的间隔可能会有偏差。例如某个<code>swf</code>文件以每秒<code>10</code>帧，也就是每帧间隔<code>100</code>毫秒的速度播放，但延迟设置为<code>80</code>毫秒，则将会在接近于<code>100</code>毫秒的间隔触发事件。大量耗费内从的脚本也可能使事件发生偏差。</p>\n<p><code>Timer</code>类的实例还有以下几个属性：</p>\n<ol>\n<li><code>currentCount</code>，只读，当前触发的总次数。</li>\n<li><code>delay</code>，计时器时间的延迟，单位是毫秒。</li>\n<li><code>repeatCount</code>，计时器运行的总次数。</li>\n<li><code>running</code>，只读，计时器的当前状态，如果正在运行则为<code>true</code>，否则为<code>false</code>。</li>\n</ol>\n<p><code>Timer</code>类的实例还有以下几个公共方法：</p>\n<ol>\n<li><code>reset</code>，如果计时器正在运行，则停止计时器，并且将<code>currentCount</code>设为<code>0</code>，类似于秒表的重置按钮。</li>\n<li><code>start</code>，如果计时器还没启动，启动计时器。</li>\n</ol>\n","path":"2014-01-15-as3-timer.json","year":"2014","month":"01","day":"15","tags":["Flash"]},{"link":"/posts/2014/01/14/flash-share-object-data.html","title":"使用ShareObject中的data","summary":"<p>昨天讨论了Flash中的“cookie”，<code>ShareObject</code>的简单使用方式，今天来讨论一下如何读写这个“cookie“中的数据。</p>\n<p>通常，我们会使用<code>ShareObject</code>的静态方法<code>getLocal</code>获取一个本地的共享对象：</p>\n<pre><code>var test:SharedObject = SharedObject.getLocal(&quot;test&quot;);\n</code></pre><p>然后我们可以访问<code>test</code>的<code>data</code>属性，对这个共享对象的数据进行读写操作。注意，这个<code>data</code>本身是只读的，所以以下的代码是无效的：</p>\n<pre><code>test.data = &quot;someValue&quot;;\n</code></pre><p>我们可以直接在<code>data</code>上存储一些数据，可以是任何ActionScript或者JavaScript类型的对象（数组、数字、布尔值、对象等）：</p>\n<pre><code>test.data.number = 1;\ntest.data.string = &quot;String&quot;;\ntest.data.obj = {&quot;a&quot;: 1, &quot;b&quot;: &quot;string&quot;};\ntest.data.arr = [2, &quot;a&quot;];\ntest.data.sprite = new Sprite();\n</code></pre><p>当程序关闭的时候，这些数据会保存到本地文件中，下次只要使用同样名称的共享对象就可以把这些数据读取回来。</p>\n<p>要删除共享对象的数据，要使用<code>delete</code>运算符来删除：</p>\n","path":"2014-01-14-flash-share-object-data.json","year":"2014","month":"01","day":"14","tags":["Flash"]},{"link":"/posts/2014/01/13/flash-share-object.html","title":"Flash的“cookie” ShareObject","summary":"<p><code>ShareObject</code>类用于在用户计算机或者服务器上读取和存储有限的数据。在用户计算机上的存储类似于浏览器的cookie，远程共享对象类似于实时数据传输设备，需要Adobe Flash Media Server，这边就简单带过远程共享对象，主要讨论类似cookie的使用方式。</p>\n<p>使用共享对象可以执行以下操作：</p>\n<ol>\n<li>本地持久化，类似于浏览器cookie。在用户计算机上存储数据可以减少服务器的负担。</li>\n<li>在Flash Media Server上存储并共享数据。通过远程共享对象可以让多个客户端共享数据。</li>\n</ol>\n<p>当应用程序关闭的时候，会刷新共享对象或者写入磁盘。使用本地磁盘空间会受到一些限制，用户可以通过设置界面管理每个域可用的磁盘空间。在调用<code>getLocal</code>和<code>flush</code>这两个方法的时候需要执行检查是否能操作成功。</p>\n<p>注意，为了使设置界面的对话框显示完全，<code>swf</code>文件的宽度至少为215像素，高度至少为138像素。</p>\n<p>像浏览器cookie一样使用共享对象，例如：</p>\n<pre><code>var so:SharedObject = SharedObject.getLocal(&quot;savedData&quot;);\n</code></pre><p>以上的代码会返回一个共享对象的实例，包含以下几个属性：</p>\n<ol>\n<li><code>client</code>，表示对其调用回调方法的对象。</li>\n<li><code>data</code>，只读，表示这个共享对象的数据，可以视为一个键值对。</li>\n<li><code>defaultObjectEncodeing</code>，表示共享对象的默认对象编码。</li>\n<li><code>fps</code>，只写，指定每秒种客户端对共享对象所做的更改被发送到服务器的次数。</li>\n<li><code>objectEncodeing</code>，表示这个共享对象的对象编码。</li>\n</ol>\n","path":"2014-01-13-flash-share-object.json","year":"2014","month":"01","day":"13","tags":["Flash"]},{"link":"/posts/2014/01/08/flash-security-domain.html","title":"使用安全域","summary":"<p><code>SecurityDomain</code>类代表当前安全性“沙箱”，也称为“安全域”。通过此类的一个实例传递给<code>Loader</code>的<code>load</code>方法，可以请求将所加载的媒体防止到特殊的沙箱中。</p>\n<p>这个类只有一个静态属性<code>currentDomain</code>，只读，用来获取当前的安全域。通过在<code>load</code>方法的第二个参数<code>context</code>中设置<code>securityDomain</code>这个属性，当前<code>swf</code>文件可以授信给所加载的<code>swf</code>文件，而所加载的<code>swf</code>文件的授信则需要通过URL策略文件：</p>\n<pre><code>var context:LoaderContext = new LoaderContext(true); \ncontext.securityDomain = SecurityDomain.currentDomain; \n</code></pre><p>用这种方式加载的<code>swf</code>文件的权力比用<code>allowDomain</code>授权的更大。把<code>swf</code>加载到同一个安全域中，等同于能做任何事，这些<code>swf</code>文件可以在当前域下面做任意操作，例如：</p>\n<ol>\n<li>获取当前<code>swf</code>中的任意引用。</li>\n<li>读取当前<code>swf</code>所在域的文件。</li>\n<li>读取主域上的共享对象。</li>\n<li>获取通过当前<code>swf</code>所在域建立的共享连接通讯。</li>\n</ol>\n<p>所以在引入跨域<code>swf</code>文件到当前的安全域下面千万要注意，不要引入恶意的<code>swf</code>文件。</p>\n","path":"2014-01-08-flash-security-domain.json","year":"2014","month":"01","day":"08","tags":["Flash"]},{"link":"/posts/2014/01/07/flash-application-domain.html","title":"使用应用程序域","summary":"<p>应用程序域<code>ApplicationDomain</code>的用途是存储ActionScript 3.0的定义表。<code>swf</code>文件中的所有代码都被定义在应用程序域中。通过不同的应用程序域，可以允许同一个类有多个定义，并且还允许子级重用父级定义。</p>\n<p>在使用<code>Loader</code>的<code>load</code>方法的时候，通过<code>context</code>这个参数可以指定加载内容的应用程序域，例如：</p>\n<pre><code>ldr = new Loader(); \nvar req:URLRequest = new URLRequest(&quot;Greeter.swf&quot;); \nvar ldrContext:LoaderContext = new LoaderContext(false, ApplicationDomain.currentDomain); \nldr.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler); \nldr.load(req, ldrContext);\n</code></pre><p>以上的代码把加载的<code>swf</code>文件放入到当前<code>swf</code>文件的应用程序域中。在使用应用程序域时，要记住以下几点：</p>\n<ol>\n<li><code>swf</code>文件中的所有代码都会被定义在该应用程序域中。</li>\n<li>已加载的类尽在其父级中没有相关定义时才进行定义，不能用较新的定义覆盖已加载类的定义。</li>\n</ol>\n<p>在加载其他<code>swf</code>文件的时候，我们可以通过创建系统域的子与划分子级<code>swf</code>文件：</p>\n<pre><code>var appDomainA:ApplicationDomain = new ApplicationDomain(); \nvar contextA:LoaderContext = new LoaderContext(false, appDomainA); \nvar loaderA:Loader = new Loader(); \nloaderA.load(new URLRequest(&quot;application2.swf&quot;), contextA);\n</code></pre>","path":"2014-01-07-flash-application-domain.json","year":"2014","month":"01","day":"07","tags":["Flash"]},{"link":"/posts/2014/01/06/flash-loader-context.html","title":"AS3 LoaderContext","summary":"<p><code>LoaderContext</code>作为<code>Loader</code>类的<code>load</code>方法的第二个参数，声明加载媒体的上下文选项。使用<code>load</code>方法加载媒体（例如<code>swf</code>文件），需要作出两个决定：</p>\n<ol>\n<li>将<code>swf</code>文件放置到哪个安全域中。</li>\n<li>将<code>swf</code>文件放置到该安全域的哪个应用程序域中。</li>\n</ol>\n<p>这两个决定对应于<code>LoaderContext</code>里面的两个属性：<code>securityDomain</code>和<code>applicationDomain</code>。除了这两个属性之外，<code>LoaderContext</code>还指定了一些其他属性，声明这个媒体相关的上下文。</p>\n<p>第一个属性是<code>allowCodeImport</code>，指定是否可以使用<code>Loader</code>对象包含的内容（例如<code>swf</code>文件）导入到调用方的安全沙箱。当设置成<code>false</code>之后，加载的文件会被限制只能执行安全操作，例如加载图像。这个属性可以防止加载的文件执行不安全的操作。</p>\n<p>第二个属性是<code>checkPolicyFile</code>，指定在开始加载之前，是否尝试从目标服务器下载URL策略文件。如果不需要对正在加载的图像进行像素级的访问，或者加载的内容是<code>swf</code>文件，建议把这个属性设置成<code>false</code>。</p>\n<p>第三个属性是<code>parameters</code>，指定要传递到内容的<code>LoaderInfo</code>对象的参数。通常是通过分析请求URL来获得参数的值，如果设置了这个属性，就会使用这个值而忽略URL上面的参数。这个属性在调用<code>loadBytes</code>方法特别有效，因为<code>loadBytes</code>是没有所谓的URL的。</p>\n<p>第四个属性是<code>requestedContentParent</code>，指定内容的父对象。通常内容的父对象为<code>Loader</code>对象，设置了这个属性之后则会使用这个属性指定的对象作为父对象，除非发生运行时错误，例如触发<code>SecurityErrorEvent</code>。</p>\n<p>最后介绍一下构造方法，接受三个参数：</p>\n<ol>\n<li><code>checkPolicyFile</code>。</li>\n<li><code>applicationDomain</code>。</li>\n<li><code>securityDomain</code>。</li>\n</ol>\n<p>分别对应于三个属性，设置初始值。最后来个例子，从另一个域加载<code>swf</code>文件并检查策略文件，还将加载的<code>swf</code>文件添加到与<code>Loader</code>对象的类相同的应用程序域中：</p>\n","path":"2014-01-06-flash-loader-context.json","year":"2014","month":"01","day":"06","tags":["Flash"]},{"link":"/posts/2014/01/03/flash-bytearray.html","title":"使用ByteArray","summary":"<p>在Flash中，我们可以使用<code>ByteArray</code>来操作二进制数据：</p>\n<pre><code>var stream:ByteArray = new ByteArray();\n</code></pre><p>使用<code>ByteArray</code>，可以把数据按照流的形式组织成一个<code>ByteArray</code>。<code>ByteArray</code>提供了<code>readXXX</code>和对应的<code>writeXXX</code>方法，按照同样调用顺序把数据读取和写入到<code>ByteArray</code>中，实现对数据的序列化。例如，我们可以这么写：</p>\n<pre><code>bytes.writeUTFBytes(&quot;someString&quot;);\nbytes.writeFloat(1);\n</code></pre><p>可以这么读：</p>\n<pre><code>var str:String = bytes.readUTFBytes();\nvar float:Float = bytes.readFloat();\n</code></pre><p><code>ByteArray</code>的<code>position</code>属性记录当前指针的位置，初始值为<code>0</code>。当读取或者写入<code>ByteArray</code>的时候，会更新<code>position</code>属性以指向上次读取或者写入字节后的位置：</p>\n<pre><code>bytes.writeUTFBytes(&quot;Hello World!&quot;);\n// position + 12\n</code></pre><p>可以更改这个<code>position</code>属性的值实现随机读写的功能。</p>\n<p><code>ByteArray</code>还提供了两个属性指示其长度。其中<code>bytesAvailable</code>表示当前位置（<code>position</code>）到结尾处还剩多少个字节，而<code>length</code>则表示整个<code>ByteArray</code>的长度。</p>\n","path":"2014-01-03-flash-bytearray.json","year":"2014","month":"01","day":"03","tags":["Flash"]},{"link":"/posts/2014/01/02/html5-formdata.html","title":"使用FormData","summary":"<p>ABCDEFG</p>\n<p>边界字符串是由浏览器生成的一个随机的字符串。使用<code>FormData</code>，我们可以方便地构造出<code>multipart/form-data</code>需要的请求体，还可以通过<code>XMLHttpRequest</code>来提交。jQuery也支持<code>FormData</code>：</p>\n<pre><code>var formData = new FormData();\nformData.append(&quot;name1&quot;, &quot;value1&quot;);\nformData.append(&quot;name2&quot;, &quot;value2&quot;);\n$.ajax({\n  url: &quot;path/to/server&quot;,\n  data: formdata,\n}).done(...);\n</code></pre><p>最后还是那句，IE10才支持<code>FormData</code>！</p>\n","path":"2014-01-02-html5-formdata.json","year":"2014","month":"01","day":"02","tags":["html5"]},{"link":"/posts/2013/12/31/html5-file-api.html","title":"HTML5的File API","summary":"<p>如果我们要上传文件，以前只能使用表单的<code>file</code>控件进行上传，而且只能把这个表单POST出去。这时候我们如果需要做类似分块上传的功能，特别是上传大文件，例如视频等，只能通过Flash或者浏览器插件来做这些分块上传的功能。</p>\n<p>现在HTML5提供了一套文件API，使用这套API配合<code>FormData</code>就可以实现文件分块、Ajax上传二进制数据等功能。今天先来介绍File API。</p>\n<p>File API提供了一个接口供我们访问文件信息和文件的二进制内容。可以通过表单上的<code>file</code>控件的<code>files</code>属性获取<code>File</code>对象：</p>\n<pre><code>var file = $(&quot;#upload_file&quot;).files[0];\n</code></pre><p><code>File</code>实现了<code>Blob</code>这个接口，所以它能处理二进制数据。<code>File</code>对象有以下几个属性，全部都是只读的：</p>\n<ol>\n<li><code>lastModifiedDate</code>，表示这个文件的修改日期。</li>\n<li><code>name</code>，表示这个文件的文件名。</li>\n</ol>\n<p>还有两个<code>Blob</code>接口的属性：</p>\n<ol>\n<li><code>size</code>，表示这个文件的大小。</li>\n<li><code>type</code>，表示这个文件的MIME类型。</li>\n</ol>\n<p>使用<code>Blob</code>接口的<code>slice</code>方法可以处理文件的内容：</p>\n<pre><code>blob = file.slice(startPos, endPos);\n</code></pre>","path":"2013-12-31-html5-file-api.json","year":"2013","month":"12","day":"31","tags":["html5"]},{"link":"/posts/2013/12/30/html-form-multipart.html","title":"HTML Form的enctype","summary":"<p>表单的这个特性用来声明这个表单的内容类型。当我们没有显式声明这个特性的值的时候，使用的是其默认值<code>application/x-www-form-urlencoded</code>，对表单中的每个控件的值进行URL编码，提交编码之后的字符串。</p>\n<p>这种编码方式满足大部分的场景，但是当我们需要传输一些非文本数据（例如文件、二进制数据等），这种方式是低效的。这时候我们需要把表单的<code>enctype</code>特性设置成<code>multipart/form-data</code>。</p>\n<p>设置成这个值之后提交的表单，请求头的<code>Content-Type</code>会变成<code>multipart/form-data</code>。还需要跟上一个字符串，这个字符串不能存在于每个部分当中。这样表单接收方就可以根据这个字符串正确地分割请求体。分割后的每一个部分对应表单中的一个“控件”，里面包含了这个部分的名字和值。</p>\n<p>每一个部分由以下几个部分组成：</p>\n<ol>\n<li><code>Content-Disposition</code>，固定为<code>form-data</code>。</li>\n<li><code>name</code>，声明这个部分“控件”的名称，例如一般表单提交的时候就是表单控件对应的<code>name</code>特性的值。</li>\n</ol>\n<p>例如：</p>\n<pre><code>Content-Disposition: form-data; name=&quot;mycontrol&quot;\n</code></pre><p>然后一个回车换行之后就是这个部分对应的值。默认的<code>Content-Type</code>是<code>text/plain</code>，即是一个文本。当这个部分是一个文件或者二进制数据，需要显式声明这个部分的<code>Content-Type</code>，例如：</p>\n<pre><code>Content-Disposition: file; filename=&quot;file2.gif&quot;\nContent-Type: image/gif\n</code></pre><p>这种部分还需要一个额外的头信息，<code>filename</code>，声明这个文件或者二进制块的名称，方便表单接收方获取文件的原来的名字。</p>\n","path":"2013-12-30-html-form-multipart.json","year":"2013","month":"12","day":"30","tags":["html"]},{"link":"/posts/2013/12/24/flash-security-loading-data.html","title":"Flash安全性之加载数据","summary":"<p>类似于HTML中的Ajax或者表单提交，Flash必须也可以与服务端交换数据。比HTML要灵活一点的是，Flash可以通过在站点上配置策略文件允许跨域访问，而Ajax则不能（当然，现在可以配置服务端的响应头实现跨域的Ajax……）。</p>\n<p>在Flash中可以使用<code>URLLoader</code>或者<code>URLStream</code>的<code>load</code>方法加载数据：</p>\n<pre><code>var request:URLRequest = new URLRequest(&quot;path/to/res&quot;);\nvar urlLoader:URLLoader = new URLLoader(request);\nurlLoader.load();\n</code></pre><p>跟Ajax类似，加载的过程是异步的，需要监听事件才能获取到加载完之后的数据。Flash内建了<code>Progress</code>的事件，这个比传统的Ajax真要方便多了（虽然貌似现在HTML5也有……）。</p>\n<p>比HTML跟进一步的是，Flash可以直接连接Socket，当然，也需要配置策略文件保护安全。Socket的策略文件可以从以下几个地方获取：</p>\n<ol>\n<li>端口<code>843</code>，这个是主策略文件，相当与<code>http://host/crossdomain.xml</code>。</li>\n<li>与主套接字连接相同的端口。</li>\n<li>之外的其他端口，由其他策略文件指定。</li>\n</ol>\n<p>在Flash中可以调用<code>Socket.connet</code>或者<code>XMLSocket.connet</code>来链接套接字：</p>\n<pre><code>var socket:Socket = new Socket();\nsocket.connet(&quot;host&quot;, 12345);\n</code></pre><p>当需要传送敏感数据的时候，可以使用传输层安全性（TLS）或者套接字安全性（SSL）来保护数据，可以使用<code>HTTPS</code>协议来连接。</p>\n","path":"2013-12-24-flash-security-loading-data.json","year":"2013","month":"12","day":"24","tags":["Flash"]},{"link":"/posts/2013/12/23/flash-security-accessing-loaded-media-as-data.html","title":"Flash安全性之访问加载媒体中的数据","summary":"<p>默认情况下，无法从其他沙箱中加载的媒体（如图形、音频、视频等）获取像素数据或者音频、视频数据。可以通过以下方式授予对应的权限：</p>\n<ol>\n<li>在目标媒体的内容中调用<code>Security.allowDomain</code>。</li>\n<li>在目标媒体的服务器上添加策略文件（<code>crossdomain.xml</code>）。</li>\n</ol>\n<h3 id=\"-\">访问位图数据</h3>\n<p><code>BitmapData</code>对象的<code>draw</code>和<code>drawWithQuality</code>方法，可以将任何显示对象的当前显示像素绘制到<code>BitmapData</code>对象，包括<code>MovieClip</code>、<code>Bitmap</code>等。需要满足以下条件：</p>\n<ol>\n<li>源对象和目标对象需要在同一个域，或者目标对象调用<code>Security.allowDomain</code>授权的域。</li>\n<li>源对象和调用<code>draw</code>方法的对象在同一个域，或者源服务器包含一个授予调用域权限的策略文件。</li>\n</ol>\n<p>如果使用<code>Loader</code>去加载图像，则可以指定第二个参数<code>context</code>，配置<code>checkPolicyFile</code>为<code>true</code>，则Flash Player会在加载图像的服务器上面查找策略文件。同理，文本对象的<code>img</code>标签也可以配置<code>checkPolicyFile</code>特性来检查策略文件。</p>\n<h3 id=\"-\">访问声音数据</h3>\n<p>以下是一些跟声音相关的安全限制：</p>\n<ol>\n<li><code>SoundMixer.computeSpectrum</code>。</li>\n<li><code>SoundMixer.stopAll</code>。</li>\n<li><code>Sound.id3</code>。</li>\n</ol>\n","path":"2013-12-23-flash-security-accessing-loaded-media-as-data.json","year":"2013","month":"12","day":"23","tags":["Flash"]},{"link":"/posts/2013/12/18/flash-security-cross-scripting.html","title":"Flash安全性之跨脚本访问","summary":"<p>如果使用AS3.0编写的两个<code>swf</code>文件来自同一个域，那么它们是可以互相访问和修改另一个文件的变量、对象、属性和方法。反之则视为是跨脚本访问。</p>\n<p>在默认情况下，Flash Player不允许这种跨域的脚本访问。通过调用<code>Security.allowDomain</code>，可以授予其他域的<code>swf</code>文件编写其脚本的权限。例如：</p>\n<pre><code>Security.allowDomain(&quot;siteA.com&quot;);\n</code></pre><p>这样，这个<code>swf</code>文件就可以被<code>siteA.com</code>中的<code>swf</code>访问其变量、对象、属性和方法。</p>\n<p>注意，调用<code>Security.allowDomain</code>是不对称的，这个<code>swf</code>文件想要访问<code>siteA.com</code>中的<code>swf</code>文件需要在<code>siteA.com</code>的<code>swf</code>文件中也调用<code>allowDomain</code>。</p>\n<h3 id=\"stage-\">Stage安全性</h3>\n<p><code>stage</code>对象的所有者是地一个加载的<code>swf</code>文件。<code>stage</code>对象的一些属性和方法只能用于在所有者同一安全沙箱中的<code>swf</code>文件，例如<code>stage.align</code>或者<code>stage.addChild</code>等。</p>\n<p>在所这者的<code>swf</code>文件中调用<code>allowDomain</code>可以授予其他安全沙箱中的<code>swf</code>访问<code>stage</code>的这些属性和方法。</p>\n<h3 id=\"-\">遍历显示列表</h3>\n<p>一个<code>swf</code>文件能够访问从其他沙箱中加载的显示对象也受到一定的限制。如果需要能访问到其他沙箱中的<code>swf</code>文件，需要在目标文件中调用<code>allowDomain</code>授予相应的权限。</p>\n<h3 id=\"-\">事件安全性</h3>\n","path":"2013-12-18-flash-security-cross-scripting.json","year":"2013","month":"12","day":"18","tags":["Flash"]},{"link":"/posts/2013/12/17/flash-security-loading-content.html","title":"Flash安全性之加载内容","summary":"<p>Flash可以加载多种类型的内容，作为显示对象显示在舞台上，包括<code>swf</code>影片、图像、声音、视频等。</p>\n<h3 id=\"-swf-\">加载SWF和图像</h3>\n<p>使用<code>Loader</code>可以加载<code>swf</code>文件或者图像。可以加载属于自己沙箱权限范围之内的资源，例如受信任的<code>swf</code>可以加载本地或者网络的资源等。下面是使用<code>Loader</code>的一个例子：</p>\n<pre><code>var ldr:Loader = new Loader(); \nvar url:String = &quot;http://www.unknown.example.com/content.swf&quot;; \nvar urlReq:URLRequest = new URLRequest(url); \nldr.load(urlReq); \naddChild(ldr);\n</code></pre><p><code>load</code>方法可以传入第二个参数<code>context</code>，定义如何使用加载的上下文。这个参数有以下几个比较重要的属性：</p>\n<ol>\n<li><code>checkPolicyFile</code>，当加载图片的时候使用该属性。如果图像文件所在的域与包含<code>Loader</code>对象的文件所在的域不同，则指定此属性。当设置成<code>true</code>的时候，会检查远程服务器上面的策略文件。如果授予了适当的权限，<code>swf</code>文件就可以访问加载图像中的数据（例如调用<code>BitmapData.draw</code>等操作图像的像素等）。</li>\n<li><code>securityDomain</code>，当加载<code>swf</code>的时候使用该属性。有两个可选的取值：<code>null</code>或者<code>SecurityDomain.currentDomain</code>。如果指定为后者，则视为远程<code>swf</code>文件在本地服务器加载一样，可以自由访问本地<code>swf</code>文件的属性和方法。请注意，多数情况可以通过执行普通加载操作然后让加载的<code>swf</code>文件调用<code>Security.allowDomain</code>方法来取代沙箱导入。由于加载的<code>swf</code>文件将位于自己的原始沙箱中，并因而能够访问自己实际服务器上的资源，因此后一种方法会更易于使用。</li>\n<li><code>applicationDomain</code>，当加载ActionScript 3.0编写的<code>swf</code>才会使用这个属性。当加载文件时，可以指定文件应放置在特定的应用程序域中，而不是默认放置在一个新的应用程序域中。</li>\n</ol>\n<h3 id=\"-\">加载声音和视频</h3>\n<p>允许任何内容使用<code>Sound.load</code>、<code>NetConnection.connect</code>和<code>NetStream.play</code>方法从网络源加载声音和视频，只能与本地文件系统内容交互的沙箱中的内容除外。</p>\n","path":"2013-12-17-flash-security-loading-content.json","year":"2013","month":"12","day":"17","tags":["Flash"]},{"link":"/posts/2013/12/16/flash-security-full-screen-interactive-mode-security.html","title":"Flash安全性之全屏交互模式安全性","summary":"<p>Flash Player 11.3和更高版本支持全屏交互模式，即昨天讨论的全屏模式下，在Flash Player 11.3之前是不支持文本输入的。而在11.3之后的版本则可以通过配置参数让浏览器中的Flash Player在全屏模式下也能支持文本输入。</p>\n<p>若要进入全屏交互模式，首先需要把<code>stage</code>的<code>displayState</code>属性设置为<code>StageDisplayState.FULL_SCREEN_INTERACTIVE</code>常量。</p>\n<p>对于运行在远程沙箱中的<code>swf</code>文件，需要额外配置参数，允许<code>swf</code>进入全屏交互模式。在<code>object</code>或者<code>embed</code>标签中配置<code>allowFullScreenInteractive</code>参数，并将其配置成<code>true</code>：</p>\n<pre><code>&lt;object&gt;\n  &lt;param name=&quot;allowFullScreenInteractive&quot; value=&quot;true&quot; /&gt;\n&lt;/object&gt;\n</code></pre><p>或者：</p>\n<pre><code>&lt;embed allowFullScreenInteractive=&quot;true&quot; /&gt;\n</code></pre><p>与一般的全屏模式相同，仅当在响应鼠标事件和键盘事件时，才能调用启动全屏交互模式的ActionScript。也会显示如何退出全屏模式的提示信息。</p>\n<p>管理员可以通过在<code>mms.cfg</code>中设置<code>FullScreenInteractiveDisable = 1</code>对浏览器中运行的<code>swf</code>文件禁用全屏交互模式。</p>\n","path":"2013-12-16-flash-security-full-screen-interactive-mode-security.json","year":"2013","month":"12","day":"16","tags":["Flash"]},{"link":"/posts/2013/12/13/flash-security-full-screen-mode-security.html","title":"Flash安全性之全屏模式安全性","summary":"<p>要进入全屏模式，要将<code>stage</code>的<code>displayState</code>属性设置为<code>StageDisplayState.FULL_STAGE</code>常量。</p>\n<p>对于在远程沙箱中运行的<code>swf</code>文件，有一些安全注意事项。第一个就是要在<code>object</code>或者<code>embed</code>标签中添加<code>allowFullScreen</code>参数，设置成<code>true</code>：</p>\n<pre><code>&lt;object&gt;\n  &lt;param name=&quot;allowFullScreen&quot; value=&quot;true&quot; /&gt;\n&lt;/object&gt;\n</code></pre><p>或者：</p>\n<pre><code>&lt;embed allowFullScreen=&quot;true&quot; /&gt;\n</code></pre><p>仅当在响应鼠标事件或者键盘事件时才会调用启动全屏模式的ActionScript。当内容进入全屏模式时，程序会显示一条信息，例如<code>按ESC退出全屏模式</code>。</p>\n<p>在全屏模式下会限制使用键盘，禁止文本输入。</p>\n<p>在独立的播放器，例如计算机上的Flash Player上播放的<code>swf</code>文件，始终允许进入全屏模式，而且也完全支持键盘。</p>\n<p>如果修改<code>stage.displayState</code>的<code>swf</code>文件跟<code>stage</code>所有者不是位于同一个安全沙箱，会引发异常。管理员也可以通过在<code>mms.cfg</code>文件中设置<code>FullScreenDisable = 1</code>对浏览器中运行的<code>swf</code>文件禁用全屏模式。</p>\n","path":"2013-12-13-flash-security-full-screen-mode-security.json","year":"2013","month":"12","day":"13","tags":["Flash"]},{"link":"/posts/2013/12/12/flash-security-restricting-networking-apis.html","title":"Flash安全性之限制网络API","summary":"<p>可以使用两种方式限制网络API。这些限制不能通过代码覆盖。</p>\n<h3 id=\"-\">阻止的端口</h3>\n<p>Flash Player和Adobe AIR对某些端口的HTTP访问设有限制。通常用于非HTTP类型服务器的某些标准端口上不允许使用HTTP请求。</p>\n<p>适用于端口阻止的API包括：</p>\n<ol>\n<li><code>FileReference</code>的<code>download</code>、<code>upload</code>方法。</li>\n<li><code>Loader</code>的<code>load</code>、<code>loadBytes</code>方法。</li>\n<li><code>navigateToURL</code>方法。</li>\n<li><code>NetConnection</code>的<code>call</code>、<code>connect</code>方法。</li>\n<li><code>NetStream</code>的<code>play</code>方法。</li>\n<li><code>Security.loadPolicyFile</code>。</li>\n<li><code>sendToURL</code>。</li>\n<li><code>Sound</code>、<code>URLLoader</code>和<code>URLStream</code>的<code>load</code>方法。</li>\n</ol>\n<p>端口阻止也适用于文本字段中有关<code>url</code>的字段，例如<code>img</code>、<code>object</code>或者<code>embed</code>等。</p>\n<h3 id=\"-allownetworking-\">使用allowNetworking参数</h3>\n<p>可以在<code>object</code>或者<code>embed</code>标签中设置<code>allowNetworking</code>参数来控制<code>swf</code>文件访问网络功能。它可以有以下的取值：</p>\n","path":"2013-12-12-flash-security-restricting-networking-apis.json","year":"2013","month":"12","day":"12","tags":["Flash"]},{"link":"/posts/2013/12/11/flash-security-permission-controls.html","title":"Flash安全性之权限控制","summary":"<p>Flash对控制严格采用一种权力层次，依次是管理员设置、用户设置、网站设置和作者设置。前者拥有比后者更高的优先级，后者不能覆盖前者的限制。</p>\n<h3 id=\"-\">管理员控制</h3>\n<p>这里的管理员指的是计算机的管理用户。管理员控制有两种形式。第一种是<code>mms.cfg</code>文件。该文件包含管理员用于管理隐私控制、本地文件安全性、套接字连接等功能。该文件的大部分功能不能被ActionScript访问，并且只能由计算机管理员进行修改。该文件的路径是：</p>\n<pre><code>Windows：system\\Macromed\\Flash\\mms.cfg\nMac：app support/Macromedia/mms.cfg\n</code></pre><p>第二种形式是全局 Flash Player 信任目录。这个目录中指定的<code>swf</code>文件分配到受信任的沙箱，不仅可以访问本地文件，也可以使用网络。该目录通常的位置是：</p>\n<pre><code>Windows：system\\Macromed\\Flash\\FlashPlayerTrust\napp support/Macromedia/FlashPlayerTrust\n</code></pre><p>这个目录可以存放若干个文本文件，标识出哪些路径下面的文件视为受信任的文件，例如：</p>\n<pre><code># Trust files in the following directories: \nC:\\Documents and Settings\\All Users\\Documents\\SampleApp\n</code></pre><h3 id=\"-\">用户控制</h3>\n<p>用户控制可以从这几个方面指定。第一个是设置UI和设置管理器，就是上下文菜单中的Flash设置。里面可以设置包括摄像头、麦克风、本地存储等设置。在<code>mms.cfg</code>文件中的设置在这里并不可见。</p>\n","path":"2013-12-11-flash-security-permission-controls.json","year":"2013","month":"12","day":"11","tags":["Flash"]},{"link":"/posts/2013/12/10/flash-security-sandboxes.html","title":"Flash安全性之安全沙箱","summary":"<p>在HTML中，传统Ajax的限制就是跨域。在Flash中，安全性比较复杂，因为<code>swf</code>文件可以在本地通过Flash Player直接播放，也可以嵌入HTML页面中播放。在不同的环境中的<code>swf</code>文件的安全策略是不一样的。我们可以通过访问<code>Security</code>的只读静态属性<code>sandboxType</code>来确定<code>swf</code>文件当前是处于那种沙箱当中。</p>\n<h3 id=\"-\">远程沙箱</h3>\n<p>第一种情况是来自Internet的资源，例如在页面播放的<code>swf</code>文件等。这时候，Flash Player会根据资源所在的域把它们分到不同的安全沙箱中。默认情况下，这些资源只能访问自身所在的安全沙箱中的内容。这个策略是基于域控制的，可以通过Web站点许可（通过昨天介绍的<code>crossdomain.xml</code>来配置）或者作者许可（调用<code>Security.allowDomain</code>方法），可以允许远程的<code>swf</code>文件访问其他安全沙箱中的资源。</p>\n<p>当<code>swf</code>文件处于远程沙箱中，<code>Security.sandboxType</code>为<code>Security.REMOTE</code>。来自Internet的资源无法加载任何本地文件和资源。</p>\n<h3 id=\"-\">本地沙箱</h3>\n<p>本地文件的意思是通过<code>file</code>协议或者统一命名约定（UNC）路径引用的任何文件，例如一个本地HTML文件嵌入的<code>swf</code>或者直接在本地Flash Player播放的<code>swf</code>。本地<code>swf</code>文件有四种安全沙箱的类型，映射到<code>Security.sandboxType</code>这个静态只读属性：</p>\n<ol>\n<li><code>Security.LOCAL_WITH_FILE</code>，表示<code>swf</code>文件是本地文件，但是未受信任，且没有使用网络名称发布。此<code>swf</code>文件可以从本地读取数据，但无法与Internet进行通讯。</li>\n<li><code>Security.LOCAL_WITH_NETWORK</code>，表示<code>swf</code>文件是本地文件，但是未受信任，但已使用网络名称进行发布。此<code>swf</code>文件可以与Internet通讯，但是无法读取本地数据。</li>\n<li><code>Security.LOCAL_TRUSTED</code>，表示<code>swf</code>已受信任。此<code>swf</code>文件既可以读取本地数据，也可以访问Internet。</li>\n<li><code>Security.APPLICATION</code>，表示<code>swf</code>文件在AIR应用程序中运行，并随AIR文件一起安装。此<code>swf</code>文件可以访问AIR应用程序沙箱的任何文件。</li>\n</ol>\n<p>其中<code>Security.LOCAL_WITH_FILE</code>跟<code>Security.LOCAL_WITH_NETWORK</code>这两类安全沙箱中的内容是无法互相访问的。</p>\n<p>经过实验观察，直接从本地Flash Player播放的<code>swf</code>文件显示的是<code>Security.LOCAL_TRUSTED</code>，表示这个<code>swf</code>文件既可以访问本地数据也可以访问Internet，不受基于域的沙箱规则控制。而嵌入在远程HTML页面中的<code>swf</code>文件显示的是<code>Security.REMOTE</code>，这种情况下要进行跨域访问需要在远程服务器中配置We站点许可，也就是<code>crossdomain.xml</code>。</p>\n","path":"2013-12-10-flash-security-sandboxes.json","year":"2013","month":"12","day":"10","tags":["Flash"]},{"link":"/posts/2013/12/09/flash-crossdomain-xml.html","title":"crossdomain.xml","summary":"<p><code>crossdomain.xml</code>是Flash授权一个客户端（Flash Player等）跨域访问数据的一个策略文件。当一个客户端请求不属于其所在域的资源时，远程服务器需要有一个<code>crossdomain.xml</code>文件去判断这个客户端所在的域是否有权限去访问这个资源。</p>\n<p>一个简单的<code>crossdomain.xml</code>的例子如下：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;    \n&lt;!DOCTYPE cross-domain-policy SYSTEM &quot;http://www.adobe.com/xml/dtds/cross-domain-policy.dtd&quot;&gt;\n&lt;cross-domain-policy&gt;\n  &lt;site-control permitted-cross-domain-policies=&quot;master-only&quot;/&gt;\n  &lt;allow-access-from domain=&quot;*.example.com&quot;/&gt;\n  &lt;allow-access-from domain=&quot;www.example.com&quot;/&gt;\n  &lt;allow-http-request-headers-from domain=&quot;*.adobe.com&quot; headers=&quot;SOAPAction&quot;/&gt;\n&lt;/cross-domain-policy&gt;\n</code></pre><p>其根元素是<code>cross-domain-policy</code>，它可以包含以下几个子元素：</p>\n<ol>\n<li><code>site-control</code>，声明该域接受哪些策略文件。该元素只有一个特性，就是<code>permitted-cross-domain-policies</code>，它可以接受以下几个取值：<ol>\n<li><code>none</code>，不接受任何策略文件，包括自己。</li>\n<li><code>master-only</code>，只接受主策略文件，即定位在<code>http://your.domain/</code>的根下面的<code>crossdomain.xml</code>。</li>\n<li><code>by-content-type</code>，所有<code>Content-Type</code>为<code>text/x-cross-domain-policy</code>都视为可接受的策略文件。</li>\n<li><code>by-ftp-filename</code>，所有文件名为<code>crossdomain.xml</code>的都视为可接受的策略文件。</li>\n<li><code>all</code>，所有策略文件都可以被接受。</li>\n</ol>\n</li>\n<li><code>allow-access-from</code>，声明这个域能被访问的策略。这个元素有以下几个特性：</li>\n</ol>\n","path":"2013-12-09-flash-crossdomain-xml.json","year":"2013","month":"12","day":"09","tags":["Flash"]},{"link":"/posts/2013/12/08/hp-other-about-repaints-and-reflows.html","title":"High Performance JavaScript 读书笔记之 还有一些关于Repaint和Reflow","summary":"<h3 id=\"-\">缓存关于布局的信息</h3>\n<p>之前已经讨论过了，虽然浏览器会把触发Repaint和Reflow的DOM操作用一个队列缓存起来，但是只要我们去访问有关布局的属性（例如各种<code>offset</code>），这时候浏览器为了保证返回的值是正确的，只能把操作队列清空，把之前的DOM操作应用到页面中去。例如以下的代码是非常低效的：</p>\n<pre><code>myElement.style.left = 1 + myElement.offsetLeft + &#39;px&#39;;\nmyElement.style.top = 1 + myElement.offsetTop + &#39;px&#39;;\nif (myElement.offsetLeft &gt;= 500) {\n  stopAnimation();\n}\n</code></pre><p>由于在设置DOM的位置的时候访问了<code>offsettLeft</code>和<code>offsetTop</code>两个有关布局的属性，导致第一行代码和第二行代码分别触发了Reflow。比较好的方式是使用一个局部变量把当前位置相关的值记录下来，而不是使用<code>offset</code>这样的属性：</p>\n<pre><code>currentLeft++;\nmyElement.style.left = currentLeft + &quot;px&quot;;\n</code></pre><h3 id=\"-dom-\">在动画的过程中把DOM从文档流中移除</h3>\n<p>举个例子，像jQuery的<code>slideDown</code>和<code>slideUp</code>这样的效果在日常的页面中出现的次数非常多，例如各种手风琴菜单、下拉菜单等。像手风琴菜单那样的效果，当菜单展开的时候，会把它之后的菜单往后挤。由于位置不断发生变化，会频繁地触发Reflow。后面的内容越多，对性能的影响就越大。</p>\n<p>为了减少动画造成的Reflow次数，我们可以这么修改一下这个效果：</p>\n<ol>\n<li>把展开的菜单项的<code>position</code>设置成<code>absolute</code>。（注：这样可能会导致页面在展开的过程中样式发生错误。）</li>\n</ol>\n","path":"2013-12-08-hp-other-about-repaints-and-reflows.json","year":"2013","month":"12","day":"08","tags":["JavaScript"]},{"link":"/posts/2013/12/07/minimizing-repaints-and-reflows.html","title":"High Performance JavaScript 读书笔记之 减少Repaint和Reflow的次数","summary":"<p>之前已经讨论过Repaint和Reflow会对性能造成一定的影响，所以我们在进行DOM操作的时候，需要注意的是要把这些操作“集中”到一个地方，然后一次性地应用到页面上面。例如以下的代码：</p>\n<pre><code>var el = document.getElementById(&#39;mydiv&#39;);\nel.style.borderLeft = &#39;1px&#39;;\nel.style.borderRight = &#39;2px&#39;;\nel.style.padding = &#39;5px&#39;;\n</code></pre><p>这里用了3行代码设置DOM的样式。虽然浏览器会对这些操作进行优化，但是最坏的情况下会进行3次Reflow。为了减少Reflow可能发生的次数，这样修改可能比较合适：</p>\n<pre><code>var el = document.getElementById(&#39;mydiv&#39;);\nel.style.cssText = &#39;border-left: 1px; border-right: 2px; padding: 5px;&#39;;\n</code></pre><p>虽然这样可以减少Reflow可能发生的次数，但是造成代码的可读性变差。最佳实践是使用<code>class</code>：</p>\n<pre><code>var el = document.getElementById(&#39;mydiv&#39;);\nel.className = &#39;active&#39;;\n</code></pre><p>当对样式的修改不依赖于运行时的时候，修改<code>class</code>这种方式最优。</p>\n<p>进行影响几何属性的DOM操作的时候，可以依照下面的步骤去进行，最小化Reflow或者Repaint的次数：</p>\n<ol>\n<li>把DOM从展现树中暂时“抽出去”。</li>\n</ol>\n","path":"2013-12-07-minimizing-repaints-and-reflows.json","year":"2013","month":"12","day":"07","tags":["JavaScript"]},{"link":"/posts/2013/12/05/as3-urlloader.html","title":"在Flash中发送请求之二：URLLoader","summary":"<p>使用<code>URLRequest</code>生成请求的内容之后，我们需要发送这个请求，这时候就需要用到<code>URLLoader</code>这个类。这个类相当于Ajax中的<code>XMLHttpRequest</code>，使用其<code>load</code>方法就可以把请求发送出去。这个类除了可以处理文本之外，还能处理二进制的数据哦，例如文件等。</p>\n<p>这个类有以下几个实例属性：</p>\n<ol>\n<li><code>bytesLoaded</code>，表示加载完毕的字节数。</li>\n<li><code>bytesTotal</code>，表示这个请求完全加载后的字节数。</li>\n<li><code>data</code>，表示接收到的数据。数据类型又<code>dataFormat</code>这个属性决定。</li>\n<li><code>dataFormat</code>，表示接收数据的格式，默认是文本<code>URLLoaderDataFormat.TEXT</code>。可选的值是二进制<code>URLLoaderDataFormat.BINARY</code>和URL编码变量<code>URLLoaderDataFormat.VARIABLES</code>。</li>\n</ol>\n<p>这个类的实例方法很简单，只有两个：</p>\n<ol>\n<li><code>load(request:URLRequest)</code>，发送请求，参数为请求的内容，类似于<code>xhr.send</code>。</li>\n<li><code>close()</code>，取消这次请求，类似于<code>xhr.abort</code>。</li>\n</ol>\n<p><code>load</code>方法是异步的，所以处理这次请求的过程跟Ajax也是十分类似，需要通过绑定事件去监听加载中的每一个过程。调用<code>load</code>之后，会触发以下几个事件：</p>\n<ol>\n<li><code>complete</code>，请求完成，数据可以通过事件对象的<code>target</code>属性中的<code>data</code>属性获取。</li>\n<li><code>httpStatus</code>，如果请求是通过HTTP协议发送的，当接收到HTTP请求的状态码的时候会触发这个事件。状态码通过事件对象的<code>status</code>属性获取。</li>\n<li><code>ioError</code>，请求无法完成的时候触发，具体失败的内容可以通过事件对象的<code>text</code>属性获取。</li>\n<li><code>progress</code>，请求进行中会触发若干遍，通过监听这个事件我们可以做出进度条的效果。根据事件对象的<code>bytesLoaded</code>属性和<code>bytesTotal</code>属性可以知道当前加载完成的百分比。</li>\n<li><code>securityError</code>，加载操作尝试从调用方安全沙箱外部的服务器检索数据时触发。</li>\n<li><code>open</code>，加载开始的时候触发。</li>\n</ol>\n","path":"2013-12-05-as3-urlloader.json","year":"2013","month":"12","day":"05","tags":["Flash"]},{"link":"/posts/2013/12/04/as3-urlrequest.html","title":"在Flash中发送请求之一：URLRequest","summary":"<p>无论在哪个前端开发的环境中，向后台发送请求获取数据、修改数据都是必须的。在AS3中，可以使用<code>URLRequest</code>配合<code>URLLoader</code>来发送请求。今天先简单看看<code>URLRequest</code>怎么用。</p>\n<p><code>URLRequest</code>像一个包含这次请求的配置、内容等信息的一个类。类似浏览器中的Ajax，这个类的对象包含一些跟HTTP请求有关的参数，例如头、发送的数据、HTTP方法以及请求的URL等。具体有以下几个属性：</p>\n<ol>\n<li><code>contentType</code>，<code>data</code>的MIME类型，默认跟表单一样<code>application/x-www-form-urlencoded</code>。</li>\n<li><code>data</code>，跟随请求一起发送到服务端的数据。</li>\n<li><code>followRedirects</code>，是否遵循重定向。</li>\n<li><code>method</code>，HTTP方法。</li>\n<li><code>requestHeaders</code>，请求头，是一个包含<code>URLRequestHeader</code>实例的数组。</li>\n<li><code>url</code>，请求的URL。</li>\n<li><code>userAgent</code>，标识用户代理的字符串，类似于浏览器的<code>window.navigator.usrAgent</code>。</li>\n</ol>\n<p>大部分参数都是字符串。<code>data</code>是一个对象，默认会按照表单形式进行编码：</p>\n<pre><code>key1=value1&amp;key2=value2\n</code></pre><p>其中<code>URLRequestHeader</code>的实例其实就是一个键值对：</p>\n<pre><code>var urlRequestHeader:URLRequestHeader = \n  new URLRequestHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);\n</code></pre><p>然后这么加到<code>URLRequest</code>中：</p>\n","path":"2013-12-04-as3-urlrequest.json","year":"2013","month":"12","day":"04","tags":["Flash"]},{"link":"/posts/2013/12/03/flashvars.html","title":"使用flashvars传递参数","summary":"<p>我们可以使用可选的<code>name</code>为<code>flashvars</code>的参数传递参数到Flash影片中。这些参数在Flash影片播放第一帧之前传递到Flash影片之中。</p>\n<p>这个参数是一个字符串，只有一个长度限制，就是最多只能传64KB的数据。</p>\n<p>格式跟URL的查询串十分类似，也是<code>key=value&amp;key=value</code>这样的格式，也可以使用<code>encodeURIComponent</code>和<code>decodeURIComponent</code>对里面的值进行编码和解码。</p>\n<p>在<code>object</code>标签里面是这么使用：</p>\n<pre><code>&lt;object&gt;\n  &lt;param name=FlashVars value=&quot;myVariable=Hello%20World&amp;mySecondVariable=Goodbye&quot; /&gt;\n&lt;/object&gt;\n</code></pre><p>在<code>embed</code>标签里面是这么使用：</p>\n<pre><code>&lt;embed FlashVars=&quot;myVariable=Hello%20World&amp;mySecondVariable=Goodbye&quot; /&gt;\n</code></pre><p>然后我们就可以在AS里面获取这些参数了。在AS3中，可以通过<code>this.loaderInfo.parameters</code>获取这些参数：</p>\n<pre><code>var params:Object = this.loaderInfo.parameters;\ntrace(params.myVariable); // Hello World\ntrace(params.mySecondVariable); // Goodbye\n</code></pre>","path":"2013-12-03-flashvars.json","year":"2013","month":"12","day":"03","tags":["Flash"]},{"link":"/posts/2013/12/02/flash-params.html","title":"给Flash影片传参数","summary":"<p>在页面中插入Flash影片有两个标签都可以用，一个是<code>object</code>，一个是<code>embed</code>。无论使用那个标签，我们都需要传入一些参数给Flash影片，今天来看看有什么参数可以设置。</p>\n<p>首先是必要的参数，<code>width</code>和<code>height</code>这两个属性无论使用哪个标签都必须设置的：</p>\n<pre><code>&lt;object width=&quot;500&quot; height=&quot;400&quot;&gt;&lt;/object&gt;\n</code></pre><p>如果使用的是<code>object</code>，则还需要以下几个参数：</p>\n<ol>\n<li><code>classid</code>，为浏览器指定ActiveX控件，一般都是<code>D27CDB6E-AE6D-11cf-96B8-444553540000</code>。</li>\n<li><code>codebase</code>，如果浏览器没有安装指定的控件，则可以通过这个特性的值去下载指定的控件，例如<code>codebase=&quot;downloader.cab#version=1,0,0,0&quot;</code>。</li>\n<li><code>movie</code>，这个是<code>object</code>内部的一个<code>param</code>标签的<code>name</code>，指定Flash影片的地址：<code>&lt;param name=&quot;movie&quot; value=&quot;path/to/swf&quot; /&gt;</code>。</li>\n</ol>\n<p>如果使用的是<code>embed</code>，内部不会有<code>param</code>标签，所有参数都是以特性写在<code>embed</code>标签里面。使用<code>embed</code>标签的时候还需要以下几个参数：</p>\n<ol>\n<li><code>src</code>，同以上的<code>movie</code>。</li>\n<li><code>pluginspage</code>，同以上的<code>codebase</code>。</li>\n</ol>\n<p>以下是可选的参数，使用<code>object</code>的时候使用<code>param</code>标签在内部声明值，使用<code>embed</code>则直接以特性写在<code>embed</code>里面：</p>\n<ol>\n<li><code>play</code>，表示是否在影片加载完成之后自动播放，默认是<code>true</code>。</li>\n<li><code>loop</code>，表示影片是否循环播放，默认是<code>true</code>。</li>\n<li><code>menu</code>，表示是否在上下文菜单显示播放控件。</li>\n</ol>\n","path":"2013-12-02-flash-params.json","year":"2013","month":"12","day":"02","tags":["Flash","html"]},{"link":"/posts/2013/12/01/hp-repaints-and-reflows.html","title":"High Performance JavaScript 读书笔记之 Repaints和Reflow","summary":"<p>当浏览器下载完所有HTML标签、脚本、样式、图片，它会创建两种数据结构：DOM树和展现树。DOM树中不可见的节点在展现树上是没有对应节点的。展现数上的节点通常被称为<code>frames</code>或者<code>boxes</code>，浏览器会把这些节点当成一个个”盒子“来处理（包括<code>padding</code>、<code>margin</code>、<code>border</code>和<code>position</code>）。当展现树构造完成之后，浏览器就可以把整个页面”画“出来了。</p>\n<p>当页面的元素发生几何变化时（例如高度、宽度变化，或者<code>padding</code>、<code>margin</code>、<code>border</code>变化等），浏览器需要重新计算页面上其他元素的几何位置。这个过程就是<code>reflow</code>。当<code>reflow</code>发生的时候，浏览器需要重绘所有受影响的元素，这个过程是一个<code>repaint</code>。</p>\n<p>不是更改所有HTML元素都会出发<code>reflow</code>，例如改变一个元素的背景色，是不会改变这个元素的几何属性的。这种情况下，只会发生<code>repaint</code>。</p>\n<p>不管是<code>reflow</code>还是<code>repaint</code>，都会有比较高昂的性能损耗。所以，减少<code>reflow</code>和<code>repaint</code>的次数对性能是十分重要的。</p>\n<p>什么时候会发生<code>reflow</code>：</p>\n<ol>\n<li>增加或者移除可视的DOM元素。</li>\n<li>元素的位置发生改变。</li>\n<li>元素的大小发生变化，包括<code>padding</code>、<code>margin</code>等。</li>\n<li>元素内容发生变化，当元素是自适应内容的情况下（<code>height</code>为<code>auto</code>等）。</li>\n<li>页面初始化的时候。</li>\n<li>浏览器<code>resize</code>的时候。</li>\n</ol>\n<p>通常浏览器会有一个队列缓冲对展现树的改变，在适当的时候一次性<code>reflow</code>或者<code>repaint</code>。但是，使用到DOM上的某些属性会导致队列被刷新，立刻执行<code>reflow</code>或者<code>repaint</code>：</p>\n<ol>\n<li>使用<code>offsetTop</code>等<code>offsetXxx</code>属性。</li>\n<li>使用<code>scrollTop</code>等<code>scrollXxx</code>属性。</li>\n<li>使用<code>clientTop</code>等<code>clientXxx</code>属性。</li>\n</ol>\n","path":"2013-12-01-hp-repaints-and-reflows.json","year":"2013","month":"12","day":"01","tags":["JavaScript"]},{"link":"/posts/2013/11/30/hp-walking-the-dom.html","title":"High Performance JavaScript 读书笔记之 遍历DOM","summary":"<p>DOM提供了多种方式供我们去遍历整个文档。虽然使用哪种方式都可以达到目的，但是有些时候还是需要选出一个效率最高的方式去达到某些性能基线。</p>\n<p>我们可以使用<code>childNodes</code>去访问一个DOM的所以子元素，这样就可以递归地遍历整个文档中的DOM，下面是一个使用<code>childNodes</code>的例子：</p>\n<pre><code>function testChildNodes() {\n  var el = document.getElementById(&#39;mydiv&#39;),\n      ch = el.childNodes,\n      len = ch.length,\n      name = &#39;&#39;;\n  for (var count = 0; count &lt; len; count++) {\n    name = ch[count].nodeName;\n  }\n  return name;\n};\n</code></pre><p>我们也可以使用<code>nextSibling</code>去访问一个DOM的邻接节点，这样也可以遍历整个文档中的DOM：</p>\n<pre><code>function testNextSibling() {\n  var el = document.getElementById(&#39;mydiv&#39;),\n      ch = el.firstChild,\n      name = &#39;&#39;;\n  do {\n</code></pre>","path":"2013-11-30-hp-walking-the-dom.json","year":"2013","month":"11","day":"30","tags":["JavaScript"]},{"link":"/posts/2013/11/26/javascript-swfobject.html","title":"使用JavaScript在页面中嵌入Flash","summary":"<p>今天讨论的是使用<code>swfobject</code>在页面中嵌入一个Flash影片。对于不熟悉Flash的前端来说，<code>swfobject</code>提供了完整的JavaScript API来插入Flash影片，封装了很多内部的实现细节。使用<code>swfobject</code>还能做一些例如版本检测、提示下载Flash Player等操作。</p>\n<p>这个库的使用方法很简单，首先肯定是在页面中引入这个库的脚本文件：</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;swfobject.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>HTML片段：</p>\n<pre><code>&lt;div id=&quot;myContent&quot;&gt;\n  &lt;p&gt;Alternative content&lt;/p&gt;\n&lt;/div&gt;\n</code></pre><p>假设我们需要在<code>#myContent</code>中插入一个Flash影片，只需要调用<code>swfobject.embedSWF</code>就可以了，这个方法接受如下几个参数：</p>\n<ol>\n<li><code>swfUrl</code>，影片的地址。</li>\n<li><code>id</code>，影片容器的ID，如上例的<code>myContent</code>。</li>\n<li><code>width</code>，影片的宽度。</li>\n<li><code>height</code>，影片的高度。</li>\n<li><code>version</code>，目标Flash Player的版本。</li>\n<li><code>expressInstallSwfurl</code>，可选，利用这个flash跳转到官方下载最新版本的flash插件。</li>\n<li><code>flashvars</code>，可选，一个JavaScript对象，传递给Flash影片的变量。</li>\n<li><code>params</code>，可选，<code>object</code>内部的<code>param</code>标签。</li>\n</ol>\n","path":"2013-11-26-javascript-swfobject.json","year":"2013","month":"11","day":"26","tags":["JavaScript","Flash"]},{"link":"/posts/2013/11/25/onload-vs-onreadystatechange.html","title":"Script标签上的onload和onreadystatechange","summary":"<p>之前做一个效果，涉及到动态加载脚本的问题。这个效果需要做成本地文件直接打开可以看到效果，所以下面的代码在Chrome是会报错的：</p>\n<pre><code>$.getScript(&quot;./js/dynamic.js&quot;, function () {...});\n</code></pre><p>由于本地文件使用的是<code>file</code>协议，而<code>$.getScript</code>在这个情况下是使用Ajax去请求脚本的内容，Chrome在使用<code>file</code>协议的页面进行Ajax请求时会抛出跨域访问的异常。所以只能用动态插入<code>script</code>标签的方式去实现：</p>\n<pre><code>var done = false;\nvar head = document.getElementsByTagName(&quot;head&quot;)[0];\nvar s = document.createElement(&quot;script&quot;);\ns.type = &quot;text/javascript&quot;;\ns.onload = s.onreadystatechange = function (evt) {\n  if (!done &amp;&amp; (!this.readyState || \n    this.readyState == &quot;loaded&quot; ||\n    this.readyState == &quot;complete&quot;)) {\n    // do something with the script\n    s.onload = s.onreadystatechange = null;\n    head.removeChild(s);\n  }\n}\ns.src = &quot;path/to/script.js&quot;;\nhead.appendChild(s);\n</code></pre>","path":"2013-11-25-onload-vs-onreadystatechange.json","year":"2013","month":"11","day":"25","tags":["JavaScript"]},{"link":"/posts/2013/11/24/hp-html-collections.html","title":"High Performance JavaScript 读书笔记之 访问和修改DOM（二）","summary":"<p>今天讨论一下<code>HTMLCollection</code>。<code>HTMLCollection</code>是一个类似数组的东西，里面包含了一组DOM对象。下面的API返回的结果都是一个<code>HTMLCollection</code>：</p>\n<ol>\n<li><code>document.getElementsByName</code>。</li>\n<li><code>document.getElementsByClassName</code>。</li>\n<li><code>document.getElementsByTagName</code>。</li>\n</ol>\n<p>而下面的这些<code>document</code>的属性也会返回一个<code>HTMLCollection</code>：</p>\n<ol>\n<li><code>document.images</code>，返回文档中所有<code>img</code>。</li>\n<li><code>document.links</code>，返回文档中所有带<code>href</code>特性的<code>a</code>。</li>\n<li><code>document.forms</code>，返回文档中所有<code>form</code>。</li>\n<li><code>document.forms[0].elements</code>，返回第一个表单中的所有表单域。</li>\n</ol>\n<p><code>HTMLCollection</code>不是数组，所以它没有<code>push</code>或者<code>slice</code>等方法。但是它有<code>length</code>属性，也可以通过下标访问，所以它是一个“类数组”。值得注意的是，<code>HTMLCollection</code>是“活”的，即在访问这个集合的时候，该集合的状态是当前文档的状态。例如这样的代码可能会进入一个死循环：</p>\n<pre><code>var alldivs = document.getElementsByTagName(&quot;div&quot;);\nfor (var i = 0; i &lt; alldivs.length; i++) {\n  document.body.appendChild(\n    document.createElement(&quot;div&quot;));\n}\n</code></pre><p>由于在循环中不断加入<code>div</code>，导致<code>alldiv.length</code>不断被增大，退出条件永远都不会成立。</p>\n","path":"2013-11-24-hp-html-collections.json","year":"2013","month":"11","day":"24","tags":["JavaScript"]},{"link":"/posts/2013/11/23/hp-innerhtml-versus-dom-methods.html","title":"High Performance JavaScript 读书笔记之 访问和修改DOM（一）","summary":"<p>之前已经讨论过为什么访问和修改DOM会带来额外的性能消耗，这种消耗会在循环的内部被加剧地放大。参考下面的代码：</p>\n<pre><code>function innerHTMLLoop() {\n  for (var count = 0; count &lt; 15000; count++) {\n    document.getElementById(&#39;here&#39;).innerHTML += &#39;a&#39;;\n  }\n}\n</code></pre><p>以上就是一个在循环中访问以及修改DOM的例子，它在循环的内部进行了两个DOM操作：</p>\n<ol>\n<li>访问DOM的<code>innerHTML</code>属性。</li>\n<li>修改DOM的<code>innerHTML</code>属性。</li>\n</ol>\n<p>根据之前讨论过的结果，我们要尽量减少DOM操作的次数，可以这么修改：</p>\n<pre><code>function innerHTMLLoop2() {\n  var content = &#39;&#39;;\n  for (var count = 0; count &lt; 15000; count++) {\n    content += &#39;a&#39;;\n  }\n  document.getElementById(&#39;here&#39;).innerHTML += content;\n}\n</code></pre>","path":"2013-11-23-hp-innerhtml-versus-dom-methods.json","year":"2013","month":"11","day":"23","tags":["JavaScript"]},{"link":"/posts/2013/11/22/jquery-csshooks.html","title":"jQuery扫盲之cssHooks","summary":"<p>在DOM的<code>style</code>属性中，不同浏览器对于一些CSS属性名称的处理是不一样的，例如<code>float</code>，在IE里面是<code>styleFloat</code>，而在Chrome则是<code>cssFloat</code>等。jQuery为我们处理了这些不一致，我们可以直接使用<code>css</code>去获取或者设置<code>float</code>的属性值。jQuery还提供了<code>cssHooks</code>这个对外的属性让我们可以自定义某些CSS属性的<code>getter</code>和<code>setter</code>：</p>\n<blockquote>\n<p>Hook directly into jQuery to override how particular CSS properties are retrieved or set, normalize CSS property naming, or create custom properties.</p>\n</blockquote>\n<p>对于<code>float</code>等常用的CSS属性，jQuery已经为我们处理了这些浏览器的不一致，但是对于一些属性，例如<code>border-radius</code>（要加上浏览器特定的前缀）等，jQuery是没有处理的。对于这种场景，其中一种比较笨的方法是我们把所有浏览器的实现都写一遍：</p>\n<pre><code>$(elem).css({\n  &quot;border-radius&quot;: &quot;2px&quot;,\n  &quot;-ms-border-radius&quot;: &quot;2px&quot;,\n  &quot;-webkit-border-radius&quot;: &quot;2px&quot;,\n  &quot;-moz-border-radius&quot;: &quot;2px&quot;,\n});\n</code></pre><p>这时候更聪明的方式是，我们可以使用<code>cssHooks</code>去处理这些前缀：</p>\n<pre><code>(function( $ ) {\n\n  if ( !$.cssHooks ) {\n    throw( new Error( &quot;jQuery 1.4.3+ is needed for this plugin to work&quot; ) );\n  }\n\n  function styleSupport( prop ) {\n</code></pre>","path":"2013-11-22-jquery-csshooks.json","year":"2013","month":"11","day":"22","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/11/20/get-computed-style.html","title":"window.getComputedStyle","summary":"<p>使用DOM的<code>style</code>属性只能获取<code>style</code>特性指定的CSS属性，而外部样式表（<code>link</code>）或者内联样式表（<code>style</code>）中对这个元素生效的CSS属性是不能通过<code>style</code>获取的。这时，调用<code>getComputedStyle</code>可以返回一个DOM元素当前的CSS属性，即经过层叠之后的CSS属性（包括外部样式表、内联样式表还有<code>style</code>）。</p>\n<p>这个方法可以接受两个参数：</p>\n<ol>\n<li><code>element</code>，要获取CSS属性的DOM元素。</li>\n<li><code>pseudoElt</code>，可选，一个伪类，可以获取到这个DOM元素的某个伪类的CSS属性，如<code>:hover</code>、<code>:active</code>，甚至是<code>:before</code>。IE和Opera不支持这个参数。</li>\n</ol>\n<p>返回的对象可以像<code>style</code>属性一样的使用，不过只能读，写是无效的：</p>\n<pre><code>var result = getComputedStyle(elem);\nalert(result.height);\n</code></pre><p>也可以调用元素上的<code>getPropertyValue</code>去获取对应的CSS属性：</p>\n<pre><code>alert(result.getPropertyValue(&quot;height&quot;);\n</code></pre><p>这个方法IE9才支持。我们可以利用这个方法在脚本中准确判断现在是哪个响应式的样式表在生效。以前我们判断现在是哪个生效，可能会写这么一些代码：</p>\n<pre><code>if ($(window).width() &gt; 1024) {\n  // min-width: 1024px\n} else if ($(window).width() &gt; 768) {\n  // max-width: 1024px and  min-width: 768px\n</code></pre>","path":"2013-11-20-get-computed-style.json","year":"2013","month":"11","day":"20","tags":["JavaScript","css"]},{"link":"/posts/2013/11/19/elem-in-viewport.html","title":"判断一个元素是否在视口之中","summary":"<p>之前讨论过如何获取视口大小，用jQuery就最简单了：</p>\n<pre><code>$(window).width();\n$(window).height();\n</code></pre><p>今天来讨论一下如何判断一个元素是否在视口之中。首先来介绍一下<code>elem.getBoundingClientRect</code>方法。这个方法可以获取到一个元素在文档中的位置，例如：</p>\n<pre><code>document.getElementById(&quot;id&quot;).getBoundingClientRect();\n</code></pre><p>返回的对象有六个属性，包括<code>width</code>、<code>height</code>、<code>top</code>、<code>left</code>、<code>bottom</code>、<code>right</code>。通过这个对象我们就可以得到一个元素在文档中的位置。只需要减去<code>scrollY</code>和<code>scrollX</code>就可以得到相对于视口的位置：</p>\n<pre><code>top = rect.top - window.scrollY;\nleft = rect.left - window.scrollX;\n</code></pre><p>根据这些信息，以及视口的大小就可以判断元素是否在视口中了。以下是一个使用jQuery的判断方法，记在这里以便不时之需，嘿嘿：</p>\n<pre><code>$.fn.isOnScreen = function(){     \n  var win = $(window);   \n  var viewport = {\n    top : win.scrollTop(),\n    left : win.scrollLeft()\n  };\n</code></pre>","path":"2013-11-19-elem-in-viewport.json","year":"2013","month":"11","day":"19","tags":["JavaScript"]},{"link":"/posts/2013/11/18/jquery-css.html","title":"jQuery扫盲之css","summary":"<p>这个也是我们日常使用频率比较高的jQuery方法了。这个方法跟<code>attr</code>类似，也是<code>geter</code>和<code>setter</code>一体的方法。</p>\n<h3 id=\"getter\">getter</h3>\n<blockquote>\n<p>Get the value of style properties for the first element in the set of matched elements.</p>\n</blockquote>\n<p>如果只传入一个参数（不是对象），则视为是<code>getter</code>调用。只会获取jQuery对象中第一个元素的CSS属性值。有两种传参的形式：</p>\n<ol>\n<li><code>propertyName</code>，表示要获取CSS属性名称的字符串。</li>\n<li><code>propertyNames</code>，表示获取多个CSS属性名称的一个数组。</li>\n</ol>\n<p><code>css</code>方法是一个十分方便的方法，它封装了不同浏览器对于获取元素当前样式所提供的API，例如IE的<code>elem.currentStyle</code>和标准的<code>getComputedStyle</code>等。它还统一了不同浏览器对于某些CSS属性名，例如<code>float</code>，在IE里面是<code>styleFloat</code>，而标准则是<code>cssFloat</code>，现在我们可以这么获取<code>float</code>的值：</p>\n<pre><code>$(elem).css(&quot;float&quot;);\n</code></pre><p>这个方法还提供了驼峰大小写和<code>-</code>连接两种形式去写我们的CSS属性，例如以下两个语句返回的结果是一样的：</p>\n<pre><code>$(elem).css(&quot;backgroundColor&quot;);\n$(elem).css(&quot;background-color&quot;);\n</code></pre><p>值得注意的是，jQuery不支持获取复合属性，例如<code>border</code>、<code>background</code>等，需要获取这些属性要提供他们所有属性的完整的名称：</p>\n","path":"2013-11-18-jquery-css.json","year":"2013","month":"11","day":"18","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/11/17/hp-dom-in-browser.html","title":"High Performance JavaScript 读书笔记之 浏览器中的DOM","summary":"<p>操作DOM是十分耗时的，至少在老版本的IE上是如此。为什么DOM操作就那么耗时呢？</p>\n<p>DOM是一个语言无关的接口，它定义了我们的程序如何跟HTML或者XML文档进行交互。在浏览器中，我们通常都是跟HTML DOM打交道，也不排除作为数据传输格式的时候操作XML DOM。</p>\n<p>尽管DOM是语言无关的，我们在浏览器中使用的是它的JavaScript的实现。由于前端的工作大部分都是跟界面有关，所以DOM操作在前端的工作中占的比例是相当大的。</p>\n<p>浏览器通常会把DOM接口的实现跟JavaScript引擎分开。举个例子，在某个版本的IE中，JavaScript引擎的实现是放在<code>jscript.dll</code>的动态库中，而DOM的实现则在<code>mshtml.dll</code>中。之所以把这两个实现分开，是因为微软可以方便地为其他脚本（例如<code>VBScript</code>）调用同一套DOM的实现。Safari、Chrome等都是把渲染引擎跟JavaScript引擎分开的。</p>\n<p>那为什么DOM操作会慢呢？简单地说，就是这种两种实现的分开造成的。当某一方需要调用另一方的时候会产生额外的消耗。举个例子，想象一下DOM的实现和JavaScript的实现是两个小岛，中间有一条桥连接，所以他们能通过这条桥进行交互。但是过桥必须交过路费。每次它们之间相互调用的时候都要产生“过路费”的消耗，调用得越多消耗的越多。</p>\n<p>所以，尽可能地减少DOM操作，包括访问、修改DOM等操作，能有效地减少这种“过路费”的消耗，也更容易地在代码的逻辑上分开展现和逻辑两个部分，提高代码的可读性与重用性。</p>\n","path":"2013-11-17-hp-dom-in-browser.json","year":"2013","month":"11","day":"17","tags":["JavaScript"]},{"link":"/posts/2013/11/16/bottom-up-selector-engine.html","title":"Secrets of the JavaScript Ninja 读书笔记之 从下到上的CSS选择器引擎","summary":"<p>如果不想做之前的唯一性的过滤，那么从下到上的CSS选择器实现应该是一个比较好的替换方式。这种实现跟之前的实现最大的不同就是它是从最右边开始解析CSS选择器。举个例子，假如有这么一个CSS选择器<code>div span</code>，从下到上的实现会先查找出文档中所有的<code>span</code>，然后在这些<code>span</code>中过滤出祖先节点有<code>div</code>的一个集合，就是最后的结果。</p>\n<p>这种先查出一个大集合再过滤的方式，优点就是代码实现起来比较简单，最明显的就是不用之前的唯一性判断。但是，代码简单带来的缺点就是扩展性比较差，而且当选择器比较复杂的时候局限性比较大。</p>\n<p>这个实现首先根据选择器的最右的部分查出所有元素。然后的操作就是从右到左，根据每一个选择器在这个集合中过滤掉合适的部分即可：</p>\n<pre><code>function find(selector, root){\n  root = root || document;\n  var parts = selector.split(&quot; &quot;),\n  query = parts[parts.length - 1],\n  rest = parts.slice(0,-1).join(&quot;&quot;),\n  elems = root.getElementsByTagName(query),\n  results = [];\n  for (var i = 0; i &lt; elems.length; i++) {\n    if (rest) {\n      var parent = elems[i].parentNode;\n      while (parent &amp;&amp; parent.nodeName != rest) {\n        parent = parent.parentNode;\n      }\n      if (parent) {\n        results.push(elems[i]);\n      }\n</code></pre>","path":"2013-11-16-bottom-up-selector-engine.json","year":"2013","month":"11","day":"16","tags":["JavaScript"]},{"link":"/posts/2013/11/15/jquery-when.html","title":"jQuery扫盲之jQuery.when","summary":"<p>现实工作中我们经常会遇见一个场景，需要多次调用Ajax，在所有请求都完成的时候再执行一个回调函数。我们可以自己做一个计数器，每次Ajax执行完计数器加一，这样就可以知道是不是所有Ajax都调用完成了。其实jQuery已经提供了这么一个功能，就是<code>jQuery.when</code>：</p>\n<blockquote>\n<p>Provides a way to execute callback functions based on one or more objects, usually Deferred objects that represent asynchronous events.</p>\n</blockquote>\n<p>这个方法接受一个或者多个<code>Deffered</code>对象，例如<code>jQuery.ajax</code>返回的东东。如果只传入一个<code>Deffered</code>对象，这个方法会简单地返回这个<code>Deffered</code>对象，例如：</p>\n<pre><code>$.when($.ajax());\n$.ajax(); // equals\n</code></pre><p>如果传入一个不是<code>Deffered</code>对象的参数，这相当于<code>Deffered</code>对象已经resolve了，所有注册的回调都会立刻执行，例如：</p>\n<pre><code>$.when( { testing: 123 } ).done(function( x ) {\n  alert( x.testing ); // Alerts &quot;123&quot;\n});\n</code></pre><p>这个方法最有用的用法还是传入多个<code>Deffered</code>对象的时候。这时，返回的对象要在所有参数都被<code>resolve</code>的时候才会被<code>resolve</code>，而当有一个参数被<code>reject</code>的时候就会被<code>reject</code>。当这个对象被<code>resolve</code>的时候，会回传各个单独<code>resolve</code>时返回的结果（就是每个回调函数中的参数），顺序就是参数传入的顺序，例如：</p>\n<pre><code>$.when( $.ajax( &quot;/page1.php&quot; ), $.ajax( &quot;/page2.php&quot; ) ).done(function( a1, a2 ) {\n  // a1 and a2 are arguments resolved for the page1 and page2 ajax requests, respectively.\n  // Each argument is an array with the following structure: [ data, statusText, jqXHR ]\n  var data = a1[ 0 ] + a2[ 0 ]; // a1[ 0 ] = &quot;Whip&quot;, a2[ 0 ] = &quot; It&quot;\n  if ( /Whip It/.test( data ) ) {\n</code></pre>","path":"2013-11-15-jquery-when.json","year":"2013","month":"11","day":"15","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/11/14/canvas-draw-image.html","title":"在canvas中使用图片","summary":"<p>在canvas中可以使用浏览器支持的所有图片格式，甚至是另一个canvas上面的图像。要在canvas上使用图片，可以分成两个步骤：</p>\n<ol>\n<li>获取图像的引用。</li>\n<li>使用<code>drawImage</code>在canvas上画出对应的图像。</li>\n</ol>\n<p>图像的引用可以通过以下几种方式获取：</p>\n<ol>\n<li><code>Image</code>对象，例如<code>var img = new Image()</code>或者<code>document.getElementById(&quot;img&quot;)</code>。</li>\n<li><code>Video</code>对象，canvas可以把这个视频对象当成图片使用。</li>\n<li>另外一个canvas。</li>\n</ol>\n<p>如果图像跟canvas在同一个文档，就可以使用各种DOM API直接获取图像的引用，例如<code>getElementById</code>、<code>getElementsByTagName</code>等。值得注意是，使用<code>Image</code>等构造函数动态创建的图像，需要等该图像完全加载完毕之后才能使用，不然画出来的图像就有可能不正确：</p>\n<pre><code>var img = new Image();   // Create new img element\nimg.addEventListener(&quot;load&quot;, function() {\n  // execute drawImage statements here\n}, false);\nimg.src = &#39;myImage.png&#39;; // Set source path\n</code></pre><p>获取到图像的引用之后就可以使用<code>drawImage</code>在canvas上画图了。该方法是在canvas的上下文中：</p>\n<pre><code>var canvas = document.getElementById(&quot;canvas&quot;);\n</code></pre>","path":"2013-11-14-canvas-draw-image.json","year":"2013","month":"11","day":"14","tags":["JavaScript","html5"]},{"link":"/posts/2013/11/13/jquery-no-conflict.html","title":"jQuery扫盲之jQuery.noConflict","summary":"<p>这个方法通常在<code>$</code>这个变量已经被占用的情况下调用，例如我们的页面已经引用了Prototype等类库（Prototype使用<code>$</code>作为<code>document.getElementById</code>的快捷方式）：</p>\n<blockquote>\n<p>Relinquish jQuery&#39;s control of the $ variable.</p>\n</blockquote>\n<p>这个方法接受一个参数<code>removeAll</code>，默认是<code>false</code>，表示只释放<code>$</code>这个全局变量。如果这个参数是<code>true</code>，则表示释放所有全局变量，包括<code>jQuery</code>：</p>\n<pre><code>$.noConflict();\nalert($); // undefined\njQuery.noConflict(true);\nalert(jQuery); // undefined\n</code></pre><p>这样就可以释放jQuery占用的所有全局变量了。那么要怎么用jQuery的方法呢？调用这个方法会返回一个函数，其实就是jQuery本身：</p>\n<pre><code>var myJQ = $.noConflict(true);\nalert(myJQ(&quot;body&quot;).length);\n</code></pre><p>还有一个方法获取jQuery的引用，就是在<code>jQuery.ready</code>的回调里面的参数：</p>\n<pre><code>$.noConflict();\njQuery( document ).ready(function( $ ) {\n  // Code that uses jQuery&#39;s $ can follow here.\n});\n</code></pre>","path":"2013-11-13-jquery-no-conflict.json","year":"2013","month":"11","day":"13","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/11/12/request-animation-frame.html","title":"window.requestAnimationFrame","summary":"<p>基于脚本的动画，我们通常会使用<code>setTimeout</code>或者<code>setInterval</code>去做：</p>\n<pre><code>setInterval(step, interval);\n</code></pre><p>但是有没有想过当中的<code>interval</code>要设置多少才合适呢？为了动画的流畅，我们可能会把这个时间设置成尽可能的小，例如<code>10</code>。这样，动画就会每10毫秒绘制一祯。但是，由于显示的时候还是有一个频率的（例如60HZ），过小的时间间隔会造成某些祯处于显示的间隔时间，这样这些祯就显示不出来。而且设置这么小的时间间隔也会加大浏览器对CPU的消耗。</p>\n<p>这时候，可以使用<code>window.requestAnimationFrame</code>来替代以前基于<code>setTimeout</code>的实现：</p>\n<blockquote>\n<p>The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint.</p>\n</blockquote>\n<p>这个方法告诉浏览器现在需要为一个动画重绘一祯，浏览器会自行计算调用的时间，调用传入的回调函数。回调函数的单位时间调用次数跟显示设备的刷新频率有关，不过不用担心，这些东西浏览器都会帮我们算好的。回调函数接受一个参数，就是这次调用的时间间隔。调用这个方法之后跟<code>setTimeout</code>一样，会返回一个<code>id</code>，调用<code>window.cancelAnimationFrame</code>也可以终止下一个回调函数的执行，跟<code>clearTimeout</code>是一致的。</p>\n<p>很可惜，<code>window.requestAnimationFrame</code>不是所有IE都支持，只有IE10才支持这个方法。但是由于这个方法的调用方式跟<code>setTimeout</code>是一致的，我们其实可以比较方便地在IE上做一个退化方案：</p>\n<pre><code>function reqAnimationFrame(callback) {\n  if (typeof requestAnimationFrame == &quot;function&quot;) {\n    return requestAnimationFrame(callback);\n  } else {\n    return setTimeout(callback, 60); // Default interval\n  }\n}\nfunction cancel(id) {\n</code></pre>","path":"2013-11-12-request-animation-frame.json","year":"2013","month":"11","day":"12","tags":["JavaScript"]},{"link":"/posts/2013/11/11/jquery-hold-ready.html","title":"jQuery扫盲之jQuery.holdReady","summary":"<p>今天来看一下一个我们平常都不会使用的方法<code>jQuery.holdReady</code>：</p>\n<blockquote>\n<p>Holds or releases the execution of jQuery&#39;s ready event.</p>\n</blockquote>\n<p>顾名思义，这个方法是用来延迟<code>ready</code>事件的触发时间。它接受一个参数<code>hold</code>，是个布尔值，表示这次调用是把<code>ready</code>事件hold住还是释放<code>ready</code>事件。</p>\n<p>那把<code>ready</code>事件hold住有什么场景？有时候我们需要为页面动态加载一段代码，而又想我们的其他代码在这动态加载的代码之后执行，一般会这么做：</p>\n<pre><code>$(function () {\n  $.getScript(&quot;path/to/script&quot;, function () {\n    ... // our code here\n  });\n});\n</code></pre><p>本来直接写到<code>$()</code>里面的代码要写到<code>$.getScript</code>的回调中去。这时候使用<code>jQuery.holdReady</code>就可以不改原来的代码，直接增加以下的代码：</p>\n<pre><code>$.holdReady(true);\n$.getScript(&quot;path/to/script&quot;, function () {\n  $.holdReady(false);\n});\n// old code\n$(function () {\n</code></pre>","path":"2013-11-11-jquery-hold-ready.json","year":"2013","month":"11","day":"11","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/11/10/javascript-set-recurseing-and-merging.html","title":"Secrets of the JavaScript Ninja 读书笔记之 递归与合并","summary":"<p>CSS选择器引擎需要递归访问元素及其子孙元素，然后合并多个匹配的结果，返回完整的结果。但是我们需要保证这个结果的结合里面没有重复的元素。由于调用类似<code>getElementsByTagName</code>这样的API，如果在子孙元素上调用的时候会返回相同的结果，例如：</p>\n<pre><code>&lt;div id=&quot;outer&quot;&gt;Outer\n  &lt;div id=&quot;middle&quot;&gt;Middle\n    &lt;div id=&quot;inner&quot;&gt;Inner&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>如果这么调用：</p>\n<pre><code>document.getElementById(&quot;outer&quot;).getElementsByTagName(&quot;div&quot;); // middle and inner\ndocument.getElementById(&quot;middle&quot;).getElementsByTagName(&quot;div&quot;); // inner\n</code></pre><p>可以看到两个都返回了<code>inner</code>，这样的重复明显是不必要的，所以我们需要一些额外的机制去判断这个元素是否已经存在在集合当中了：</p>\n<pre><code>this.unique = function(array) {\n  var ret = [];\n  run++;\n  for (var i = 0, length = array.length; i &lt; length; i++) {\n    var elem = array[i];\n    if (elem.uniqueID !== run) {\n      elem.uniqueID = run;\n</code></pre>","path":"2013-11-10-javascript-set-recurseing-and-merging.json","year":"2013","month":"11","day":"10","tags":["JavaScript"]},{"link":"/posts/2013/11/09/javascript-filter-the-set.html","title":"Secrets of the JavaScript Ninja 读书笔记之 过滤元素","summary":"<p>一个CSS选择器是由多个部分组成，例如<code>div.class[id]</code>，这里有三个部分：<code>div</code>、<code>.class</code>、<code>[id]</code>。首先，我们会根据<code>div</code>这个选择器，使用<code>getElementsByTagName</code>去获取文档中所有<code>div</code>。然后，我们需要对这个集合进行过滤，过滤出匹配<code>.class</code>和<code>[id]</code>这两个选择器的元素。</p>\n<p>过滤操作基本上在每一个CSS选择器引擎的实现都会有。通常会根据特性和元素的位置对集合进行过滤：</p>\n<ol>\n<li>特性过滤，需要在每一个元素上面调用<code>getAttribute</code>来获取对应的特性，跟特性选择器进行对比（特性的名称或者特性的值）。这里包括类选择器的过滤，因为<code>class</code>也可以作为一个特性。</li>\n<li>位置过滤，例如<code>nth-child</code>或者<code>first-child</code>等。这些过滤通常会优先使用DOM的<code>children</code>，这个属性是这个DOM元素的所有子孙元素。如果不支持这个属性，则需要遍历每一个DOM元素，访问其<code>childNodes</code>属性，这个属性只会包含这个元素的子元素。使用这两个属性就可以判断元素在集合中的位置是否匹配位置选择器。</li>\n</ol>\n<p>这种过滤功能还能提供给用户，例如<code>jQuery.fn.filter</code>或者<code>jQuery.grep</code>，使用这个方法可以使用自定义的过滤逻辑过滤这个集合，提供比CSS选择器更方便、更灵活的过滤功能。</p>\n","path":"2013-11-09-javascript-filter-the-set.json","year":"2013","month":"11","day":"09","tags":["JavaScript"]},{"link":"/posts/2013/11/08/jquery-constructor.html","title":" jQuery扫盲之jQuery","summary":"<p>jQuery的<code>jQuery</code>方法（通常是<code>$</code>）相信是最最最最常用的方法了，通常会传入一个选择器然后返回匹配这个选择器的元素的集合（jQuery对象）。其实这个函数还有一些其他的调用形式，一起看下去。</p>\n<h3 id=\"-\">选择元素</h3>\n<p>第一类是在文档中选择元素，有以下几种调用形式：</p>\n<p><strong>jQuery(selector, context)</strong></p>\n<p>其中<code>selector</code>就是CSS选择器，<code>context</code>是可选的上下文元素，默认是在整个文档中查找。传入<code>context</code>即等于<code>jQuery(context).find(selector)</code>。</p>\n<p><strong>jQuery(element)</strong></p>\n<p>其中<code>element</code>就是DOM元素，即把DOM元素“包裹”成jQuery对象。</p>\n<p><strong>jQuery(elementArray)</strong></p>\n<p>同上，只是传入的是DOM元素的一个数组。</p>\n<p><strong>jQuery(object)</strong></p>\n<p>其中<code>object</code>是一个普通的JavaScript对象，也是把它“包裹”成jQuery对象。这样我们就可以在普通的元素上使用jQuery的方法，例如一个简单的观察者模式：</p>\n","path":"2013-11-08-jquery-constructor.json","year":"2013","month":"11","day":"08","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/11/07/jquery-callbacks-object.html","title":"jQuery扫盲之callbacks对象","summary":"<p>callbacks对象是使用<code>jQuery.Callbacks</code>返回的对象，可以使用这个对象去管理回调函数列表。</p>\n<h3 id=\"-\">增加</h3>\n<p>调用<code>callbacks.add</code>就可以往列表里面增加一个或者多个回调函数：</p>\n<pre><code>callbacks.add(function () {...});\n</code></pre><h3 id=\"-\">删除</h3>\n<p>调用<code>callbacks.remove</code>可以在列表中删除一个或者多个回调函数：</p>\n<pre><code>callbacks.remove(foo);\n</code></pre><p>也可以使用<code>callbacks.empty</code>清空整个回调函数列表：</p>\n<pre><code>callbacks.empty();\n</code></pre><h3 id=\"-\">查询</h3>\n<p>调用<code>callbacks.has</code>可以判断一个回调函数是否在列表里面：</p>\n","path":"2013-11-07-jquery-callbacks-object.json","year":"2013","month":"11","day":"07","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/11/06/node-redis.html","title":"在Node上使用Redis","summary":"<p>Redis是一个开源的，基于<code>key-value</code>的内存数据库，可以作为一个能够存储字符串、哈希表、列表、集合等数据结构的数据服务器。</p>\n<p>首先是要安装一个Redis。在Unix/Linux下需要下载源码编译安装，今天就来简单看看Windows下如何安装吧。打开Redis的Windows版本的<a href=\"https://github.com/rgl/redis/downloads\">下载页面</a>，选择对应Windows版本的包下载即可。</p>\n<p>下载完解压到一个地方就可以使用了。首先启动Redis服务，双击<code>redis-server.exe</code>即可：</p>\n<pre><code>[9612] 07 Nov 18:01:28 # Warning: no config file specified, using the default config. In order to specify a config file use &#39;redis-server /path/to/redis.conf&#39;\n[9612] 07 Nov 18:01:28 * Server started, Redis version 2.4.5\n[9612] 07 Nov 18:01:28 * DB loaded from disk: 0 seconds\n[9612] 07 Nov 18:01:28 * The server is now ready to accept connections on port 6379\n[9612] 07 Nov 18:01:29 - DB 0: 8 keys (0 volatile) in 12 slots HT.\n[9612] 07 Nov 18:01:29 - 0 clients connected (0 slaves), 1182568 bytes in use\n</code></pre><p>启动后可以看到当前的端口、使用了多少个<code>key</code>还有多少个客户端链接进来等信息。注意哦，这些信息现在都是默认的配置，修改配置文件<code>redis.conf</code>可以修改这些信息，详细的配置文档<a href=\"http://redis.io/topics/config\">参考这里</a>。然后就可以启动<code>redis-cli.exe</code>来使用Redis了：</p>\n<pre><code>redis 127.0.0.1:6379&gt; set foo bar\nOK\nredis 127.0.0.1:6379&gt; get foo\n&quot;bar&quot;\n</code></pre><p>今天主要是关注Node下面怎么使用Redis。<a href=\"https://github.com/mranney/node_redis\">这里</a>有封装了一套API，让我们很方便地在Node里面使用Redis。API跟Redis的命令的名称基本上是一致的，例如<code>get</code>、<code>set</code>，还有最常用的哈希表操作<code>hgetAll</code>、<code>hmset</code>等。</p>\n","path":"2013-11-06-node-redis.json","year":"2013","month":"11","day":"06","tags":["node"]},{"link":"/posts/2013/11/05/css-content.html","title":"css content","summary":"<p><code>content</code>属性通常会跟<code>before</code>和<code>after</code>伪类一起使用。这个属性就是<code>before</code>或者<code>after</code>插入到文档中的“伪元素”的内容。</p>\n<p>这个属性接受以下几个值：</p>\n<ol>\n<li><code>none</code>，不生成伪元素。</li>\n<li><code>normal</code>，在<code>before</code>或者<code>after</code>的时候会被当成<code>none</code>。</li>\n<li><code>&lt;string&gt;</code>，一个字符串，表示伪元素的内容。</li>\n<li><code>&lt;url&gt;</code>，使用格式是<code>content: url(path/to/resource)</code>，表示伪元素是一个外部资源，例如图片等。</li>\n<li><code>&lt;counter&gt;</code>，使用格式是<code>content: counter(name, decimal)</code>，表示伪元素是一个计数器，第一个参数是计数器的名字，使用<code>conter-increment</code>声明一个CSS类为计数器；第二个参数是计数器的样式，默认是十进制数字。</li>\n<li><code>attr(x)</code>，表示伪元素的内容是当前元素的<code>x</code>特性的值。</li>\n<li><code>open-quote|close-quote</code>，表示伪元素的内容是引号。</li>\n<li><code>no-open-quote|no-close-quote</code>，增加或者减少引号的层次。</li>\n</ol>\n<p>下面是几个例子：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/r8sv8/embedded/html,css,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<p>注意几点：</p>\n<ol>\n<li>IE6、IE7不支持<code>content</code>，其他主流浏览器都支持。</li>\n<li><code>content</code>插入的内容其实只是“视觉”上的，所以不存在于文档中，无法复制粘贴。</li>\n</ol>\n","path":"2013-11-05-css-content.json","year":"2013","month":"11","day":"05","tags":["css"]},{"link":"/posts/2013/11/04/css-overflow.html","title":"css overflow","summary":"<p><code>overflow</code>声明当一个块元素的内容超过块元素的高度的时候应该如何显示。</p>\n<p>当这个属性的值不是默认值（<code>visible</code>）的时候，会创建一个BFC，这意味着这个容器会把里面的<code>float</code>的元素包裹起来（也就是修复浮动元素的高度塌陷问题）。注：即使是<code>hidden</code>，还是可以用脚本控制内部元素的<code>scrollTop</code>等滚动相关的属性。</p>\n<p>这个属性可选的值有4个：</p>\n<ol>\n<li><code>visible</code>，默认值，内容不被裁剪，直接渲染到盒子外面，但是不影响布局。</li>\n<li><code>hidden</code>，内容被裁剪，且没有滚动条，意味着这些内容在页面上没法直接看见。</li>\n<li><code>scroll</code>，内容被裁剪，浏览器会显示滚动条，通过滚动条可以查看完整的内容。注：在打印设备上<code>scroll</code>是没效的，同<code>visible</code>。</li>\n<li><code>auto</code>，由浏览器去决定怎么显示，一般是当内容超过容器的时候自动出现滚动条。</li>\n</ol>\n<p>常见的用法就是修复容器内部浮动元素导致的高度塌陷问题，一般只需要在容器上写上一条CSS：</p>\n<pre><code>overflow: hidden;\n</code></pre><p>这样容器就可以把内部浮动元素也包裹起来，高度也就是正常的了。</p>\n<p>最后有兴趣的童鞋可以看看<a href=\"http://edskes.net/ie/ie8overflowandexpandingboxbugs.htm\">这里</a>，是一些关于IE8的<code>overflow</code>的bug，竟然有一个bug是可以把页面弄不见的，太牛逼了！</p>\n","path":"2013-11-04-css-overflow.json","year":"2013","month":"11","day":"04","tags":["css"]},{"link":"/posts/2013/11/03/javascript-find-the-elements.html","title":"Secrets of the JavaScript Ninja 读书笔记之 寻找元素","summary":"<p>解析完选择器之后，需要根据每个部分去查找匹配的元素。要使用哪些技术要取决于要支持什么CSS选择器和浏览器对CSS选择器的支持能力。</p>\n<p>第一个是<code>getElementById</code>，只在文档的根元素上（<code>document</code>）提供的API，用于在当前文档中找出第一个<code>id</code>是指定参数的元素。Id选择器就是直接调用这个API去获取匹配的元素。但是IE和Opera还会找到第一个<code>name</code>是指定参数的元素。这个“有用”的副作用是我们所不需要的，所以还要编写一些代码去过滤这些额外的元素：</p>\n<pre><code>if (elem.getAttribute(&quot;id&quot;) == id) { ... }\n</code></pre><p>如果我们希望找到文档中所有包含指定<code>id</code>的元素，则需要遍历这个文档中所有元素，并比较它们的<code>id</code>特性，或者使用<code>document.all[&quot;id&quot;]</code>，这个会返回一个匹配该<code>id</code>的元素的一个数组（IE、Opera、Safari支持）。</p>\n<p>第二个是<code>getElementsByTagName</code>，可以寻找所有匹配该标签名的元素。这个API还有另外一个作用，就是查找元素的所有子孙元素：</p>\n<pre><code>elem.getElementsByTagName(&quot;*&quot;);\n</code></pre><p>当传入的CSS选择器中不包含标签选择器的时候（例如<code>.class</code>等），这种调用方式十分有用。</p>\n<p>有一个使用<code>*</code>的陷阱：IE会返回注释（IE把注释视为标签名为<code>!</code>的元素）！所以这里又需要一个过滤器把所有注释过滤掉。</p>\n<p>第三个是<code>getElementsByName</code>，根据<code>name</code>特性去查找元素，在使用<code>[name=name]</code>这种选择器的时候十分有用。</p>\n<p>最后一个是<code>getElementsByClassName</code>，这个是HTML5的API，根据<code>class</code>特性去寻找元素。这个方法的出现大大提高了类选择器的查找速度。</p>\n<p>以上就是用来寻找元素的最常用的API。匹配到元素之后，我们就可以根据某些选择器去过滤结果集（例如<code>nth-child</code>等），得到最后的结果。</p>\n","path":"2013-11-03-javascript-find-the-elements.json","year":"2013","month":"11","day":"03","tags":["JavaScript"]},{"link":"/posts/2013/11/02/javascript-parsing-selector.html","title":"Secrets of the JavaScript Ninja 读书笔记之 解析选择器","summary":"<p>之前的纯JavaScript实现的CSS选择器引擎中，只是简单地使用标签选择器，所以解析起来十分简单，就是按空格<code>split</code>就好了。但是，CSS选择器有很多种，例如特性选择器（<code>[name=&quot;value&quot;]</code>等）就没有办法通过空格去解析。</p>\n<p>一个完整的实现需要有很多解析的规则，去处理所有合法的CSS选择器。这时候使用正则表达式就最合适不过了：</p>\n<pre><code>var selector = &quot;div.class &gt; span:not(:first-child) a[href]&quot;\nvar chunker = /((?:\\([^\\)]+\\)|\\[[^\\]]+\\]|[^ ,\\(\\[]+)+)(\\s*,\\s*)?/g;\nvar parts = [];\nchunker.lastIndex = 0;                        \nwhile ((m = chunker.exec(selector)) !== null) {     \n  parts.push(m[1]);\n  if (m[2]) {                         \n    extra = RegExp.rightContext;\n    break;\n  }\n}\n</code></pre><p>使用书中提供的这个正则表达式就可以解析出上面那个这么复杂的选择器了！</p>\n<p>这个例子只是完整的实现的其中一部分，还有一些其他我们要支持的CSS选择器需要增加自己的规则。某些选择器引擎使用一个Map把正则表达式映射到一个函数，当一个正则表达式匹配的时候，对应的函数就会执行，解析其中的CSS选择器。</p>\n<p>如果大家有兴趣去查看完整的CSS选择器是如何实现的，可以去查看<a href=\"https://github.com/jquery/jquery\">jQuery的源码</a>。</p>\n","path":"2013-11-02-javascript-parsing-selector.json","year":"2013","month":"11","day":"02","tags":["JavaScript"]},{"link":"/posts/2013/11/01/ie-ondataavailable-event.html","title":"IE的dataavailable事件","summary":"<p>虽然<code>postMessage</code>已经是跨<code>iframe</code>通讯的一个比较完善的解决方案了，但是，如果，要IE8及以上的版本才支持这个方法。如果这两个<code>iframe</code>是同域的话，其实是可以直接通过脚本操作两个<code>window</code>，直接调用其内部方法就行通讯：</p>\n<pre><code>// outer\nvar innerWin = document.getElemenetById(&quot;iframe&quot;).contentWindow;\ninnerWin.doSomething();\n// inner\nfunction doSomething() {\n  alert(&quot;outer message!&quot;);\n}\n</code></pre><p>其实还有一个方法，就是<code>dataavailable</code>事件。这个事件是IE特有的事件，当数据源对象的数据准备好之后，可以触发这个事件来通知其他对象。</p>\n<p>这个事件像其他标准事件一样，可以使用以下几个方式来绑定：</p>\n<ol>\n<li>在HTML里面：<code>&lt;element ondataavailable=&quot;handler&quot;&gt;&lt;/element&gt;</code>。</li>\n<li>作为属性：<code>object.ondataavailable = handler;</code>。</li>\n<li>使用<code>attachEvent</code>：<code>object.attachEvent(&quot;ondataavailible&quot;, handler);</code>。</li>\n<li>在IE9还可以使用<code>addEventListener</code>：<code>object.addEventListener(&quot;dataavailible&quot;, handler, useCapture);</code>。</li>\n</ol>\n<p>由于这个事件不是用户触发的，我们需要使用脚本在特定的对象上触发这个事件：</p>\n<pre><code>var event = document.createEventObject();\n</code></pre>","path":"2013-11-01-ie-ondataavailable-event.json","year":"2013","month":"11","day":"01","tags":["JavaScript"]},{"link":"/posts/2013/10/31/window-postmessage.html","title":"window.postMessage","summary":"<p>以前我们需要在跨域的<code>iframe</code>中通讯，只能使用一个中间<code>iframe</code>跳转（或者<code>window.name</code>）来进行数据交换。而<code>window.postMessage</code>允许我们进行安全的跨域通讯。</p>\n<p>调用<code>window.postMessage</code>的时候会在目标的<code>window</code>上分发<code>MessageEvent</code>。这个事件对象包括事件类型<code>message</code>和一些关于这次消息通讯的属性，包括数据、源还有调用<code>postMessage</code>的<code>window</code>等。</p>\n<p>这个方法接受两个参数：</p>\n<ol>\n<li><code>message</code>，要传输的数据。</li>\n<li><code>targetOrigin</code>，声明特定的域接收这个事件，可以是<code>*</code>或者是一个URI。如果目标<code>window</code>的域与这个参数不匹配，则不会把事件分发到这个<code>window</code>。这样就可以防止事件的信息被不信任的代码捕获到。</li>\n</ol>\n<p>我们可以通过以下的代码接收别的<code>window</code>发送过来的消息：</p>\n<pre><code>window.addEventListener(&quot;message&quot;, receiveMessage, false);\nfunction receiveMessage(event) {\n  if (event.origin !== &quot;http://example.org:8080&quot;)\n    return;\n    // ...\n}\n</code></pre><p>事件对象有以下几个属性：</p>\n<ol>\n<li><code>data</code>，就是通过<code>postMessage</code>传入的第一个参数的值。</li>\n<li><code>origin</code>，调用<code>postMessage</code>的<code>window</code>所在的域。这个属性包括协议、主机还有端口。这个域只是调用<code>postMessage</code>当时的<code>window</code>所在的域。</li>\n</ol>\n","path":"2013-10-31-window-postmessage.json","year":"2013","month":"10","day":"31","tags":["JavaScript","html5"]},{"link":"/posts/2013/10/30/javascript-same-origin-policy.html","title":"JavaScript同源策略","summary":"<p>当一个不是当前页面的域下的脚本要跟当前页面进行交互，要受到这个同源策略的限制。这里的同源指的是页面和脚本路径的协议、端口和主机都一样。其中一项不一样都视作不同源，也就是我们常说的跨域：</p>\n<pre><code>http://store.company.com/dir/other.html\nhttp://store.company.com/dir2/other.html // same\nhttp://store.company.com:81/dir/other.html // not same\n</code></pre><p>一个页面还可以更改其所在的域，不过有很多限制。可以通过设置<code>document.domain</code>改变当前页面的域，但是只能够设置到当前域的后缀部分，例如：</p>\n<pre><code>// current domain: www.duowan.com\ndocument.domain = &quot;duowan.com&quot;; // success\ndocument.domain = &quot;u.duowan.com&quot;; // error\n</code></pre><p>设置了域之后的跨域检查都会使用设置后的值去计算。有一点需要注意的是，设置<code>document.domain</code>之后端口会被重置为<code>null</code>，所以<code>company.com:8080</code>和<code>company.com</code>要通讯，两个页面都需要设置<code>document.domain</code>，这样端口才能一致。</p>\n<p>跨域的访问通常可以分成三种：</p>\n<ol>\n<li>a跨域“写”，即链接、跳转和表单提交，这种行为是允许的。</li>\n<li>a跨域“嵌入”，即<code>script</code>、<code>link</code>、<code>img</code>、<code>video</code>、<code>object</code>、<code>embed</code>、<code>iframe</code>等，这些也是被允许的。</li>\n<li>a跨域“读”，例如<code>XMLHttpRequest</code>，一般是不允许的，需要设置CORS才能允许这些跨域访问。</li>\n</ol>\n<p>在JavaScript中，我们可以通过<code>iframe.contentWindow</code>、<code>window.parent</code>等API去访问页面中的其他文档。如果这些文档不在同一个域，访问这些文档的<code>winodw</code>和<code>location</code>会被禁止。如果需要跨域的<code>iframe</code>通讯，请使用HTML5提供的<code>postMessage</code>API或者使用一些框架去实现，例如<a href=\"https://github.com/biqing/MessengerJS\">MessengerJS</a>。</p>\n","path":"2013-10-30-javascript-same-origin-policy.json","year":"2013","month":"10","day":"30","tags":["JavaScript"]},{"link":"/posts/2013/10/29/document-cookie.html","title":"document.cookie","summary":"<p>什么是cookie？</p>\n<blockquote>\n<p>cookie 是存储于访问者的计算机中的变量。每当同一台计算机通过浏览器请求某个页面时，就会发送这个 cookie。你可以使用 JavaScript 来创建和取回 cookie 的值。</p>\n</blockquote>\n<p>对应的JavaScript API就是<code>document.cookie</code>。这是一个非常奇怪的属性，我们可以通过访问这个属性得到当前页面的所有cookie：</p>\n<pre><code>allCookies = document.cookie;\n</code></pre><p>返回的字符串是一系列的键值对，用<code>;</code>隔开，键值用<code>=</code>连接：</p>\n<pre><code>key1=value1;key2=value2\n</code></pre><p>我们需要使用一个正则表达式去把这个字符串转成JavaScript对象（摘自<a href=\"https://github.com/aralejs/cookie/blob/master/src/cookie.js\">arale/cookie</a>）：</p>\n<pre><code>var cookieParts = document.cookie.split(/;\\s/g);\nfor (var i = 0, len = cookieParts.length; i &lt; len; i++) {\n  var cookieNameValue = cookieParts[i].match(/([^=]+)=/i);\n  if (cookieNameValue) {\n    var cookieName = decodeURIComponent(cookieNameValue[1]);\n    var cookieValue = decodeURIComponent(cookieParts[i]\n      .substring(cookieNameValue[1].length + 1));\n    result[cookieName] = cookieValue;\n</code></pre>","path":"2013-10-29-document-cookie.json","year":"2013","month":"10","day":"29","tags":["JavaScript"]},{"link":"/posts/2013/10/28/jquery-callbacks-add.html","title":"jQuery扫盲之Callbacks","summary":"<p>jQuery在1.7的时候引入了一个<code>jQuery.Callbacks</code>方法，返回一个强力的对象去管理我们的回调函数列表。这个对象支持对回调函数列表的增删改、触发停用等操作。</p>\n<p>先来看看这个方法用来干嘛的：</p>\n<blockquote>\n<p> A multi-purpose callbacks list object that provides a powerful way to manage callback lists</p>\n</blockquote>\n<p>简单的说就是返回一个对象让我们去管理回调函数。这个方法接受一个参数，可以配置<code>callbacks</code>的行为。返回的对象提供了一些方法，让我们可以去控制这些回调函数，例如增加、删除、触发或者禁用等。</p>\n<p>最简单的用法是：</p>\n<pre><code>var callbacks = $.Callbacks();\ncallbacks.add(function () { alert(1); });\ncallbacks.fire(); // alert(1);\n</code></pre><p><code>add</code>就是增加回调函数，<code>fire</code>就是触发这些回调，就是这么简单。在调用<code>jQuery.Callbacks</code>的时候我们还可以传入一个标志位，它是若干的标志的集合，用空格分开，支持以下标志位：</p>\n<ol>\n<li><code>once</code>，表示这个回调函数列表只能被<code>fire</code>一次，之后的<code>fire</code>都不会调用这些回调函数。</li>\n<li><code>memory</code>，表示会跟踪触发的状态，即<code>fire</code>之后再<code>add</code>的回调函数，不需要再次<code>fire</code>也会被执行。</li>\n<li><code>unique</code>，表示一个回调只能被<code>add</code>一次。</li>\n<li><code>stopOnFalse</code>，表示当一个回调函数返回<code>false</code>的时候剩下的回调函数都不会被执行。</li>\n</ol>\n<p>可以看到这些标志位的设置跟jQuery常用的事件处理的方式都有点联系，例如<code>one</code>可以看到<code>jQuery.fn.one</code>这种绑定事件的方式，而<code>stopOnFalse</code>正好也是jQuery在处理事件的时候<code>return false</code>有点关系。其实jQuery关于事件的操作很多都是基于这个<code>callbacks</code>对象去做的，例如<code>$.Deffered</code>。</p>\n","path":"2013-10-28-jquery-callbacks-add.json","year":"2013","month":"10","day":"28","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/10/27/javascript-css-selector-implementation.html","title":"Secrets of the JavaScript Ninja 读书笔记之 纯JavaScript实现的CSS选择器引擎","summary":"<p>一个CSS选择器引擎的核心其实是纯JavaScript实现的这个部分。最主要的功能就是把CSS选择器映射到一系列浏览器原生提供的API（例如<code>getElementById</code>或者<code>getElementsByTagName</code>等）的调用序列，通过这些原生的API去寻找我们想要定位到的元素。</p>\n<p>为什么还需要一个纯JavaScript实现的CSS选择器引擎？</p>\n<ol>\n<li>a因为IE6和IE7不支持原生的CSS选择器、也不支持使用XPath。</li>\n<li>a因为我们的站点可能需要向前兼容这些古董浏览器。</li>\n<li>a因为效率，某些CSS选择器使用原生的API速度更快（例如<code>id</code>选择器）。</li>\n<li>a因为CSS选择器的覆盖率，由于不是所有支持原生CSS选择器的浏览器都支持所有CSS选择器，所以当某个选择器在某个浏览器里面不支持就要退化到纯JavaScript的实现。</li>\n</ol>\n<p>通常我们会从左到右分析一个CSS选择器，然后顺着<code>root</code>往下找，例如以下的选择器：</p>\n<pre><code>div.ninja a span\n</code></pre><p>按照一般的逻辑，我们会找<code>class</code>是<code>ninja</code>的<code>div</code>，在它的子元素中找<code>a</code>，在<code>a</code>的子元素中找<code>span</code>。这里要注意两个问题：</p>\n<ol>\n<li>a返回的结果可能有多个，它们的顺序要跟定义的顺序一致。</li>\n<li>a返回的结果中不能有重复的DOM。</li>\n</ol>\n<p>由于这两个问题，使用从上到下分析DOM文档树的方法可能需要一些额外的工作量，所以就有了从下到上分析DOM文档树的方法去解析CSS选择器。原理就是先找出文档树中匹配最右边的选择器的元素，再去匹配它的祖先元素是否满足左侧的CSS选择器：</p>\n<pre><code>function find(selector, root) {\n  root  = root || document;\n</code></pre>","path":"2013-10-27-javascript-css-selector-implementation.json","year":"2013","month":"10","day":"27","tags":["JavaScript"]},{"link":"/posts/2013/10/25/jquery-val.html","title":"jQuery扫盲之val","summary":"<p>jQuery提供了一个简便的方法让我们去获取DOM的<code>value</code>特性，就是<code>jQuery.fn.val</code>方法。跟<code>attr</code>和<code>prop</code>一样，它也是一个<code>getter</code>和<code>setter</code>一体的方法。</p>\n<h3 id=\"getter\">getter</h3>\n<blockquote>\n<p>Get the current value of the first element in the set of matched elements.</p>\n</blockquote>\n<p>跟<code>attr</code>和<code>prop</code>也一样的是，作为<code>getter</code>的<code>val</code>方法不接受任何参数，只会获取jQuery对象中地一个元素的<code>value</code>的值：</p>\n<pre><code>$(elem).val();\n</code></pre><p>通常我们会在<code>input</code>、<code>select</code>或者<code>textarea</code>元素上使用<code>val</code>方法。当<code>select</code>的<code>multiple</code>特性声明为有效的时候，<code>val</code>会返回一个数组，包含了选中的<code>option</code>的<code>value</code>；如果没有选中任何<code>option</code>，则会返回<code>null</code>。</p>\n<p>如果目标对象不是以上的元素（例如<code>div</code>、<code>a</code>等），<code>val</code>方法会返回一个空字符串。其实就是返回DOM上的<code>value</code>属性，而不是<code>value</code>特性：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/Hrv6u/embedded/js,html/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<h3 id=\"setter\">setter</h3>\n<blockquote>\n<p>Set the value of each element in the set of matched elements.</p>\n</blockquote>\n<p>跟<code>attr</code>和<code>prop</code>也十分类似，有两种传输参数的方式：</p>\n","path":"2013-10-25-jquery-val.json","year":"2013","month":"10","day":"25","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/10/24/javascript-string-replace.html","title":"字符串的replace方法","summary":"<p><code>replace</code>是一个我们经常都会使用到的方法，最简单的就是直接使用字符串进行替换，还有就是可以传入正则表达式进行替换。不仅可以简单地替换字符串，而且还可以传入一个回调函数进行更复杂的替换。今天就简单看一下这个方法可以怎么用。</p>\n<p><code>replace</code>方法不会改变原来的字符串，它会返回一个替换后的新字符串。它接受两个参数，每个参数都有两种传入形式。</p>\n<p>第一个参数可以是一个正则表达式，它匹配的结果会被第二个参数的返回值替换；也可以是一个字符串，原字符串中与这个字符串相同的子串会被第二个参数的返回值：</p>\n<pre><code>&quot;abca&quot;.replace(&quot;a&quot;, &quot;d&quot;); // &quot;dbca&quot;\n&quot;abca&quot;.replace(/a/, &quot;d&quot;); // &quot;dbca&quot;\n</code></pre><p>注意哦，如果第一个参数是字符串，则只会替换第一个相同的子串，如上例中的第二个<code>a</code>是没有被替换的，如果要替换全部相同的子串只能使用正则表达式：</p>\n<pre><code>&quot;abca&quot;.replace(/a/g, &quot;d&quot;); // &quot;dbcd&quot;\n</code></pre><p>第二个参数比较有意思，它可以是一个字符串，作为新值被替换。这个字符串也简单支持了一些模式，例如：</p>\n<ol>\n<li><code>$$</code>，表示一个美元符号<code>$</code>。</li>\n<li><code>$&amp;</code>，表示匹配的子串。</li>\n<li><code>$[反引号]</code>，表示匹配子串之前的子串。</li>\n<li><code>$&#39;</code>，表示匹配子串之后的子串。</li>\n<li><code>$n</code>或者<code>$nn</code>，当<code>n</code>是一个数字的时候表示第n个捕获的子串，只有当第一个参数是正则表达式的时候才有效。</li>\n</ol>\n<p>除了字符串，我们还可以指定一个回调函数作为第二个参数。<code>replace</code>会使用这个回调函数返回的值进行替换，例如：</p>\n","path":"2013-10-24-javascript-string-replace.json","year":"2013","month":"10","day":"24","tags":["JavaScript"]},{"link":"/posts/2013/10/23/javascript-unicode-hex-decode.html","title":"Unicode 16进制编码","summary":"<p>这里的16进制编码，指的是<code>\\u0001</code>这样的编码。有时候我们为了防止文件编码格式（例如<code>utf-8</code>或者<code>GBK</code>等）影响到文件中的内容（特别是中文），会在代码中使用这些编码，例如：</p>\n<pre><code>alert(&#39;\\u6211\\u662f\\u4e2d\\u6587&#39;);\n</code></pre><p>这样写的话，无论文件是什么编码，显示的信息都不会乱码，因为JavaScript无论如何都会把这个字符串解析成Unicode的编码。以前在国际化资源文件中大量使用到这个编码，所有非ASCII的字符都会以这种编码写入（当然是通过工具输入的……）。</p>\n<p>在原生的JavaScript是没有实现这种编解码的API，写一个也十分方便：</p>\n<pre><code>function getHex(str) {\n  var result = &quot;&quot;;\n  for(var i = 0; i &lt; str.length; i++) {\n    var c = str.charCodeAt(i).toString(16);\n    for (var j = 4 - (&quot;&quot; + c).length; j &gt; 0; j--) {\n      c = &quot;0&quot; + c;\n    }\n    result += &quot;\\\\u&quot; + c;\n  }\n  return result;\n}\n</code></pre><p>为什么要写这个？因为今天发现了一个很厉害的注入：</p>\n","path":"2013-10-23-javascript-unicode-hex-decode.json","year":"2013","month":"10","day":"23","tags":["JavaScript"]},{"link":"/posts/2013/10/22/using-html5-audio-and-video-2.html","title":"使用HTML5的audio和video（二）","summary":"<p>昨天讨论了如何加入一个媒体、如何进行简单控制等内容。今天继续来看一下关于html5内建媒体<code>audio</code>和<code>vedio</code>还有什么其他功能。</p>\n<p>除了控制媒体的播放、暂停和音量，通过<code>currentTime</code>我们还可以定位到具体的某个时间点。</p>\n<p>先通过<code>seekable</code>这个属性去获取媒体的范围：</p>\n<pre><code>var mediaElement = \n  document.getElementById(&#39;mediaElementID&#39;);\nmediaElement.seekable.start();\nmediaElement.seekable.end();\n</code></pre><p>其中<code>start</code>和<code>end</code>方法会返回整个媒体的开始和结束，单位是秒。然后我们就可以设置<code>currentTime</code>让媒体定位到指定的时间点：</p>\n<pre><code>mediaElement.currentTime = 122;\n</code></pre><p>除了以上的方法，我们还可以通过DOM上的<code>played</code>属性去获取媒体已经播放过的时间：</p>\n<pre><code>mediaElement.played.end();\n</code></pre><p>全部都以秒为单位。</p>\n<p>我们还可以指定媒体的播放范围。在URL后增加<code>#t=[starttime][,endtime]</code>参数即可。里面的参数可以是秒，也可以是类似<code>2:05:01</code>这样的字符串：</p>\n","path":"2013-10-22-using-html5-audio-and-video-2.json","year":"2013","month":"10","day":"22","tags":["html5"]},{"link":"/posts/2013/10/21/using-html5-audio-and-video-1.html","title":"使用HTML5的audio和video（一）","summary":"<p>HTML5提供了内建<code>audio</code>和<code>video</code>，使用它们可以简单地在我们的页面中插入一些媒体：</p>\n<pre><code>&lt;video src=&quot;http://v2v.cc/~j/theora_testsuite/320x240.ogg&quot; controls&gt;\n  Your browser does not support the &lt;code&gt;video&lt;/code&gt; element.\n&lt;/video&gt;\n</code></pre><p>以下是一个真实的例子：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/BzGex/embedded/html,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<p>以<code>video</code>为例：</p>\n<ol>\n<li><code>src</code>，声明这个媒体文件的路径，可以是一个URL或者是一个本地路径。</li>\n<li><code>controls</code>，声明是否显示控件。</li>\n<li><code>autoplay</code>，声明是否自动开始播放。</li>\n<li><code>loop</code>，声明是否自动循环播放。</li>\n<li><code>preload</code>，声明缓存的方式：<ol>\n<li><code>none</code>表示不缓存文件。</li>\n<li><code>auto</code>表示缓存文件。</li>\n<li><code>metadata</code>表示只缓存文件的元数据。</li>\n</ol>\n</li>\n</ol>\n<p>其中<code>src</code>可以通过<code>sorce</code>子标签声明多个：</p>\n","path":"2013-10-21-using-html5-audio-and-video-1.json","year":"2013","month":"10","day":"21","tags":["html5"]},{"link":"/posts/2013/10/20/javascript-xpath-css-selector.html","title":"Secrets of the JavaScript Ninja 读书笔记之 使用XPath","summary":"<p>当浏览器不支持W3C标准的CSS选择器API，我们可以使用XPath作为替代的实现。XPath是一个用来在DOM文档中选择元素的一门语言，比CSS选择器功能更为强大。在大部分的现代浏览器中也实现了XPath，我们可以使用相关的API在HTML文档中去获取元素。可惜IE6以及之前的版本只支持在XML DOM中使用XPath（囧）。</p>\n<p>其中一个使用XPath的原因是，当选择器比较复杂的时候XPath的效率要比纯JavaScript实现的选择器引擎高。相反的，当选择器比较简单（例如Id选择器或者是标签等）XPath的效率就比较低了。</p>\n<p>浏览器实现了一个<code>evaluate</code>方法去使用XPath选择DOM元素，下面是书中的一个例子：</p>\n<pre><code>if (typeof document.evaluate === &quot;funtion&quot;) {\n  function getElementByXPath(expression, parentElement) {\n    var results = [];\n    var query = document.evaluate(expression,\n        parentElement || document,\n        null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);\n    for (var i = 0, length = query.snapshotLength; i &lt;length; i++) {\n      results.push(query.snapshotItem(i));\n    }\n    return results;\n  }\n}\n</code></pre><p>但是如果直接使用XPath的表达式的话，对于用户来说是比较复杂的。我们可以把CSS选择器映射到特定的XPath表达式，用户就可以通过CSS选择器来使用我们提供的API了，例如：</p>\n<pre><code>$(&quot;#foo&quot;); // XPath: *[@id=&#39;foo&#39;]\n</code></pre>","path":"2013-10-20-javascript-xpath-css-selector.json","year":"2013","month":"10","day":"20","tags":["JavaScript"]},{"link":"/posts/2013/10/19/javascript-w3c-css-selector-api.html","title":"Secrets of the JavaScript Ninja 读书笔记之 W3C CSS选择器API","summary":"<p>由于jQuery的风靡，W3C在规范中加入了浏览器内置的CSS选择器引擎，来减少我们去实现一个纯JavaScript的CSS选择器引擎所导致的额外工作量。所有现代浏览器都已经实现了对应的API，并且如果该浏览器完全支持CSS3的话，所有CSS选择器都是可用的。</p>\n<p>浏览器提供了以下两个API供我们使用CSS选择器去选择我们要操作的DOM：</p>\n<ol>\n<li><code>querySelector</code>，该方法接受一个CSS选择器，并返回匹配的<strong>第一个</strong>DOM元素。</li>\n<li><code>querySelectorAll</code>，该方法接受一个CSS选择器，返回一个包含所有匹配的DOM元素的一个<code>NodeList</code>。</li>\n</ol>\n<p>这两个方法在所有<code>document</code>、<code>documentFragment</code>和DOM元素上都有。在哪个对象上调用这些API即视该DOM为根元素，会在该对象的子孙寻找匹配的元素。</p>\n<p>恐怕这些API最大的局限性就是浏览器对CSS选择器的支持程度，而纯JavaScript实现的CSS选择器则不会受到浏览器默认实现的影响。而且还有一个可能看起来比较别扭的使用场景：</p>\n<pre><code>&lt;div id=&quot;test&quot;&gt;\n  &lt;b&gt;Hello&lt;/b&gt;, I&#39;m a ninja!\n&lt;/div&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n  window.onload = function () {\n  var b = document.getElementById(&quot;test&quot;).querySelector(&quot;div b&quot;);\n  assert(b, &quot;Only the last part of the selector matters.&quot;);\n};\n&lt;/script&gt;\n</code></pre><p>在这个例子里面，选择器的愿意是寻找<code>div</code>子孙中的<code>b</code>。但是由于<code>querySelector</code>是在<code>div</code>上调用的，而这个元素是不计入选择器的匹配范围的，即上面的代码是找<code>div</code>下面的<code>div</code>下面的<code>b</code>，所以自然就匹配不上了。</p>\n","path":"2013-10-19-javascript-w3c-css-selector-api.json","year":"2013","month":"10","day":"19","tags":["JavaScript"]},{"link":"/posts/2013/10/18/css-outline.html","title":"CSS outline","summary":"<p>如果我们没有任何<code>reset.css</code>，当Chrome上的输入框获得焦点的时候会有一圈淡黄色的“边框”，这个就是<code>outline</code>在搞鬼。</p>\n<blockquote>\n<p>An outline is a line that is drawn around elements, outside the border edge, to make the element stand out.</p>\n</blockquote>\n<p><code>outline</code>是在<code>border</code>之外的另外一圈“边框”，让该元素能突显出来。它是一个复合的CSS样式，跟<code>border</code>一样，由以下几个部分组成：</p>\n<ol>\n<li><code>outline-color</code>，表示“边框”的颜色。</li>\n<li><code>outline-width</code>，表示“边框”的宽度。</li>\n<li><code>outline-style</code>，表示“边框”的样式，取值的范围几乎跟<code>border</code>是一样的。</li>\n</ol>\n<p>每个部分都跟<code>border</code>类似，那<code>outline</code>跟<code>border</code>有什么不一样的地方吗？主要是以下两个方面：</p>\n<ol>\n<li><code>outline</code>不会占用空间，而<code>border</code>则是盒模型的一部分，有独立的空间。<code>outline</code>就像“浮空”在元素上面一样。</li>\n<li><code>outline</code>在某些浏览器（例如Opera）上可以不是矩形的，而<code>border</code>则什么时候都是矩形的。</li>\n</ol>\n<p>这个会造成一些非常有意思的例子，如：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/aaG3R/embedded/css,html,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<p>这个例子里面，两个元素的HTML是一样的，一个是设置了<code>outline</code>，一个是设置了<code>border</code>。可以看到<code>outline</code>里面的框是把折行后的<code>span</code>包围起来，而中间重复的部分是没有框的。而<code>border</code>重复的部分则把原来<code>span</code>的元素给遮住了。</p>\n<p>正如<code>outline</code>的定义所说，这个样式就是为了让一个元素“突显”出来，所以设置这个样式是不会影响布局的。可能也是因为这样所以Chrome的默认样式里面就为获得焦点的<code>input</code>设置<code>outline</code>，让用户更清晰地知道焦点在哪。</p>\n","path":"2013-10-18-css-outline.json","year":"2013","month":"10","day":"18","tags":["css"]},{"link":"/posts/2013/10/17/jquery-datatable-feature.html","title":"jQuery DataTable 配置之特性配置","summary":"<p>表格其实是一个非常难开发得好的组建，因为其需求太多了。排序、分页、过滤、单元格个性化……考虑到这些东西，还是使用DataTable作为底层比较方便（可惜已经很久没更新了，估计太重了坑太多……）。DataTable的用法非常简单：</p>\n<pre><code>$(elem).dataTable();\n</code></pre><p>可以传入一个<code>options</code>作为配置。DataTable的配置十分丰富，分成特性、选项等几个方面，今天先看看如何配置DataTable支持的特性。</p>\n<p><strong>bAutoWidth</strong></p>\n<p>布尔值，默认是<code>true</code>。表示启用或者禁用自动调整列宽的功能。自动调整列宽可以通过显式制定列宽（通过配置<code>aoColumns</code>）来禁用：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/hKpX4/embedded/js,html,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<p><strong>bDeferRender</strong></p>\n<p>布尔值，默认是<code>false</code>。表示是否需要动态加载数据。当表格的数据量很大的时候，为了提高加载的速度，只能加载一页数据，当用户翻页的时候才加载下一页的数据。这样，需要把<code>bDeferRender</code>设置成<code>true</code>，并提供一个地址作为数据源（<code>sAjaxSource</code>）。</p>\n<p><strong>bFilter</strong></p>\n<p>布尔值，默认是<code>true</code>。表示是否需要过滤器。如果设成<code>false</code>则不会显示默认的过滤器。</p>\n<p><strong>bInfo</strong></p>\n","path":"2013-10-17-jquery-datatable-feature.json","year":"2013","month":"10","day":"17","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/10/16/jquery-prop.html","title":"jQuery扫盲之prop","summary":"<p>与昨天介绍的<code>attr</code>一样，<code>prop</code>也是个getter、setter一体的方法。</p>\n<h3 id=\"getter\">getter</h3>\n<hr>\n<blockquote>\n<p>Get the value of a property for the first element in the set of matched elements.</p>\n</blockquote>\n<p>作为getter的<code>prop</code>方法接受一个参数<code>propertyName</code>，就是要获取的属性名字。和<code>attr</code>一样，它也只会获取jQuery对象中第一个元素的属性值。</p>\n<p>那<code>prop</code>跟<code>attr</code>有什么区别呢？在jQuery 1.6之前，<code>attr</code>有时候会获取到属性值而不是特性值，这样会导致一些不一致的场景。例如：</p>\n<pre><code>$(elem).attr(&quot;checked&quot;); // 1.6 return true or false\n</code></pre><p>所以，在1.6之后，<code>prop</code>返回的是属性值，<code>attr</code>返回的是特性值：</p>\n<pre><code>$(elem).attr(&quot;checked&quot;); // as of 1.6 return &quot;checked&quot; or null\n</code></pre><p>其中，<code>selectedIndex</code>、<code>tagName</code>、<code>nodeName</code>、<code>nodeType</code>、<code>ownerDocument</code>、<code>defaultChecked</code>和<code>defaultSelected</code>应该使用<code>prop</code>去获取它们的值，因为它们是DOM的属性，在DOM上也没有对应的特性。</p>\n<p>而有相同名称的特性的属性，使用这两个方法获取有什么区别呢？下面以<code>checked</code>这个特性为例：</p>\n<pre><code>elem.checked; // true or false\n</code></pre>","path":"2013-10-16-jquery-prop.json","year":"2013","month":"10","day":"16","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/10/15/jquery-attr.html","title":"jQuery扫盲之attr","summary":"<p><code>jQuery.fn.attr</code>是一个根据传入参数的个数判断是setter还是getter的一个方法。</p>\n<h3 id=\"getter\">getter</h3>\n<hr>\n<blockquote>\n<p>Get the value of an attribute for the first element in the set of matched elements.</p>\n</blockquote>\n<p>作为getter的<code>attr</code>方法只接受一个参数：<code>attrName</code>，指定需要获取的特性的名字。如果该jQuery对象包含多个元素，则只会返回第一个元素的特性值。如果需要获取所有元素的值，需要遍历这个jQuery对象，再逐个调用<code>attr</code>方法。</p>\n<p>调用这个方法获取特性值有两个好处：</p>\n<ol>\n<li>方便，直接通过jQuery对象就可以调用。</li>\n<li>跨浏览器兼容。有一些特性在不同的浏览器中表现是不一致的，<code>attr</code>方法封装了这些不一致，提供统一的API以及结果。</li>\n</ol>\n<p>有两个值得注意的地方：</p>\n<ol>\n<li>返回的值一般都是字符串，而一些<code>value</code>和<code>tabindex</code>除外。</li>\n<li>修改一个已经存在在文档中的<code>input</code>的<code>type</code>特性，在IE6、7、8会抛出异常。</li>\n</ol>\n<p>如果指定的特性不存在，则<code>attr</code>返回<code>undefined</code>。诸如<code>checked</code>、<code>disabled</code>或者<code>selected</code>等特性，最好使用<code>prop</code>来获取。再介绍完<code>prop</code>之后会为两者进行一个对比。</p>\n<h3 id=\"setter\">setter</h3>\n","path":"2013-10-15-jquery-attr.json","year":"2013","month":"10","day":"15","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/10/14/jquery-manipulate-class.html","title":"jQuery扫盲之处理class","summary":"<p>这个class当然是指HTML上面的class了！今天看一些jQuery有关操作DOM的class的一些方法，就是增删改查它们！</p>\n<h3 id=\"jquery-fn-addclass\">jQuery.fn.addClass</h3>\n<hr>\n<blockquote>\n<p>Adds the specified class(es) to each of the set of matched elements.</p>\n</blockquote>\n<p>为DOM加上特定的class，该方法接受一个参数，但是可以传入两种不同的参数：</p>\n<ol>\n<li><code>className</code>，要增加的class的名字，可以是多个，用空格分开。</li>\n<li><code>function(index, currentClass)</code>，一个回调函数，返回一个字符串，增加字符串指定的class。回调函数接受的参数，<code>index</code>是当前jQuery对象的索引，而<code>currentClass</code>则为当前的class，也可以有多个，用空格隔开。</li>\n</ol>\n<p>不用担心重复，jQuery已经做了这些工作，所以重复增加相同的class是没有问题的。</p>\n<h3 id=\"jquery-fn-removeclass\">jQuery.fn.removeClass</h3>\n<hr>\n<blockquote>\n<p>remove a single class, multiple classes, or all classes from each element in the set of matched elements.</p>\n</blockquote>\n<p>这个方法接受的参数跟<code>addClass</code>一模一样。有一个要注意的是，如果什么都不传入，则会把元素上的所有class都删掉，如：</p>\n<pre><code>$(elem).removeClass(); // remove all class\n</code></pre>","path":"2013-10-14-jquery-manipulate-class.json","year":"2013","month":"10","day":"14","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/10/13/javascript-css-selector-engine.html","title":"Secrets of the JavaScript Ninja 读书笔记之 简述CSS选择器引擎","summary":"<p>随着jQuery的风靡，CSS选择器引擎已经作为一个标准，现代浏览器都可以通过例如<code>querySelector</code>等API去使用像jQuery那样的CSS选择器去选择DOM了。既然这样，为什么还要讨论JavaScript实现的CSS选择器引擎呢？</p>\n<p>其中一个比较重要的原因是因为浏览器实现的CSS选择器引擎还是一个半成品，所以有一些细节没有考虑，例如DOM的缓存、错误报告机制和扩展机制等。而一些JavaScript类库提供的CSS选择器引擎（尤其是jQuery），以上的这些细节都是有所考虑的。所以，在现实的项目中，由于使用场景比较多，其性能可能比浏览器实现的CSS选择器引擎要高，例如多次使用相同的选择器去选择DOM等。</p>\n<p>那又是为什么要去了解一个JavaScript实现的选择器引擎是如何工作的呢？通过了解其工作机制，我们可以了解怎样去遍历一个文档树。而且，只有了解一个选择器引擎的工作机制，我们才可以写出高性能的选择器（例如<code>.className</code>和<code>div.className</code>的区别）。由于使用CSS选择器去获取DOM几乎是我们每个功能都必须要使用，而且要使用多次的功能，所以提高其性能是十分重要的哦。</p>\n<p>其实，我们的日常工作都可以抽象成以下两个步骤：</p>\n<ol>\n<li>获取我们需要操作的DOM。</li>\n<li>在这些DOM上面弄点什么。</li>\n</ol>\n<p>在使用CSS选择器之前，由于浏览器的API的限制（<code>document.getElementById</code>和<code>document.getElementsByTagName</code>），要选中我们需要操作的DOM，可能还需要一大部分代码。所以，通过CSS选择器选择DOM元素是一个十分高效而且准确的手段。通过减少步骤1的代码量，我们可以把更多的心思花在步骤2里面，例如提供更好的用户体验等。</p>\n<p>除了以上的原因，我们需要一个JavaScript实现的CSS选择器引擎的原因，就是要支持那些没有内置CSS选择器的浏览器，所以需要我们抽象另外一个接口去使用CSS选择器引擎。一般实现一个JavaScript的CSS选择器有以下几个步骤：</p>\n<ol>\n<li>优先使用W3C的标准API。</li>\n<li>使用XPath。</li>\n<li>使用JavaScript遍历DOM树。</li>\n</ol>\n","path":"2013-10-13-javascript-css-selector-engine.json","year":"2013","month":"10","day":"13","tags":["JavaScript"]},{"link":"/posts/2013/10/12/dom-innerhtml.html","title":"DOM的innerHTML属性","summary":"<p><code>innerHTML</code>可以访问一个DOM对象的子孙节点的HTML字符串，也可以设置该DOM元素内部的HTML字符串，浏览器会自动把这些字符串转成DOM结构并塞到该DOM元素内，例如：</p>\n<pre><code>var content = element.innerHTML;\nelement.innerHTML = content;\n</code></pre><p>访问<code>innerHTML</code>属性的时候，该元素内部的文本节点如果有<code>&amp;</code>、<code>&lt;</code>或者<code>&gt;</code>，则会转成对应的XML实体，需要注意。</p>\n<p><code>innerHTML</code>简化了DOM操作，多层嵌套的DOM结构如果用<code>document.createElement</code>等DOM API生成的话需要非常多的代码，而使用<code>innerHTML</code>则只需要编写一段HTML字符串即可，简单高效。</p>\n<p><code>innerHTML</code>的作用有很多，可以清空一个元素内部的所有DOM节点：</p>\n<pre><code>element.innerHTML = &quot;&quot;;\n</code></pre><p>也可以查看页面的DOM结构：</p>\n<pre><code>javascript:&quot;&lt;pre&gt;&quot;+document.documentElement.innerHTML.replace(/&lt;/g,&quot;&amp;lt;&quot;) + &quot;&lt;/pre&gt;&quot;;\n</code></pre><p>注意哦，由于安全问题，通过<code>innerHTML</code>设置的<code>script</code>标签是不会被执行的哦。但是，还是可以通过某种手段执行一些代码：</p>\n<pre><code>var name = &quot;&lt;img src=x onerror=alert(1)&gt;&quot;;\nel.innerHTML = name; // shows the alert\n</code></pre>","path":"2013-10-12-dom-innerhtml.json","year":"2013","month":"10","day":"12","tags":["JavaScript"]},{"link":"/posts/2013/10/11/assertion-expect-js.html","title":"一个断言：expect.js","summary":"<p>讲了测试驱动和测试框架，最后再来讲一下断言。断言的风格其实有很多，而Mocha这个测试框架则允许我们使用自己喜欢的断言来写测试代码。今天简单了解一下其中一个断言：expect.js（我不会告诉你为什么选择这个断言是因为Arale也用了这个）。</p>\n<p>expect.js是基于<code>should.js</code>的一个断言工具，比<code>should</code>要清爽一些。支持所有主流的浏览器和测试框架，并兼容Node的模块格式，所以在Node中可以这样使用expect.js：</p>\n<pre><code>require(&quot;path/to/expect.js&quot;);\n</code></pre><p>为了在浏览器也使用这个断言，SPM封装了其CMD的模块，使用以下命令就可以安装了：</p>\n<pre><code>spm install gallery/expect -d path/to/seajs-base-path\n</code></pre><p>因为昨天编写的测试用例也是一个CMD模块，所以在浏览器也可以使用expect.js来断言啦！</p>\n<p>也可以通过<code>script</code>标签直接引入脚本文件来使用，不过这个时候<code>expect</code>就是一个全局变量了：</p>\n<pre><code>&lt;script src=&quot;expect.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>它的断言很有意思，符合英文语法，例如：</p>\n<pre><code>expect(1).to.be.ok();\n</code></pre><p>这个断言判断<code>expect</code>中的参数是否一个在JavaScript中代表<code>true</code>的变量，例如非0数字和非空字符串等。是不是跟写英文句子有点像？</p>\n","path":"2013-10-11-assertion-expect-js.json","year":"2013","month":"10","day":"11","tags":["前端","JavaScript"]},{"link":"/posts/2013/10/10/use-mocha-to-test-seajs-modules.html","title":"使用Mocha测试SeaJs模块","summary":"<p>昨天介绍了测试驱动，Karma的作用只是拉起浏览器，加载需要的脚本，例如测试框架、源码还有测试代码，执行加载的代码。测试代码怎么写，用什么测试框架，它是不关心的。今天继续昨天的单元测试问题，讨论的是使用Mocha这个单元测试框架去编写我们的测试用例。</p>\n<p>由于是使用Karma拉起的，所以只使用Karma里面的Mocha适配器即可，即在Karma配置文件中配置<code>framework</code>：</p>\n<pre><code>`framework`: [&quot;mocha&quot;],\n</code></pre><p>然后参考昨天讨论过的结果，在测试入口文件调用：</p>\n<pre><code>mocha.run();\n</code></pre><p>即可拉起之前通过<code>seajs.use</code>加载的测试代码。</p>\n<p>我们的测试代码也是以一个CMD模块加载进来的，所以测试代码看上去应该是这样的：</p>\n<pre><code>define(function (require) {\n  var expect = require(&quot;path/to/expect.js&quot;);\n  describe(&quot;Some subject&quot;, function () {\n    it(&quot;Some case&quot;, function () {\n      expect(true).to.be(true);\n    });\n  });\n});\n</code></pre>","path":"2013-10-10-use-mocha-to-test-seajs-modules.json","year":"2013","month":"10","day":"10","tags":["前端","JavaScript"]},{"link":"/posts/2013/10/09/use-karma-to-test-seajs-module.html","title":"使用Karma测试Seajs模块","summary":"<p><a href=\"http://karma-runner.github.io/0.10/index.html\">Karma</a>是一个使用Node作为平台的单元测试驱动。通过Karma，可以实现基于命令行的自动化测试，十分方便。而且Karma只是一个底层的测试驱动，帮助我们去启动浏览器、编写测试页面、加载源码以及测试套件等功能。在Karma之上，可以使用现在各种各样流行的单元测试框架，例如Jasmine、Mocha、QUnit等，在编写测试用例的时候可以根据自己的习惯灵活地选择需要的单元测试框架，赞！</p>\n<p>首先需要安装Node。然后就可以通过npm安装Karma了：</p>\n<pre><code>npm install -g karma\n</code></pre><p>关键的是Karma的配置文件，可以通过以下命令，用交互式的方法生成一个Karma的配置文件：</p>\n<pre><code>karma init karma.conf.js\n</code></pre><p>只需要回答问题就可以生成配置了，主要是关于使用的测试框架、是否需要RequireJs的支持、需要启动哪些浏览器、引入或者排除的文件、是否需要监视文件变化进行自动测试等。</p>\n<p>生成的配置文件有以下几个比较重要的配置：</p>\n<ol>\n<li><code>basePath</code>，所有文件路径都以这个路径为根路径。</li>\n<li><code>frameworks</code>，使用的测试框架，可以是多个，例如<code>[&quot;mocha&quot;, &quot;jasmine&quot;]</code>。</li>\n<li><code>files</code>，需要引入的文件数组，数组的元素可以是字符串，声明直接引入到runner.html里面；也可以是一个对象，其中<code>pattern</code>是文件路径，<code>included</code>声明是否需要引入到runner.html里面。</li>\n<li><code>exclude</code>，需要排除的文件数组，内容格式跟<code>file</code>一致。</li>\n<li><code>port</code>，测试服务器的端口号。</li>\n<li><code>autoWatch</code>，是否自动监听文件变化进行测试。</li>\n<li><code>browser</code>，需要启动的浏览器。</li>\n</ol>\n","path":"2013-10-09-use-karma-to-test-seajs-module.json","year":"2013","month":"10","day":"09","tags":["JavaScript","node","前端"]},{"link":"/posts/2013/10/08/css-font-face.html","title":"使用fontface","summary":"<p>以前我们需要引入一些自定义字体的时候，都只能在本地使用Photoshop等绘图软件写好这些字之后，做成图片放到页面上去。现在，有了<code>@font-face</code>这个工具，终于可以像本地一样使用自定义的各种各样字体了！</p>\n<p>首先看一下<code>@font-face</code>的语法：</p>\n<pre><code>@font-face {\n  font-family: &#39;Bigelow Rules&#39;;\n  font-style: normal;\n  font-weight: 400;\n  src: local(&#39;Bigelow Rules&#39;), \n       local(&#39;BigelowRules-Regular&#39;), \n       url(path/to/font.woff) format(&#39;woff&#39;);\n}\n</code></pre><ol>\n<li><code>font-family</code>，声明这个字体的名称。</li>\n<li><code>font-style</code>，声明这个字体的样式，可以是<code>normal</code>、<code>italic</code>或者是<code>oblique</code>。</li>\n<li><code>font-weight</code>，声明这个字体的加粗度，可以是<code>normal</code>、<code>bold</code>、<code>bolder</code>、<code>lighter</code>或者是100、200到900之间的数字。</li>\n<li><code>font-stretch</code>，声明这个字体是否横向的拉伸变形。</li>\n<li><code>font-variant</code>，声明这个字体是否大写，可以是<code>normal</code>或者是<code>small-cap</code>。</li>\n<li><code>src</code>，声明这个字体文件的路径，可以是本地路径<code>local</code>（字体文件从浏览器所在的机器上），或者是一个网络路径<code>url</code>。</li>\n</ol>\n<p>其中<code>src</code>要注意的是除了路径之外还有一个<code>format</code>配置，声明这个字体文件的格式。虽然主流的浏览器都支持<code>@font-face</code>，但是支持的字体文件格式是不一样的：</p>\n","path":"2013-10-08-css-font-face.json","year":"2013","month":"10","day":"08","tags":["css"]},{"link":"/posts/2013/10/07/javascript-text-content.html","title":"Secrets of the JavaScript Ninja 读书笔记之 文本内容","summary":"<p>处理文本内容看起来要比处理DOM元素要简单得多，特别是浏览器已经提供了通用的API让我们去处理文本内容。但是，API的行为在不同的浏览器中也有一些小区别需要注意。</p>\n<p>最常用的操作就是获取和设置DOM的文本内容。标准浏览器提供了一个<code>textContent</code>的属性，可以通过这个属性访问DOM对象中的文本内容，包括其子孙元素的文本内容，如：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/8hUR5/embedded/html,js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<p>老版本的IE提供了另外一个属性<code>innerText</code>，跟标准的<code>textContent</code>的行为是一致的，Webkit核心的浏览器也支持<code>innerText</code>。</p>\n<p>注意，当设置了<code>textContent</code>或者<code>innerText</code>之后，DOM对象里面的HTML结构也会被清除哦，只剩下设置的文本内容。这样会导致一些问题。</p>\n<p>第一个问题就是内存泄漏。因为直接设置文本内容后，该DOM对象的子孙元素会被删除，但是这些元素上面可能会有绑定的事件处理程序等数据，这些数据占用的内容有可能不能释放。</p>\n<p>还有一个问题就是各种浏览器对于空白的处理都不一致，这样导致直接使用浏览器提供的操作文本内容的属性不能产生一致的效果。</p>\n<p>所以我们需要额外地编写一些代码以提供跨浏览器表现一致的API。</p>\n<h3 id=\"-\">设置文本内容</h3>\n<hr>\n<p>由于要避免子孙元素的事件处理程序等数据的内存泄漏，需要分成两个步骤去设置文本内容：</p>\n<ol>\n<li>删掉该元素所有子孙DOM对象，清除所有附加的数据。</li>\n</ol>\n","path":"2013-10-07-javascript-text-content.json","year":"2013","month":"10","day":"07","tags":["JavaScript"]},{"link":"/posts/2013/10/06/javascript-remove-elements.html","title":"Secrets of the JavaScript Ninja 读书笔记之 删除DOM","summary":"<p>要讨论的最后的操作就是删除了。DOM对象已经提供了<code>removeChild</code>，让我们能方便地删除元素。但是，在删除元素之前，还要做一些清理工作。通常分成两个步骤。</p>\n<p>第一个步骤就是把该元素上绑定的事件处理程序都删除掉。这个步骤十分重要，因为在老的IE上如果只把DOM对象删除，而事件处理程序没有被正确删除，会发生循环引用，导致内存不能正确回收。所以jQuery才不直接把事件处理程序绑定到元素上，而是使用一个唯一的key关联DOM对象及其事件处理程序等附加数据。所以，使用jQuery绑定的事件处理程序的删除非常方便，只需要把对应key的所有事件处理程序一并删除即可。</p>\n<p>第二个步骤就是把我们自定义在DOM上的特性删除掉。同上，在jQuery中，只要把该元素对应key值的所有数据都删除即可。</p>\n<p>还需要注意的是，这两个步骤必须在该元素的所有子元素上都执行一遍才行。以下是jQuery的一段代码示例：</p>\n<pre><code>function remove() {\n  jQuery(&quot;*&quot;, this).add([this]).each(function () {  \n    jQuery.event.remove(this);                   \n    jQuery.removeData(this);                 \n  });\n  if (this.parentNode)               \n    this.parentNode.removeChild(this);\n}\n</code></pre><p>先取出元素中的所有子孙元素，然后加上该元素本身，执行以上两个步骤。最后调用<code>removeChild</code>去删除DOM对象。</p>\n<p>在IE中，除非页面跳转或者刷新，单纯删除一个DOM对象，内存可能不会回收。这意味这那些单页面应用（通常在一个页面会停留很久），随着使用时间的增大，在IE中消耗的内存会比较多。</p>\n<p>针对IE的内存占用，有一个解决方案，就是把<code>outerHTML</code>属性置成空字符串。这会触发IE进行垃圾回收，虽然内存也不会被完全回收，但是比单纯调用<code>removeChild</code>的效果要好：</p>\n","path":"2013-10-06-javascript-remove-elements.json","year":"2013","month":"10","day":"06","tags":["JavaScript"]},{"link":"/posts/2013/10/05/javascript-clone-elements.html","title":"Secrets of the JavaScript Ninja 读书笔记之 复制DOM","summary":"<p>复制一个DOM对象，只需要直接调用其<code>cloneNode</code>方法即可。但是，现实永远是那么的骨感，古老版本的IE又有一些问题，为了支持它们，我们又要写出一些额外丑陋的代码去封装这些差异。</p>\n<p>首先，它会把DOM对象的事件处理程序复制到新元素中，例如：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/KaY7s/embedded/js,html,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<p>在Chrome等标准浏览器中，单击克隆出来的<code>div</code>是不会触发事件处理程序的。但是在IE6中，单击克隆出来的<code>div</code>则触发了事件处理程序。</p>\n<p>避免这个问题的最简单的方法就是删除克隆元素的事件处理程序。悲剧的是，在IE上，如果删除了克隆元素的事件处理程序，连原来元素上面的处理程序也会被删除！（注，这是书中所写的，在IE6、7上测试是不会删除原来元素上的事件处理程序的。）</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/HRwHE/2/embedded/js,html,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<p>最后的解决方案只能是，先调用<code>cloneNode</code>克隆出一个DOM对象，然后把它放入到一个容器中，再读出其<code>innerHTML</code>的值，最后把该值转成新的DOM对象。这个时候，IE又来了。有一些特性的值，例如书中提到的<code>name</code>，在<code>innerHTML</code>中是不正确的，哎！而且这个方案不能用于XML DOM，因为XML的DOM对象是没有<code>innerHTML</code>这个属性的。由于XML DOM中极少存在事件处理程序这一事物，所以XML DOM的复制可以直接使用<code>cloneNode</code>即可。</p>\n<p>所以，需要为上述的方案进行优化，先区分是XML DOM还是HTML DOM，为HTML DOM作特殊处理。当所有步骤都结束之后，我们还需要在克隆出来的DOM对象中为重新那些丢失了的特性重新赋值。</p>\n<p>由于jQuery不是直接把事件处理程序绑定到元素中，所以它做了一个非常有意思的事情：</p>\n<pre><code>var clone = ret.find(&quot;*&quot;).andSelf().each(function () {\n  if (this[ expando ] !== undefined)\n    this[ expando ] = null;\n});\n</code></pre>","path":"2013-10-05-javascript-clone-elements.json","year":"2013","month":"10","day":"05","tags":["JavaScript"]},{"link":"/posts/2013/10/04/javascript-inject-html-to-dom-3.html","title":"Secrets of the JavaScript Ninja 读书笔记之 执行内联脚本","summary":"<p>执行HTML字符串中的内联脚本也是一个非常常见的需求，特别是服务器返回的HTML字符串，其中包括一些有关于这段HTML字符串的行为，需要内联在这些HTML字符串中一并传到前端。执行这些内联的脚本大概可以分成两个步骤。</p>\n<h3 id=\"-\">收集内联脚本</h3>\n<hr>\n<p>无论是直接内联的脚本，还是外部引入的脚本，都是用<code>script</code>标签的形式引入到HTML中。所以，假设现在已经从HTML字符串中生成了一个DOM的集合<code>ret</code>，从该集合收集内联脚本可以分成以下几个步骤：</p>\n<ol>\n<li>a遍历这个集合。</li>\n<li>a如果是<code>script</code>，而且<code>type=&quot;text/javascript&quot;</code>，则认为这个是内联脚本，放入到结果集中。</li>\n<li>a如果是普通的DOM，则调用该DOM对象的<code>getElementsByTagName</code>就可以获取到这个对象中的<code>script</code>标签。</li>\n</ol>\n<p>当收集完所有内联的脚本之后，并且DOM已经被插入到文档中，就可以执行这些内联的脚本了。</p>\n<h3 id=\"-\">执行内联脚本</h3>\n<hr>\n<p>这些内联的脚本要在全局中执行，即所有在最外边定义的变量和方法都是全局的。这里使用动态插入<code>script</code>的方式来执行这些代码：</p>\n<pre><code>function globalEval(data) {\n  data = data.replace(/^\\s+|\\s+$/g, &quot;&quot;);\n  if (data) {\n    var head = document.getElementsByTagName(&quot;head&quot;)[0] ||\n</code></pre>","path":"2013-10-04-javascript-inject-html-to-dom-3.json","year":"2013","month":"10","day":"04","tags":["JavaScript"]},{"link":"/posts/2013/10/03/javascript-inject-html-to-dom-2.html","title":"Secrets of the JavaScript Ninja 读书笔记之 插入DOM（二）","summary":"<p>昨天讨论如何把HTML字符串转成DOM，今天就要把生成的DOM插入到文档中去。这里使用DOM fragments去保证插入操作的最小化。DOM fragments可以作为容器存放多个DOM元素，而又不影响页面的显示。当操作完成之后再把fragments里面的DOM一把插入到文档中，这样浏览器就只需要渲染一次。如果不使用这种方式，每插入一个DOM都会渲染一次，这样效率比较低。</p>\n<p>有些时候我们需要在文档中的多个位置插入生成的DOM，所以如果位置是大于一的时候，我们需要使用<code>cloneNode</code>，去复制fragments里面的内容，然后插入到多个位置中。</p>\n<p>首先，在获取DOM的方法中加入第三个参数<code>fragments</code>，如果有这个参数就把生成的DOM塞到这个fragments里面：</p>\n<pre><code>if (fragment) {\n  while (div.firstChild) {\n    fragment.appendChild(div.firstChild);\n  }\n}\n</code></pre><p>这样，我们可以通过<code>fragments</code>的引用获得里面的DOM。然后插入的动作就变成在特定的位置插入这个<code>fragments</code>：</p>\n<pre><code>function insert(elems, args, callback) {\n  if (elems.length) {\n    var doc = elems[0].ownerDocument || elems[0],\n        fragment = doc.createDocumentFragment(),\n        scripts = getNodes(args, doc, fragment),\n        first = fragment.firstChild;\n    if (first) {\n      for (var i = 0; elems[i]; i++) {\n</code></pre>","path":"2013-10-03-javascript-inject-html-to-dom-2.json","year":"2013","month":"10","day":"03","tags":["JavaScript"]},{"link":"/posts/2013/10/02/javascript-inject-html-to-dom.html","title":"Secrets of the JavaScript Ninja 读书笔记之 插入DOM（一）","summary":"<p>DOM的插入操作应该是最日常的行为了。我们会插入DOM来显示提示信息、把服务器返回的数据转成HTML字符串再插入到文档中显示出来等。一般来说，插入DOM可以按照以下几个步骤：</p>\n<ol>\n<li>把合法的HTML或者XML字符串转成DOM。</li>\n<li>把生成的DOM插入到文档中。</li>\n<li>执行字符串中内联的脚本。</li>\n</ol>\n<p>今天先来看步骤一，把字符串转成DOM。这里使用了DOM元素中的<code>innerHTML</code>属性。步骤是：</p>\n<h3 id=\"-html-\">确保传入的字符串是合法的HTML字符串</h3>\n<hr>\n<p>首先是要兼容XML的自关闭的标签。在HTML里面，也有一些自关闭的标签，例如<code>img</code>、<code>br</code>等。但是，像<code>div</code>这种标签如果写成自关闭的形式，HTML解析器没有办法解析。所以，我们要把传入字符串中的自关闭标签，而在HTML里面又不是自关闭的这些标签转一下形式，例如：</p>\n<pre><code>$(&quot;&lt;div /&gt;&quot;); // $(&quot;&lt;div&gt;&lt;/div&gt;&quot;);\n</code></pre><h3 id=\"-\">根据浏览器的规则修改传入的字符串</h3>\n<hr>\n<p>有一些标签必须是某个标签的自标签，例如<code>option</code>一定要在<code>select</code>里面。如果发现传入字符串中的第一个标签有这些特殊的规则，则需要修改传入的HTML字符串，为其加上必须的父元素标签。下面是除了<code>option</code>之外有一些特殊父元素要求的标签：</p>\n<ol>\n<li><code>legend</code>必须在<code>fieldset</code>中。</li>\n<li><code>thead</code>、<code>tbody</code>、<code>tfoot</code>、<code>colgroup</code>、<code>caption</code>必须在<code>table</code>中。</li>\n</ol>\n","path":"2013-10-02-javascript-inject-html-to-dom.json","year":"2013","month":"10","day":"02","tags":["JavaScript"]},{"link":"/posts/2013/10/01/javascript-document-ready-event.html","title":"Secrets of the JavaScript Ninja 读书笔记之 document的ready事件","summary":"<p>在没有jQuery之前，我们为了保证代码运行时文档已经加载完全，使用<code>window.onload</code>来执行我们的代码。但是，这个事件有一个十分坑爹的地方：</p>\n<blockquote>\n<p>The load event fires at the end of the document loading process. At this point, all of the objects in the document are in the DOM, and all the images and sub-frames have finished loading.</p>\n</blockquote>\n<p>要所有图片等外部资源全部加载完成之后才会触发<code>window.onload</code>。其实我们是不需要等到外部资源加载完毕的，只要DOM树构造完全即可。所以，在jQuery之后，通常会这么写：</p>\n<pre><code>$(function () { ... });\n</code></pre><p>这种是<code>$(document).ready(function () { ... })</code>的缩写，其中使用的就是<code>document</code>的<code>DOMContentLoaded</code>事件。在DOM树构造完成，已经可以操作的时候这个事件就会触发。标准的浏览器已经支持直接使用<code>addEventListener</code>来绑定事件处理程序。但是，IE9之前的IE是不支持这个事件的，所以必须要编写一些代码在IE上模拟这个事件。</p>\n<p>可以通过两个途径来模拟。第一个是比较腻害的，它会把页面滚动到最左方，如果抛出异常，则说明文档没有加载完成，然后继续滚动直到没有抛出异常为止，这个时刻就十分靠近标准中的<code>DOMContentLoaded</code>事件触发的时刻。</p>\n<p>第二个是使用IE中特有的<code>onreadystatechange</code>，来近似模拟模拟标准的实现。当<code>document.readystate</code>为<code>complete</code>的时候说明文档已经准备好了。虽然这个时刻一般会比标准的要晚，可是一定早于<code>window.onload</code>，所以可以作为<code>doScroll</code>的一个备用方案。</p>\n<p>写了一些测试代码，测试以上的几种方法的触发顺序：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/3ZHWX/4/embedded/js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<p>可以看到标准浏览器是<code>DOMContentLoaded</code>先触发，等图片加载完成后<code>onload</code>才触发。在IE6上是<code>doScroll</code>最先触发，<code>onreadystatechange</code>为<code>complete</code>虽然比<code>onload</code>要早，但是也早不了多少，所以在IE6上应该是<code>doScroll</code>最接近<code>DOMContentLoaded</code>。</p>\n","path":"2013-10-01-javascript-document-ready-event.json","year":"2013","month":"10","day":"01","tags":["JavaScript"]},{"link":"/posts/2013/09/30/about-yaml.html","title":"简述YAML","summary":"<p>这个博客是使用Jekyll在Github上搭建的。而Jekyll使用了YAML作为其配置文件的格式。什么是YAML？它跟XML和JSON有什么不同？今天来简单介绍一下。</p>\n<p>YAML，有一个有意思的递归命名：</p>\n<pre><code>YAML isn&#39;t A Markup Language.\n</code></pre><p>这句话的意思是，YAML不是一个标记语言，它着重于数据而不是存储数据的格式。以下是Jekyll配置文件<code>_config.yml</code>的一个例子：</p>\n<pre><code>permalink: /:categories/:year/:month/:day/:title \nexclude: [&quot;.rvmrc&quot;, &quot;.rbenv-version&quot;, &quot;README.md&quot;, &quot;Rakefile&quot;, &quot;changelog.md&quot;]\npygments: true\nbaseurl: \n</code></pre><p>是不是非常简单，而且可读性非常强。跟XML和JSON一样，YAML也需要表示数组（Array）和对象（Object）两种形式。在YAML中的语法大概是这样的：</p>\n<p>数组使用<code>-</code>去标识每一个元素，例如：</p>\n<pre><code>- Mark McGwire\n- Sammy Sosa\n- Ken Griffey\n</code></pre><p>对象使用<code>:</code>去划分键和值，例如：</p>\n","path":"2013-09-30-about-yaml.json","year":"2013","month":"09","day":"30","tags":["前端"]},{"link":"/posts/2013/09/29/javascript-pagination.html","title":"一个用JavaScript写的分页器算法","summary":"<p>今天简单实现了一个分页器组件。感觉要用点脑子的是如何去显示页数十分大的分页器。记得以前有各种规范，规定一个分页器最多能显示多少个按钮，其他的用<code>...</code>来替代，例如：</p>\n<pre><code>1 ... 10 11 12 13 14 ... 100\n</code></pre><p>而且还要选中的在显示出来的按钮的中间（例如上例选中的应该是12）。</p>\n<p>想了好久，写了这么一个算法：</p>\n<ol>\n<li>首先不考虑边界，先计算如果选中的按钮要出现在中间，开始和结束的索引是多少。</li>\n<li>如果计算出来的索引不合法，例如小于零或者大于最大页数，则在保证显示页码个数的前提下重新计算索引。</li>\n<li>最后计算出正确的开始和结束的索引，还要判断页码是否连续，是否需要加入<code>...</code>。</li>\n<li>注意加上开始和结束的两个页码。</li>\n<li>返回计算后的所有页码信息。</li>\n</ol>\n<p>这个算法接受三个参数：</p>\n<ol>\n<li><code>current</code>，当前页码，计算出来的页码尽可能将这个页码放到中间。</li>\n<li><code>length</code>，页码的长度，总共有多少个页码。</li>\n<li><code>displayLength</code>，要显示多少个页码，包括固定的第一个和最后一个。</li>\n</ol>\n<p>例子参考这里：</p>\n","path":"2013-09-29-javascript-pagination.json","year":"2013","month":"09","day":"29","tags":["JavaScript"]},{"link":"/posts/2013/09/28/javascript-bubbling-and-delegating.html","title":"Secrets of the JavaScript Ninja 读书笔记之 冒泡与代理","summary":"<p>通过事件冒泡机制，我们可以把特定元素上的事件处理程序代理到其祖先元素上面。这样不仅可以统一在祖先元素上处理事件绑定，还能实现动态插入的元素的“自动绑定事件”，例如<code>jQuery.fn.on</code>等。</p>\n<h3 id=\"-\">把事件代理到祖先元素</h3>\n<hr>\n<p>事件代理的其中一个比较有用的场景就是绑定子孙元素的事件处理程序。如果子孙元素的个数非常多，在每一个子孙元素上绑定会生成很多个一模一样的事件处理程序，浪费内存。如果把事件绑定到祖先元素上，根据<code>event.target</code>来判断是哪个子孙元素触发了这个事件，则只绑定了一个事件处理程序而逻辑也能保持一致，例如：</p>\n<pre><code>var table = document.getElementById(&quot;someTable&quot;);\naddEvent(table, &quot;click&quot;, function (event) {\n  if (event.target.tagName.toLowerCase() == &#39;td&#39;) {\n    event.target.style.backgroundColor = &#39;yellow&#39;;\n});\n</code></pre><p>浏览器的事件冒泡机制保证了以上的代码是可行的。所以要注意，代理只能代理到元素的祖先元素上，而且要保证事件能够顺利冒泡到该祖先元素。</p>\n<h3 id=\"-\">处理浏览器差异</h3>\n<hr>\n<p>有四个特殊的事件，<code>submit</code>、<code>change</code>、<code>focus</code>、<code>blur</code>，它们的事件冒的实现在不同的浏览器中有一些差异。简单来说，在W3规范中，<code>submit</code>和<code>change</code>是可以冒泡的，但是低版本的IE浏览器这两个事件是不能冒泡的；而<code>focus</code>和<code>blur</code>则都不支持冒泡，但是为了能实现事件代理，我们又需要它们能冒泡。</p>\n<p><strong>检测是否支持特定事件冒泡</strong></p>\n","path":"2013-09-28-javascript-bubbling-and-delegating.json","year":"2013","month":"09","day":"28","tags":["JavaScript"]},{"link":"/posts/2013/09/27/css-display-inline-block.html","title":"消除display: inline-block引起的元素之间的缝隙","summary":"<p>记得以前在看bootstrap的例子的时候，发现它的按钮之间都是有空隙的。检查元素的样式，发现并没有任何<code>margin</code>被设置了，那为什么会出现空隙呢？</p>\n<p>先来看看<code>display: inline-block</code>干了些什么。</p>\n<blockquote>\n<p>The element generates a block element box that will be flowed with surrounding content as if it were a single inline box (behaving much like a replaced element would).</p>\n</blockquote>\n<p>简单地说就是一个行级的块元素，即像行内元素一样排版，但又可以像块元素一样设置元素的大小。我们可以尝试用<code>inline-block</code>去模拟一个浮动的效果：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/e6EQ9/embedded/result,html,css/\" frameborder=\"0\"> </iframe>\n\n<p>惊讶地发现，元素之间竟然出现了缝隙！查看代码并没有任何<code>margin</code>被设置了，跟bootstrap中的情况一样。其实非常简单，就是元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据<code>white-space</code>的处理方式（默认是<code>normal</code>，合并多余空白），原来HTML代码中的回车换行被转成一个空白符，所以元素之间就出现了空隙。</p>\n<p>有时候加入这些空隙是好事，例如并排显示多个按钮，按钮之间留有一定空隙是比较好看的。但是，有时候为了完美地实现设计搞，元素之间的空隙都要精确限制。由于这个空隙是一个空白符，占用的空间跟父元素的<code>font-size</code>有之间关系，所以这个空隙的大小是不可控的。这时候，要先消除这些空隙，再根据设计搞设置精确的<code>margin</code>。</p>\n<p>上网查了一下，最有效的办法就是在父元素中设置<code>font-size: 0</code>，然后在子元素上重置正确的<code>font-size</code>：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/e6EQ9/1/embedded/result,html,css/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<p>又到了我们可爱的IE出场的时间了。很遗憾，虽然IE从5.5就开始支持<code>display: inline-block</code>，但是它的实现跟标准实现的表现是不一致的。我们需要以下的代码让IE的表现跟标准趋于一致：</p>\n<pre><code>display:inline-block; /* 现代浏览器 +IE6、7 inline 元素 */\n*display:inline; /* IE6、7 block 元素 */\n</code></pre>","path":"2013-09-27-css-display-inline-block.json","year":"2013","month":"09","day":"27","tags":["css"]},{"link":"/posts/2013/09/26/jquery-ajax-short-cut.html","title":"jQuery扫盲之Ajax常用方法","summary":"<p>由于<code>jQuery.ajax</code>参数配置太多，日常应该也用不到所有参数配置，所以jQuery声明了一些比较符合日常使用场景的方法，例如<code>jQuery.get</code>和<code>jQuery.post</code>等，让我们方便地发送Ajax请求。</p>\n<h3 id=\"jquery-get\">jQuery.get</h3>\n<hr>\n<blockquote>\n<p>Load data from the server using a HTTP GET request.</p>\n</blockquote>\n<p>这个方法封装了使用GET方法发送Ajax请求，接受四个参数：</p>\n<ol>\n<li><code>url</code>，发送请求的URL。</li>\n<li><code>data</code>，可选，发送的数据。由于使用的是GET方法，所以数据默认是使用<code>jQuery.params</code>序列化之后的字符串。</li>\n<li><code>success</code>，可选，请求成功后的回调，跟<code>ajaxSetting</code>的一致。</li>\n<li><code>dataType</code>，可选，指定返回数据的数据类型。</li>\n</ol>\n<p>由于没有设置<code>ajaxSetting.error</code>，请求失败的时候只能通过Promise接口或者<code>jQuery.document.ajaxError</code>来处理错误。</p>\n<p>这个方法等同于：</p>\n<pre><code>$.ajax({\n  url: url,\n  data: data,\n  success: success,\n</code></pre>","path":"2013-09-26-jquery-ajax-short-cut.json","year":"2013","month":"09","day":"26","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/09/25/jquery-ajax-setup-ajax-transport.html","title":"jQuery扫盲之ajaxSetup和ajaxTransport","summary":"<p>Ajax系列的最后一篇文档翻译。今天讨论的是Ajax的全局配置<code>jQuery.ajaxSetup</code>和配置真正传输对象<code>jQuery.ajaxTransport</code>。</p>\n<h3 id=\"jquery-ajaxsetup\">jQuery.ajaxSetup</h3>\n<hr>\n<blockquote>\n<p>Set default values for future Ajax requests. Its use is not recommended.</p>\n</blockquote>\n<p>这个方法十分简单，就是配置Ajax默认的参数。这个方法接受一个参数，跟<code>jQuery.ajax</code>的配置参数一模一样。调用<code>jQuery.ajax</code>的时候，会合并传入的参数和默认的参数，传入的参数优先级较高。其他所有的快捷方式，例如<code>jQuery.get</code>，都会使用这些默认的参数。</p>\n<p>jQuery文档强烈建议我们不要使用这个方法配置默认参数，以防发生难以预料的错误，例如改变了一个快捷方式的默认行为。</p>\n<h3 id=\"jquery-ajaxtransport\">jQuery.ajaxTransport</h3>\n<hr>\n<blockquote>\n<p>Creates an object that handles the actual transmission of Ajax data.</p>\n</blockquote>\n<p>这个方法比较有趣，可以更改Ajax数据真正的传输方式。我们知道，默认的Ajax是使用XMLHttpRequest去把数据发送到服务器。jQuery提供了这个方法，供我们改变数据传输的方式。</p>\n<p>这个方法接受两个参数：</p>\n<ol>\n<li><code>dataType</code>，声明该传输对象只对特定的数据类型生效。</li>\n<li><code>handler</code>，一个回调函数，接受三个参数，与<code>jQuery.ajaxPrefilter</code>一致。该回调函数返回的对象就是作为数据的传输对象。</li>\n</ol>\n","path":"2013-09-25-jquery-ajax-setup-ajax-transport.json","year":"2013","month":"09","day":"25","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/09/24/javascript-for-in-order.html","title":"再谈for-in循环的顺序","summary":"<p>今天终于重现了两年前出现过的<code>for...in</code>循环的顺序问题，多谢永胜哥给出的例子。原来是当键值是整数的时候，使用<code>for...in</code>循环去遍历一个对象，不同浏览器的顺序是不一样的。</p>\n<p>ECMA-262标准中有这么一句说明：</p>\n<blockquote>\n<p>The mechanics and order of enumerating the properties (step 6.a in the first algorithm, step 7.a in the second) is not specified.</p>\n</blockquote>\n<p>关于<code>for...in</code>的具体顺序在最新的标准中是没有说明的。这也意味着每一个浏览器都可以有其特定的实现。之前的文章也强调过，<strong>不要依赖<code>for...in</code>遍历一个对象的顺序</strong>。为了彻底搞清楚不同浏览器的实现，蛋疼的我写了个测试，代码<a href=\"http://jsfiddle.net/k5DBh/18/\">参考这里</a>。</p>\n<p>比较有规律的IE6的实现，全部都跟定义时的顺序一致。IE7、8、9跟Chrome的最新版本的实现是一样的：</p>\n<ol>\n<li>a把key中是整数的先抽取出来。注意一定要是整数，像<code>3a</code>、<code>1.1</code>等不在范围之内哦。</li>\n<li>a抽取出来的按数字大小正序排列，放到最前面。</li>\n<li>a其他key则按照定义的顺序放到整数key的后面。</li>\n</ol>\n<p>有趣的是最新版本的FireFox。当数字比较小的时候，跟Chrome的实现是一致的。当数字比较大的时候，跟IE6的表现是一致的。为了揭示问题的真相，我又蛋疼地写了一段代码，去测试FireFox的边界值，<a href=\"http://jsfiddle.net/9pYL4/4/\">参考这里</a>。</p>\n<p>得出的结论是FireFox把超过1000的数字排除在优先范围之外。所以当key值小于1000的时候是跟Chrome的行为一致，大于的时候跟IE6的行为一致。</p>\n","path":"2013-09-24-javascript-for-in-order.json","year":"2013","month":"09","day":"24","tags":["JavaScript"]},{"link":"/posts/2013/09/23/jquery-ajax-prefilter.html","title":"jQuery扫盲之jQuery.ajaxPrefilter","summary":"<p>除了<code>jQuery.ajax</code>这个比较底层的接口之外，jQuery还提供了其他的接口供我们去控制Ajax的行为。今天就先讨论一下<code>jQuery.ajaxPrefilter</code>。</p>\n<blockquote>\n<p>Handle custom Ajax options or modify existing options before each request is sent and before they are processed by $.ajax().</p>\n</blockquote>\n<p>在请求被<code>jQuery.ajax</code>处理之前，可以通过这个接口去干涉每一个请求的配置。这个方法接受两个参数：</p>\n<ol>\n<li><code>dataType</code>，可选的，如果提供则需要请求配置中的<code>dataType</code>是否匹配这个参数指定的值。</li>\n<li><code>handler</code>，在<code>jQuery.ajax</code>处理之前经过的过滤器，接受三个参数：<ol>\n<li><code>options</code>，Ajax请求的配置。</li>\n<li><code>originalOptions</code>，调用<code>jQuery.ajax</code>时传入的配置。这个配置是没有<code>ajaxSetting</code>中的默认配置的。</li>\n<li><code>jqXHR</code>，这个请求的jqXHR对象。</li>\n</ol>\n</li>\n</ol>\n<p>通过这个方法，可以做一些有趣的东西，例如jQuery文档中的这个例子：</p>\n<pre><code>var currentRequests = {};\n\n$.ajaxPrefilter(function( options, originalOptions, jqXHR ) {\n  if ( options.abortOnRetry ) {\n    if ( currentRequests[ options.url ] ) {\n      currentRequests[ options.url ].abort();\n    }\n    currentRequests[ options.url ] = jqXHR;\n</code></pre>","path":"2013-09-23-jquery-ajax-prefilter.json","year":"2013","month":"09","day":"23","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/09/22/use-grunt-to-build.html","title":"使用Grunt去构建","summary":"<p>之前已经接触过grunt了，在去年的工作中就已经使用grunt去做一些零星的构建工作，但是没有系统地使用过，而且也是使用原生的node比较多。今天自己使用grunt的构建工具已经差不多编写完成了，在这里写一下，顺便也当作一个不是很正式的文档吧。</p>\n<h3 id=\"-\">准备工作</h3>\n<hr>\n<p>grunt是使用node作为运行环境的，所以先要安装一个node。</p>\n<p>安装grunt-cli和项目脚手架工具：</p>\n<pre><code>npm install -g grunt-cli\nnpm install -g grunt-init\n</code></pre><p>这两个node的模块都要安装到全局里面，方便在任何一个地方调用。</p>\n<p>由于使用了SPM去安装外部依赖，需要安装SPM：</p>\n<pre><code>npm install -g spm\n</code></pre><p>先从仓库里面把必须的文件checkout出来。暂时存了一份在github上，可以通过<code>git clone</code>来checkout，地址是<a href=\"https://github.com/amkit2/amkit2.git\">https://github.com/amkit2/amkit2.git</a>。</p>\n<p>checkout之后，在该目录上面执行命令：</p>\n","path":"2013-09-22-use-grunt-to-build.json","year":"2013","month":"09","day":"22","tags":["前端"]},{"link":"/posts/2013/09/21/javascript-handle-cross-browser-event-2.html","title":"Secrets of the JavaScript Ninja 读书笔记之 跨浏览器处理事件（二）","summary":"<p>虽然使用昨天讨论的东西，已经能写出一个能跨浏览器实现绑定、解绑定事件的接口，但是还有一些小的细节，例如由于使用了一个匿名函数内部调用<code>apply</code>去改变事件处理函数的<code>this</code>，导致需要返回这个匿名函数才能解绑对应的事件处理程序；而且也没有传入处理后的事件对象作为事件处理程序的参数等。</p>\n<p>书中介绍了jQuery绑定事件的一些方式，比起昨天介绍的相关接口的实现要有想法得多。</p>\n<h3 id=\"-\">管理事件处理程序</h3>\n<hr>\n<p>jQuery不直接把用户传入的函数绑定成事件处理函数，而是把这些函数存储在一个对象中，用一个键值跟DOM关联起来。这种做法可以避免低版本的IE由于循环引用而引发的内存泄漏，而且使用统一的存储可以让我们能在事件触发的过程中实现更灵活的控制，例如阻止冒泡、阻止默认行为、阻止本DOM上的其他事件处理程序执行等。</p>\n<h3 id=\"-\">触发事件</h3>\n<hr>\n<p>之前讨论过使用<code>document.createEvent</code>和<code>elem.dispatchEvent</code>来模拟DOM事件，通过代码模拟用户与浏览器的交互行为。而使用jQuery绑定的事件，则不需要使用这些API去手动触发事件。根据事件的类型，可以获取到对应DOM对象上关于这个事件的所有事件处理程序，直接执行它们即可。</p>\n<p>但是还是要注意一个地方，就是还要递归地去寻找父元素，在父元素上触发对应的事件。</p>\n<p>通过jQuery实现的事件机制，我们可以为绑定一个自定义的事件（即不是浏览器的标准事件）。自定义事件可以实现观察者模式，在拆分模块的时候可以通过触发事件、监听时间来解藕这些模块，提高可重用性和可维护性。</p>\n","path":"2013-09-21-javascript-handle-cross-browser-event-2.json","year":"2013","month":"09","day":"21","tags":["JavaScript"]},{"link":"/posts/2013/09/20/javascript-handle-cross-browser-event-1.html","title":"Secrets of the JavaScript Ninja 读书笔记之 跨浏览器处理事件（一）","summary":"<p>处理事件是JavaScript最最最最最最重要的一部分，负责用户与页面的交互逻辑。由于种种历史遗留问题，从绑定事件，到事件对象、处理程序的上下文等，IE跟标准的浏览器不太一样，这需要我们抽象出绑定事件的一般接口，根据不同的浏览器给出不同的实现。</p>\n<h3 id=\"-\">绑定与解绑定事件</h3>\n<hr>\n<p>标准浏览器使用<code>addEventListener</code>和<code>removeEventListener</code>去绑定和解绑定事件，而IE9之前版本的IE使用<code>attachEvent</code>和<code>detachEvent</code>。</p>\n<p>标准的事件处理有捕获和冒泡两个阶段，而IE只支持事件冒泡阶段。还有，标准的事件处理程序中的<code>this</code>是DOM元素，而IE则是<code>window</code>对象。标准的事件处理程序接受一个事件对象作为参数，而IE则是把事件对象存储在一个全局变量（<code>window.event</code>）中。</p>\n<p>为了保持每个浏览器的行为一致，我们需要编写一些代码使得IE也具有跟标准事件绑定一致的行为：</p>\n<ol>\n<li>抽象通用的接口绑定事件。</li>\n<li>抽象通用的接口解绑定事件。</li>\n<li>调用事件处理程序的时候传入事件对象。</li>\n<li>调用事件处理程序的时候保证上下文为DOM本身。</li>\n</ol>\n<p>最简单的实现就是使用特性检测：</p>\n<pre><code>if (document.addEventListener) {\n  // DOM Modal\n} else if (document.attachEvent) {\n  // IE Modal\n</code></pre>","path":"2013-09-20-javascript-handle-cross-browser-event-1.json","year":"2013","month":"09","day":"20","tags":["JavaScript"]},{"link":"/posts/2013/09/19/about-frontend-framework.html","title":"关于框架的一点思考","summary":"<p>由于昨天听了一个非常有意思的培训，觉得对自己作为程序员的价值观有比较大的冲击，今天来分享一下这些与技术关系不大的东西。培训是关于一个PHP框架的反思，也可以算是一个Web框架的反思吧，感觉有很多东西都是共同的。</p>\n<h3 id=\"-\">关于框架</h3>\n<hr>\n<p>框架要实现三个目标：快速开发、快速运行和快速学习。快速开发，就是说使用框架可以提高开发效率，快速构建可使用的应用系统；快速运行就是使用框架后代码的性能会得到提升；快速学习就是框架本身比较简单，学习成本低。</p>\n<p>现在很多框架跟这三个目标是有偏差的，最主要体现在性能和学习成本上。现在的框架，动辄上万行的代码，原来使用一行代码的功能，使用框架后可能成倍地增长，而由于PHP等解释型的语言缺少编译过程（这个方面JavaScript是类似的），多行代码的性能肯定比不上一行代码；而由于上万行的代码，学习成本也会响应地提升，繁多的配置让人却步。</p>\n<p>要构建一个符合以上三个目标的Web框架，首先需要的是简单。只有框架本身足够简单，才能保证运行的效率，才能快速上手。而基于Web应用的模式，与企业应用不同，一般可以简单地归纳成数据存取，就是说每一个业务都是数据存取并展现的一个过程。框架只要着眼于这两点就可以了。</p>\n<p>框架还分成通用型和专用型两种。前者考虑了全世界，例如支持多数据库、国际化、目录结构、配置、HTML生成方式、各个过程的钩子……通用框架就是希望做到世界上任何一个应用都可以用它来开发。这样的出发点就决定了通用框架不可能简单，它要考虑的东西太多了。而对于一个公司来说，通用框架所需要考虑的事情有很多都是用不着的，例如公司只用MySql，不用考虑多数据库；规定了目录结构和配置，所有项目都必须根据这个目录结构和配置来进行开发……这种专用框架，到了外边肯定是行不通的，但是在公司内部绝对是效率最高，而且最简单的一种实现方式。实现以上的三个目标，专用框架要简单地多。</p>\n<p>对于需求的把握也是十分重要的。其中有一个我觉得比较有意思的观点：小众需求的声音才是最大的。当大部分用户使用这个框架觉得没有什么问题的时候，一些小众提出的需求就占了反馈声音中的绝大部分，这使得框架开发者必须关注这些小众需求，但是这些需求在大部分用户那是没有必要的。时刻紧记要为大部分用户服务！</p>\n<p>还有一个比较有意思的观点是：代码能不写就不写，写得少错得少。不仅是框架本身的代码，甚至是使用框架开发的业务层的代码，都要精简。最近经常听到他们在讨论一些框架方法的命名问题，就是在纠结命名的长短，都是基于这个观点出发的吧。而且写得少，功能照样实现，对于程序员来说不也是一件很爽的事情吗？</p>\n<h3 id=\"-\">关于规范</h3>\n<hr>\n<p>这部分的观点与我做了4年程序员的观点有比较大的冲突。在我看来，规范是个好东西，可以统一团队内部的编码风格，提高项目的可维护性等。遵循某些规范，并使用一些手段去检测我们的代码是否符合规范，能够避免一些低级错误。而昨天培训持的是反面的观点，认为规范这个东西，出现的前提是认为程序员“性本惡”。由于害怕程序员出问题，故提出各种规范、各种流程（例如代码检视、领导签字合入等），来限制程序员。用人不疑，疑人不用。把任务交给一个程序员，就要认同这个程序员能在完成这个任务。程序员不需要考虑什么规范、什么流程，认真努力去做就行了。</p>\n","path":"2013-09-19-about-frontend-framework.json","year":"2013","month":"09","day":"19","tags":["前端"]},{"link":"/posts/2013/09/18/javascript-httpxmlrequest.html","title":"XMLHttpRequest对象","summary":"<p>XMLHttpRequest最初是微软设计的，现在已经是W3C的标准了。使用XMLHttpRequest，我们可以不需要重新刷新页面，又可以获得服务端的数据。这样，我们就可以只更新页面的某一个部分，而不影响其他的部分。基本上所有Ajax的应用都在使用XMLHttpRequest（除了老式的某些应用使用<code>iframe</code>）。</p>\n<p>尽管名字含有XML，使用XMLHttpRequest可以获取任何类型的数据，不仅是XML。它也不仅仅支持HTTP协议，例如<code>file</code>、<code>ftp</code>等它也支持。</p>\n<h3 id=\"-\">构造</h3>\n<hr>\n<p>可以通过以下这行代码实例化一个XMLHttpRequest对象（IE6除外）：</p>\n<pre><code>var myRequest = new XMLHttpRequest();\n</code></pre><h3 id=\"-\">实例方法</h3>\n<hr>\n<ol>\n<li><code>abort()</code>，手动终止一个已经发出去的请求。</li>\n<li><code>getAllResponseHeaders()</code>，返回包含所有相应头信息的字符串。</li>\n<li><code>getResponseHeader(header)</code>，返回<code>header</code>指定名称的相应头信息的字符串。</li>\n<li><code>open(method, url, async, user, password)</code>，初始化一个请求。<strong>注意，如果重复调用<code>open</code>则第二次调用视为是调用了<code>abort</code>，会中止已经发出的请求。例子可以<a href=\"http://jsfiddle.net/C6RNA/\">参考这里</a>。</strong></li>\n<li><code>overrideMimeType(mimeType)</code>，使用<code>mimeType</code>指定的MIME类型覆盖服务端返回的MIME类型。</li>\n<li><code>send(data)</code>，发送该请求。如果请求是异步的，调用这个方法后会立刻返回；否则会一直阻塞直到请求返回。其中<code>data</code>是可选的，可以是各种类型的数据，例如二进制数据、XML文档、字符串或者是表单数据等。<strong>注意，所有事件监听器都必须在调用<code>send</code>之前绑定好，不然就没法触发了。</strong></li>\n<li><code>setRequestHeader(header, value)</code>，设置请求头，其中<code>header</code>为请求头的名字，<code>value</code>为对应请求头的值。</li>\n</ol>\n","path":"2013-09-18-javascript-httpxmlrequest.json","year":"2013","month":"09","day":"18","tags":["JavaScript"]},{"link":"/posts/2013/09/17/jquery-ajax-jqxhr.html","title":"jQuery扫盲之jqXHR对象","summary":"<p>当执行<code>jQuery.ajax</code>的时候会返回一个jQuery封装的XMLHttpRequest对象，简称jqXHR对象。该对象是原生的XMLHttpRequest对象扩展，不仅含有所有原生对象中的属性和方法，jQuery还加入了一些新的属性，例如promise模式的<code>done</code>、<code>fail</code>等方法。还有，jQuery为jsonp等方式获取的脚本模拟了XMLHttpRequest对象，使得所有Ajax的行为趋于一致。</p>\n<p>从1.5之后，jQuery在jqXHR中提供了Promise接口。接口中的方法接受一个或者多个回调函数，当Ajax请求终止的时候会根据请求的状态，例如成功或者失败等，调用不同的回调函数。接口中的方法有：</p>\n<ol>\n<li><code>jqXHR.done</code>，跟<code>ajaxSetting</code>中的<code>success</code>类似，在Ajax请求成功时调用作为参数的回调函数。</li>\n<li><code>jqXHR.fail</code>，跟<code>ajaxSetting</code>中的<code>error</code>类似，在Ajax请求失败时调用作为参数的回调函数。</li>\n<li><code>jqXHR.always</code>，跟<code>ajaxSetting</code>中的<code>complete</code>类似，无论请求成功或者失败都调用作为参数的回调函数。</li>\n<li><code>jqXHR.then</code>，接受两个参数，第一个是成功时的回调函数，同<code>done</code>中的参数；第二个是失败时的回调函数，同<code>fail</code>中的参数。</li>\n</ol>\n<p>回调函数中的<code>this</code>指向的都是调用<code>jQuery.ajax</code>时，指定的<code>context</code>。如果没有指定<code>context</code>，则为这次调用的<code>ajaxSetting</code>对象。</p>\n<p>由于需要兼容原生的XMLHttpRequest，jqXHR对象中还有很多XMLHttpRequest上的属性，例如<code>readyState</code>、<code>status</code>、<code>responseText</code>等。唯一不同的是<code>onreadystatechange</code>机制不再提供，需要使用<code>jqXHR.done</code>等Promise接口去处理对应的逻辑。</p>\n<p>包含<code>jQuery.ajax</code>的配置还有这几个Promise接口，jQuery允许我们在各种不同的阶段”勾入“我们的代码，这些钩子按以下的顺序执行：</p>\n<ol>\n<li><code>ajaxSetting.beforeSend</code>。</li>\n<li><code>ajaxSetting.error</code>。</li>\n<li><code>ajaxSetting.dafaFilter</code>。</li>\n<li><code>ajaxSetting.success</code>。</li>\n<li><code>jqXHR.done</code>等Promise接口。</li>\n<li><code>ajaxSetting.complete</code>。</li>\n</ol>\n","path":"2013-09-17-jquery-ajax-jqxhr.json","year":"2013","month":"09","day":"17","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/09/16/javascript-document-fragment.html","title":"Document Fragment","summary":"<p>如果我们需要对一些DOM进行操作，而又不想这些操作造成的变化体现在浏览器中，可以创建一个文档片段（Document Fragment）临时把我们要操作的DOM放入其中，待操作完成后再放回原来的位置。</p>\n<h3 id=\"document-fragment\">Document Fragment</h3>\n<hr>\n<blockquote>\n<p>The DocumentFragment interface represents a minimal document object that has no parent. It is used as a light-weight version of Document to store well-formed or potentially non-well-formed fragments of XML.</p>\n</blockquote>\n<p>一个文档片段相当于一个轻量级的文档，可以存放一部分的XML（HTML）DOM。可以通过<code>document.createDocumentFragment</code>来创建一个文档片段。</p>\n<p>其实一个文档片段就是一个小型的文档，可以使用<code>appendChild</code>加入DOM、使用<code>childNodes</code>去获取文档片段中的子元素等。</p>\n<h3 id=\"document-createdocumentfragment\">document.createDocumentFragment</h3>\n<hr>\n<p>上文已经提到了这个方法。这个方法的作用就是创建一个空白的文档片段，所以这个方法不接受任何参数，而返回一个文档片段的DOM。这个DOM不在当前的文档树中。通常会在这个文档片段中进行DOM操作，例如从某个地方使用<code>appendChild</code>把相关的DOM插入到文档片段中，然后对文档片段中的DOM进行修改或者删除，最后把这个文档片段（或者只把它的子元素）插入到当前的文档树中。这时这些DOM操作才真正生效。</p>\n<p>由于这种操作方式不会导致页面的reflow，所以使用文档片段去操作DOM是一种效率比较高的方式，建议使用。</p>\n<h3 id=\"range-createcontextualfragment\">range.createContextualFragment</h3>\n<hr>\n<p>今天看书的时候提到了一种比<code>document.createFragment</code>效率更高的方式，就是<code>range.createContexualFragment</code>，其中<code>range</code>是通过<code>document.createRange</code>创建的对象。</p>\n","path":"2013-09-16-javascript-document-fragment.json","year":"2013","month":"09","day":"16","tags":["JavaScript"]},{"link":"/posts/2013/09/15/javascript-fetch-computed-styles.html","title":"Secrets of the JavaScript Ninja 读书笔记之 获取层叠后的style","summary":"<p>昨天讨论过，简单通过<code>elem.style</code>只能获取到内联在HTML标签的样式值，而不能获取到<code>style</code>标签的样式和<code>link</code>标签的外部样式表的样式。需要获取经过浏览器计算后的元素“真正的”样式，要调用浏览器特定的API。很遗憾，又是IE。</p>\n<h3 id=\"-\">标准</h3>\n<hr>\n<p>这里的标准浏览器是所有现代浏览器加上IE9及其以上的版本。标准的浏览器提供<code>window.getComputedStyle</code>这个API去获取经过层叠计算后的样式。这个方法接受一个参数，就是要计算样式的DOM元素。该方法返回一个接口，通过调用其上面的<code>getPropertyValue</code>去获取特定名称的CSS样式的值，如：</p>\n<pre><code>var computedStyle = window.getComputedStyle(elem);\nvar fontSize = computedStyle.getPropertyValue(&quot;font-size&quot;);\n</code></pre><p>注意哦，<code>getPropertyValue</code>接受的是CSS样式真正的名字，不需要转化成驼峰大小写的形式。</p>\n<h3 id=\"-ie\">老IE</h3>\n<hr>\n<p>在IE9之前的版本，需要通过DOM上面的<code>currentStyle</code>来获取经过层叠后的样式。这个属性跟<code>style</code>属性的使用方式相同，唯一的区别就是前者可以获取到<code>style</code>标签或者外部样式表中的CSS样式的值。</p>\n<p>由于是使用属性，<code>currentStyle</code>上的CSS样式的名字跟<code>style</code>一样，也要使用驼峰大小写的形式。</p>\n<h3 id=\"-\">坑</h3>\n<hr>\n","path":"2013-09-15-javascript-fetch-computed-styles.json","year":"2013","month":"09","day":"15","tags":["JavaScript"]},{"link":"/posts/2013/09/14/javascript-style-attribute-issue.html","title":"Secrets of the JavaScript Ninja 读书笔记之 style的那些事","summary":"<p><code>style</code>算是一个比较麻烦的东西，因为使用<code>getAttribute(&quot;style&quot;)</code>和<code>elem.style</code>这两个返回的结果是不一样的。通常的用法是使用后者，返回一个<code>style</code>对象，通过这个对象操作DOM的各种CSS样式。而通过这个对象访问DOM上的CSS样式，<strong>只能访问到内联的CSS样式</strong>，而通过样式表（<code>style</code>标签、外部CSS样式表）叠加的CSS样式则不能通过这个对象访问。不过还是可以通过一些方式得到“层叠后”的CSS样式。</p>\n<h3 id=\"style-\">style属性的命名</h3>\n<hr>\n<p>很多CSS样式都是使用<code>-</code>来连接多个单词，例如<code>border-width</code>、<code>margin-left</code>等。要访问这些<code>style</code>对象的属性，需要通过以下的代码访问：</p>\n<pre><code>elem.style[&#39;border-width&#39;];\n</code></pre><p>如果使用<code>.</code>来访问属性，例如<code>elem.style.border-width</code>，中间的<code>-</code>会被解析成减号，导致逻辑错误或者是语法错误。需要使用<code>.</code>访问这些CSS样式，需要把这些样式名改成驼峰大小写的形式，例如：</p>\n<pre><code>elem.style.borderWidth;\n</code></pre><p>可以简单使用以下代码去进行转换：</p>\n<pre><code>name = name.replace(/-([a-z])/ig,                   \n  function(all,letter){\n    return letter.toUpperCase();\n  });\n</code></pre><h3 id=\"float\">float</h3>\n<hr>\n","path":"2013-09-14-javascript-style-attribute-issue.json","year":"2013","month":"09","day":"14","tags":["JavaScript"]},{"link":"/posts/2013/09/13/jquery-ajax.html","title":"jQuery扫盲之jQuery.ajax","summary":"<p>继续扫盲，今天是<code>jQuery.ajax</code>方法详解。</p>\n<blockquote>\n<p>Perform an asynchronous HTTP (Ajax) request.</p>\n</blockquote>\n<p>这个方法应该是jQuery有关Ajax的最底层的一个方法。</p>\n<h3 id=\"-\">用法</h3>\n<hr>\n<p>这个方法有两种调用形式：</p>\n<ol>\n<li>接受两个参数，第一个是<code>url</code>，第二个是Ajax的配置。</li>\n<li>接受一个参数，就是Ajax的配置。</li>\n</ol>\n<p>其实第一种调用方式就是方便发出请求，只需要传递URL作为参数即可。注意哦，所有配置都是可选的，可以通过<code>$.ajaxSetup</code>来设置默认配置。</p>\n<h3 id=\"-\">配置</h3>\n<hr>\n<ol>\n<li><code>accepts</code>，用来设置接受那些MIME类型的数据，例如<code>accepts: { xml: &quot;text/xml&quot; }</code>。默认值与<code>dataType</code>配置有关。</li>\n<li><code>async</code>，声明这个Ajax请求是否异步。默认值是<code>true</code>，表示请求是异步的。可以通过<code>async: false</code>来显式声明这个请求是同步的。使用跨域的请求或者是jsonp的时候，不支持同步请求。<strong>注意，在1.8之后，同步的请求只能通过<code>success</code>等回调进行处理，而不能使用jqXHR的promise。</strong></li>\n<li><code>beforeSend</code>，配置一个回调函数，在Ajax请求发出之前调用。接受两个参数，第一个是jqXHR对象，第二个是这次Ajax请求的配置。如果在回调函数中返回<code>false</code>，则这个Ajax请求会被取消。</li>\n</ol>\n","path":"2013-09-13-jquery-ajax.json","year":"2013","month":"09","day":"13","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/09/12/jquery-ajax-help-function.html","title":"jQuery扫盲之Ajax工具函数","summary":"<p>jQuery为了方便用户使用Ajax，提供了几个工具函数，提供一些有关参数传递与序列化的功能。</p>\n<h3 id=\"jquery-param\">jQuery.param</h3>\n<hr>\n<blockquote>\n<p>Create a serialized representation of an array or object, suitable for use in a URL query string or Ajax request.</p>\n</blockquote>\n<p>这个方法可以提供数组或者对象的一个序列化之后的字符串，可以用作URL上的<code>query</code>，也可以作为Ajax的<code>data</code>传递。该方法接受两个参数：</p>\n<ol>\n<li><code>obj</code>，需要序列化的数组或者对象。</li>\n<li><code>traditional</code>，可选的标志位，是否使用“浅层次”的序列化。默认是<code>false</code>，会递归地序列化对象的属性或者数组的元素。</li>\n</ol>\n<p>返回一个这个数组或者对象的一个序列化之后的字符串。</p>\n<p>在jQuery 1.4及之前的版本，可以通过<code>jQuery.ajaxSetting.traditional = true</code>去设置全局的Ajax都使用浅层次的序列化。</p>\n<p>在jQuery 1.8及之后的版本，这个设置对<code>jQuery.param</code>已经没有效果了。这时候要使用浅层次的序列化只能通过调用<code>jQuery.param</code>的时候传入第二个参数<code>true</code>来显式声明这次序列化是使用浅层次的序列化。</p>\n<p>注意，如果传入的是数组，里面的元素需要是以下这种格式的才可以（是调用<code>jQuery.fn.serializeArray</code>返回的数组元素的格式）：</p>\n<pre><code>[{name:&quot;first&quot;,value:&quot;Rick&quot;},\n {name:&quot;last&quot;,value:&quot;Astley&quot;},\n</code></pre>","path":"2013-09-12-jquery-ajax-help-function.json","year":"2013","month":"09","day":"12","tags":["jQuery","JavaScript"]},{"link":"/posts/2013/09/11/html5-history-api.html","title":"HTML5 history API","summary":"<p>今天偶然发现有一个需求，单击某个链接的时候，浏览器显示的URL要变化，而页面又不要跳转。这个时候可以使用HTML5的history API。</p>\n<h3 id=\"-html-history-api\">老的HTML history API</h3>\n<hr>\n<p>在HTML4中，浏览器已经提供了一些关于历史记录的API，都在<code>window.history</code>里面：</p>\n<ol>\n<li><code>back</code>，相当于单击浏览器的后退按钮。</li>\n<li><code>forward</code>，相当于单击浏览器的前进按钮。</li>\n<li><code>go</code>，前进或者后退若干个历史记录。接受一个整数作为参数，正数为前进，负数为后退，<code>0</code>为刷新本页面。</li>\n</ol>\n<h3 id=\"-html-hisotry-api\">新的HTML hisotry API</h3>\n<hr>\n<p>HTML5提供了新的两个API，为了使一些SPA应用也能使用前进后退的功能。</p>\n<p>第一个是<code>window.history.pushState</code>，往历史记录栈中压入一个记录。第二个是<code>window.history.replaceState</code>，替换掉历史记录栈中的栈顶的记录。这两个方法都接受三个参数：</p>\n<ol>\n<li><code>stateObject</code>，关于这个历史记录的数据。当<code>popstate</code>触发的时候，对应记录的这个数据会作为事件对象的<code>state</code>属性回传给事件处理程序。<strong>注意，这个对象有大小限制，当对象序列化后的大小超过这个限制的时候某些浏览器会抛出异常。</strong></li>\n<li><code>title</code>，理论上应该是对应历史记录中浏览器应该显示的标题，但是绝大部分浏览器没有实现这个功能，而这个参数也会被忽略。</li>\n<li><code>URL</code>，浏览器显示的地址。虽然不会跳转到该地址上面，但是应该保证这个地址是可以访问的，因为当用户刷新这个页面的时候应该能正常到达当前这个状态。</li>\n</ol>\n","path":"2013-09-11-html5-history-api.json","year":"2013","month":"09","day":"11","tags":["html5","JavaScript"]},{"link":"/posts/2013/09/10/jquery-ajax-event.html","title":"jQuery扫盲之全局Ajax事件","summary":"<p>当今天没啥东西写的时候，会强迫自己看看一些常用的，但是又不完全了解的东西，例如各种文档、各种API参考等。扫盲系列其实就是去读这些API的文档，去发掘一些我们不知道的用法和要注意的事情。</p>\n<p>今天讨论的是jQuery中有关Ajax的全局事件，这些事件有时候可以使我们的代码更加简洁，表现更加一致。</p>\n<p>当<code>jQuery.ajaxSetup()</code>返回的<code>global</code>属性是<code>true</code>的时候（这个也是默认值），全局的Ajax事件才能生效。还有，调用<code>jQuery.ajax</code>的时候如果选项中的<code>global</code>为<code>false</code>，这次请求也不会触发全局的Ajax事件。注意，<strong>跨域的Ajax或者是jsonp是无论如何都不会触发这些全局的Ajax事件的</strong>。</p>\n<p>强烈建议在<code>document</code>上绑定这些事件（在jQuery 1.8往后的版本只能绑定在<code>document</code>上了）。这些全局Ajax事件的绑定方法都只接受一个参数，就是要绑定的事件处理程序。</p>\n<h3 id=\"ajaxcomplete\">ajaxComplete</h3>\n<p>处理程序接受三个参数，事件对象、XMLHttpRequest对象、调用这次Ajax的<code>ajaxOptions</code>。每一个Ajax请求完成（无论成功或者失败）时，都会调用所有事件处理程序。</p>\n<h3 id=\"ajaxerror\">ajaxError</h3>\n<p>处理程序接受四个参数，事件对象、jQuery封装的XHR对象、调用这次Ajax的<code>ajaxOptions</code>、还有抛出的错误，例如服务器错误（5xx）、路径错误（4xx）或者是当数据类型是<code>json</code>或者其他特定类型时解析错误（json语法错误）等。错误以字符串的形式返回，例如<code>Not found</code>、<code>Internal Server Error</code>等。每一次Ajax请求以失败告终的时候，都会调用所有事件处理程序。</p>\n<h3 id=\"ajaxsend\">ajaxSend</h3>\n<p>处理程序接受三个参数，与<code>ajaxError</code>的前三个参数一致。每一次发出一个Ajax请求时，都会嗲用所有事件处理程序。</p>\n<h3 id=\"ajaxstart\">ajaxStart</h3>\n","path":"2013-09-10-jquery-ajax-event.json","year":"2013","month":"09","day":"10","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/09/09/css-expression.html","title":"CSS表达式","summary":"<p>对于一些呈现型的网站（例如门户、资讯类的），在国内还是必须照顾一大部分使用IE6的用户。这样导致我们的代码为了兼容很多IE6，需要在IE6上模拟一些高级浏览器的功能，例如<code>fixed</code>的CSS样式，还有<code>max-width</code>等。在不希望使用JavaScript的时候，css表达式还是可以作为一个不错的向下兼容的方案的。</p>\n<p>CSS表达式，严格来说应该是CSS中的动态属性，在MSDN中的定义是这样的：</p>\n<pre><code>Using the power of dynamic properties, it is now possible to declare property values not only as constants, but also as formulas. \n</code></pre><p>使用CSS表达式，使得CSS样式中的值不仅仅只有常量，如<code>10px</code>、<code>100%</code>等，还可以是变量、可以通过N条语句计算出来的值。由于IE8及更高版本已经完全支持CSS 2.1的全部功能，像上述说的<code>fixed</code>和<code>max-width</code>等都可以直接使用CSS来实现了。而其他更具体的功能还是推荐使用JavaScript去完成。</p>\n<h3 id=\"-\">接口</h3>\n<hr>\n<ol>\n<li><code>getExpression</code>，获取CSS表达式。</li>\n<li><code>recalc</code>，强制刷新CSS表达式的值。</li>\n<li><code>removeExpression</code>，删除CSS表达式。</li>\n<li><code>setExpression</code>，设置CSS表达式。</li>\n</ol>\n<p>可以在JavaScript脚本中使用以上的命令操作CSS表达式，例如：</p>\n<pre><code>oDiv.style.setExpression(&quot;left&quot;,\n  &quot;document.body.clientWidth/2 - oDiv.offsetWidth/2&quot;\n);\n</code></pre>","path":"2013-09-09-css-expression.json","year":"2013","month":"09","day":"09","tags":["css"]},{"link":"/posts/2013/09/08/dom-attribute-cross-browser-issue.html","title":"Secrets of the JavaScript Ninja 读书笔记之 DOM特性跨浏览器的那些事","summary":"<p>昨天简单地介绍了一下特性和属性的区别。今天来看看跨浏览器编程中，DOM特性和属性的一些问题，以防掉坑。</p>\n<h3 id=\"id-name-in-form\">id/name in form</h3>\n<hr>\n<p>第一个问题有关于<code>form</code>以及其中的表单域。在“Big Five”浏览器中，都会自动为<code>form</code>创建有<code>id</code>或者<code>name</code>特性的表单域同名的属性，以方便快速访问以及设置这些表单域的值。这个方便的功能有时候会造成误会，例如：</p>\n<pre><code>&lt;form id=&quot;testForm&quot; action=&quot;/&quot;&gt;                     \n  &lt;input type=&quot;text&quot; id=&quot;id&quot;/&gt;\n  &lt;input type=&quot;text&quot; name=&quot;action&quot;/&gt;\n&lt;/form&gt;\n</code></pre><p>以上这个<code>form</code>就有一个问题，就是其中有表单域的<code>id</code>或者<code>name</code>的值跟<code>form</code>的一些特性，例如<code>id</code>和<code>action</code>冲突，导致这样的代码：</p>\n<pre><code>document.getElementById(&quot;testForm&quot;).id;\n</code></pre><p>获取的不是<code>form</code>上的<code>id</code>的特性值，而是那个表单域。虽然Chrome、Firfox等标准浏览器可以通过<code>getAttribute</code>获取到特性值，可惜不是所有版本的IE都支持。还有一个办法去获取特性值：</p>\n<pre><code>var actionValue = element.getAttibuteNode(&quot;action&quot;).nodeValue;\n</code></pre><p>鉴于以上代码的复杂性，还是HTML书写阶段不要用<code>form</code>的一些内建特性或者是方法（例如<code>submit</code>）作为表单域的<code>id</code>或者<code>name</code>的值。</p>\n","path":"2013-09-08-dom-attribute-cross-browser-issue.json","year":"2013","month":"09","day":"08","tags":["JavaScript"]},{"link":"/posts/2013/09/07/dom-attribute-and-property.html","title":"Secrets of the JavaScript Ninja 读书笔记之 DOM的特性和属性","summary":"<p>今天介绍一下DOM上面的特性（Attribute）和属性（property）。</p>\n<p>当我们需要获取一个DOM元素上面的特性值，例如<code>id</code>，我们可以使用原生的<code>getAttribute(&quot;id&quot;)</code>，也可以使用<code>elem.id</code>直接获取<code>id</code>的值。但是不要简单地认为这两个方式获取的值都是一样的。</p>\n<h3 id=\"-\">跨浏览器的命名</h3>\n<hr>\n<p>每一个浏览器对于特性和属性的命名都有一些细微的差别。例如<code>class</code>这个特性，Chrome、FireFox可以用<code>getAttribute(&quot;class&quot;)</code>去获取其值，而IE则需要使用<code>className</code>作为特性的名字才能获取到值，例子<a href=\"http://jsfiddle.net/DVHvy/show/\">参考这里</a>。</p>\n<p>我们可以使用jQuery等库去规范这些命名，而当我们使用原生的JavaScript的时候也要注意这些命名的细微差别。</p>\n<h3 id=\"-\">命名的限制</h3>\n<hr>\n<p>由于特性的名称是一个字符串，理论上特性的命名是没有限制的。而属性则不一样，由于属性是一个JavaScript标识符，受到很多标识符的限制，例如不能是JavaScript的关键字或者保留字等等。例如<code>for</code>这个特性对应的属性名称是<code>htmlFor</code>，<code>class</code>这个特性对应的属性名称是<code>className</code>等。</p>\n<h3 id=\"xml-html\">XML和HTML</h3>\n<hr>\n<p>为DOM元素上的特性创建对应的属性其实是HTML DOM的一个能力，而XML DOM是没有这个能力的。这样可以通过以下代码判断一个DOM是否XML DOM：</p>\n<pre><code>function isXML(elem) {\n</code></pre>","path":"2013-09-07-dom-attribute-and-property.json","year":"2013","month":"09","day":"07","tags":["JavaScript"]},{"link":"/posts/2013/09/05/javascript-get-viewport-dimension.html","title":"获取浏览器视口的大小","summary":"<p>在日常工作中，经常需要浏览器当前视口的大小，以防止一些绝对定位的元素跑到视口之外（例如Tips等）。最稳妥的办法是使用jQuery：</p>\n<pre><code>var dimension = {\n  &quot;width&quot;: $(window).width(),\n  &quot;height&quot;: $(window).height()\n};\n</code></pre><p>那用原生的JavaScript是如何获取视口大小的呢？有以下几个属性可以供我们使用：</p>\n<ol>\n<li><code>window.innerWidth</code>和<code>window.innerHeight</code>。</li>\n<li><code>document.documentElement.clientWidth</code>和<code>document.documentElement.clientHeight</code>。</li>\n<li><code>document.body.clientWidth</code>和<code>document.body.clientHeight</code>。</li>\n</ol>\n<p>第一组是<code>innerXXX</code>，只有<code>window</code>有这个属性，而这个属性就是代表了视口的大小！第二组和地三组都是是一个DOM元素的大小，不同是DOM元素而已，一个是<code>documentElement</code>，即<code>html</code>元素，一个是<code>body</code>元素。</p>\n<p>不同的浏览器对于以上这几个属性的处理有所不同，大概可以分成标准和非标准两类：</p>\n<ol>\n<li>标准，即Chrome、FireFox、IE9及以上版本。</li>\n<li>非标准，即IE8及以下版本。</li>\n</ol>\n<p>我们将运行以下的代码测试浏览器对于这些属性的处理，运行例子可以<a href=\"http://jsfiddle.net/s4PhQ/show/\">参考这里</a>：</p>\n","path":"2013-09-05-javascript-get-viewport-dimension.json","year":"2013","month":"09","day":"05","tags":["JavaScript"]},{"link":"/posts/2013/09/04/jquery-append.html","title":"jQuery扫盲之jQuery.fn.append","summary":"<p>今天又来扫盲啦，带来的是<code>jQuery.fn.append</code>的用法。</p>\n<blockquote>\n<p>Insert content, specified by the parameter, to the end of each element in the set of matched elements.</p>\n</blockquote>\n<p>这个方法就是用来插入DOM元素的。有两种调用的方式：</p>\n<p>第一种方式接受不定长的参数列表，每一个参数可以是HTML字符串、DOM元素、数组或者jQuery对象。调用该方法后，会在jQuery对象中所有元素的后面插入指定的内容，如：</p>\n<pre><code>$( &quot;.inner&quot; ).append( &quot;&lt;p&gt;Test&lt;/p&gt;&quot; );\n$( &quot;.container&quot; ).append( $( &quot;h2&quot; ) );\n$( &quot;p&quot; ).append( document.createTextNode( &quot;Hello&quot; ) );\n$( &quot;body&quot; ).append( $newdiv1, [ newdiv2, existingdiv1 ] );\n$(&#39;body&#39;).append( $newdiv1, newdiv2, existingdiv1 );\n</code></pre><p>第二种方式接受一个函数，调用<code>jQuery.fn.append</code>之后会在jQuery对象中所有元素的后面插入该函数返回的内容。该函数有两个参数，与<code>jQuery.fn.html</code>类似，是该元素在jQuery对象中的索引以及该元素在调用<code>append</code>之前的<code>innerHTML</code>，如：</p>\n<pre><code>$(&quot;body&quot;).append(function (i, oldHTML) { return &quot;Hello World&quot;; });\n</code></pre><p>与<code>jQuery.fn.append</code>对应的有<code>jQuery.fn.appendTo</code>。这两个方法唯一的区别是，<code>jQuery.fn.append</code>是把<code>append</code>的参数插到jQuery对象中的每一个元素中；而<code>jQuery.fn.appendTo</code>是把该jQuery对象的元素插入到<code>appendTo</code>的每一个参数中。例子可以<a href=\"http://jsfiddle.net/r6Quz/\">参考这里</a>。</p>\n<p>注意哦，如以下代码：</p>\n","path":"2013-09-04-jquery-append.json","year":"2013","month":"09","day":"04","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/09/03/css-width-max-width-min-width.html","title":"CSS的width、max-width和min-width","summary":"<p>昨天虽然说用<code>width</code>和<code>height</code>控制图片大小的方法生成缩略图的方式不是十分完美，但总是有它适用的场景的。使用这个方式生成缩略图，重要的是保持图片的宽高比，而且高度和宽度都不能超过特定的值。这时候，使用<code>max-width</code>和<code>max-height</code>就是非常好的选择了。今天就简单讨论一下<code>width</code>、<code>max-width</code>和<code>min-width</code>三个CSS样式的属性的区别。</p>\n<h3 id=\"width\">width</h3>\n<hr>\n<blockquote>\n<p>The width CSS property specifies the width of the content area of an element. The content area is inside the padding, border, and margin of the element.</p>\n</blockquote>\n<p><code>width</code>声明的是元素的内容宽度，即不包括<code>padding</code>、<code>border</code>和<code>margin</code>的宽度。</p>\n<p><code>width</code>的默认值是<code>auto</code>，块元素会继承包含块的宽度，而行内元素则会根据行内内容自适应宽度，所以行内元素设置<code>width</code>是没有效果的。</p>\n<p><code>width</code>可以是绝对的长度，例如<code>100px</code>、<code>100em</code>等，也可以是百分比的长度（包含块的绝对宽度的百分比）。</p>\n<h3 id=\"max-width\">max-width</h3>\n<hr>\n<blockquote>\n<p>The max-width CSS property is used to set the maximum width of a given element. It prevents the used value of the width property from becoming larger than the value specified for max-width.</p>\n</blockquote>\n<p>从名字就可以看出来，<code>max-width</code>就是为了限制元素的宽度不能超过某个特定的值。当元素的宽度（无论是绝对长度或者是经百分比计算后的长度）超过<code>max-width</code>所设置的值，元素的宽度就是等于<code>max-width</code>设置的值。这样就是说<strong><code>max-width</code>能覆盖<code>width</code>的值</strong>。</p>\n<p><code>max-width</code>的默认值是<code>none</code>，表示元素默认是没有最大宽度的。与<code>width</code>一样，值可以是绝对长度也可以是百分比长度（同样是包含块的绝对宽度的百分比）。</p>\n","path":"2013-09-03-css-width-max-width-min-width.json","year":"2013","month":"09","day":"03","tags":["css"]},{"link":"/posts/2013/09/02/html-img-size.html","title":"img的大小问题","summary":"<p>说到HTML元素的大小，都是使用CSS类去控制，而尽量避免内联的<code>style</code>，更是尽量不要使用<code>width</code>和<code>height</code>特性。可是在<code>img</code>元素上，可能有点不一样。今天针对<code>width</code>和<code>height</code>特性讨论一下这两个大小属性对于HTML页面的影响。</p>\n<h3 id=\"-\">显式指定图片大小</h3>\n<hr>\n<p>与普通的行内元素元素不一样，图片是可以设置宽度和高度的，可以通过CSS样式去控制，也可以通过<code>width</code>和<code>height</code>特性控制（高级浏览器都会把特性映射到对应的CSS样式中去），例如：</p>\n<pre><code>&lt;img src=&quot;path/to/image.png&quot; alt=&quot;a pic&quot; width=&quot;400&quot; height=&quot;300&quot; /&gt;\n</code></pre><p>在特性上面的值的单位是像素。上面的代码声明了一个宽400像素，高300像素的图片。当声明的大小跟图片实际的大小不一致的时候，浏览器会自动缩放该图片以匹配声明的大小。</p>\n<p>这两个特性可以只设置一个。当只有一个值被设置之后，另一个值会自动变化，以保证图片的宽高比保持不变。</p>\n<p>但是这两个属性不是必须的。如果忽略了对图片大小描述的代码，图片的显示大小跟实际大小是一致的。这样就有一个问题，在图片没有加载完成之前，浏览器并不知道图片的大小是多少（或者不用等待加载完成，但也必须等一定的事件确定图片的大小）。浏览器通常会使用一个默认大小的占位符先把图片的位置占上，当图片的大小确定之后对这个区域重新进行布局。我们知道，重新布局是有额外的开销的，频繁地重置图片的大小可能会造成性能瓶颈（尤其是那些以图片展示为目的的页面，例如图库等）。</p>\n<p>可以在图片加载的时候，显式指定图片的大小。那样浏览器再图片加载完毕之后就不需要重新布局了，可以省下这些开销。</p>\n<p>一个比较有意思的小点：当没有显式指定大小的时候，而图片却加载不上（404等），这个图片的大小会被重置成<code>alt</code>声明的字符串所占的大小。</p>\n<h3 id=\"-\">指定的大小要跟原图大小一致</h3>\n<hr>\n","path":"2013-09-02-html-img-size.json","year":"2013","month":"09","day":"02","tags":["html"]},{"link":"/posts/2013/09/01/javascript-cross-browser-strategies.html","title":"Secrets of the JavaScript Ninja 读书笔记之 跨浏览器编程策略","summary":"<p>今天继续分享跨浏览器编码要注意的问题。经过昨天对跨浏览器编程的一些问题的分析，现在投入实战！</p>\n<h3 id=\"-\">安全修复</h3>\n<hr>\n<p>最安全的跨浏览器代码有以下两个条件：</p>\n<ol>\n<li>a不能在其他浏览器中引入问题。</li>\n<li>a不使用浏览器检测或者特性检测。</li>\n</ol>\n<p>达到以上条件的最简单的方法就是统一这个API在所有浏览器中的表现。例如IE不支持事件捕获，那jQuery就只支持事件冒泡，而不支持事件捕获，即使在支持事件捕获的浏览器中也是如此表现。但是这样做的其中一个缺点，就是限制了在高级浏览器中对应的功能，如上例中的事件捕获。如何平衡这个问题，取决于代码的下游用户，看他们是否需要这些额外的功能。</p>\n<h3 id=\"-\">对象检测</h3>\n<hr>\n<p>通常最安全的场景是很少的，有比较多的时候我们需要对浏览器的某种对象或者特性作检测，以决定应该如何执行我们的代码。最常见的例子就是事件绑定：</p>\n<pre><code>function bindEvent(element, type, handle) {\n  if (element.addEventListener) {\n    element.addEventListener(type, handle, false); }\n  else if (element.attachEvent) {\n    element.attachEvent(&quot;on&quot; + type, handle); }\n</code></pre>","path":"2013-09-01-javascript-cross-browser-strategies.json","year":"2013","month":"09","day":"01","tags":["JavaScript"]},{"link":"/posts/2013/08/31/javascript-cross-browser-concerns.html","title":"Secrets of the JavaScript Ninja 读书笔记之 跨浏览器需要关心的东西","summary":"<p>又到了周末读书的时间啦！今天带来跨浏览器编码需要关心的几个东西。</p>\n<h3 id=\"-bugs\">浏览器的Bugs</h3>\n<hr>\n<p>其中一个最重要的点是我们需要了解，需要支持的数个浏览器中的bugs还有浏览器之间各种API的区别。完成代码的编写之后，最重要的是需要一套完整的测试用例，以便保证各种需要支持的浏览器上面不会出现问题。更重要的是我们需要持续进行测试，以防止浏览器更新之后的各种异常场景。</p>\n<h3 id=\"-bugs\">修复浏览器的Bugs</h3>\n<hr>\n<p>要保证我们对于浏览器的Bugs的规避方法在浏览器修复对应Bugs之后还是可行的。更可靠的方式是做特性检测，而不是去做浏览器检测（检测会发生该bug的浏览器或者特定版本等）。</p>\n<p>规避浏览器的bug可能会造成以下两个麻烦：</p>\n<ol>\n<li>规避的代码很容易在浏览器本身修复该bug之后失效。</li>\n<li>由于害怕浏览器修复bug之后的造成的麻烦，我们可能会停止催促浏览器厂商去修改这些bugs。</li>\n</ol>\n<p>久而久之，会导致一些bug被当作是正确的使用方式，而真正正确的使用方式则被当作是“ bug”了。</p>\n<p>而bug跟非标准的API也有区别。有时候我们为了向下兼容，会为低版本的浏览器自定义高版本浏览器对应的非标准API功能。这时候要注意，当浏览器升级之后，这些API的表现是否跟我们增加的API一致，因为这些非标准API什么时候都有可能改变的。相对的，浏览器的bug的修复是可遇见的，通常跟我们的预期是一致的。</p>\n<h3 id=\"-\">与外部代码共存</h3>\n","path":"2013-08-31-javascript-cross-browser-concerns.json","year":"2013","month":"08","day":"31","tags":["JavaScript"]},{"link":"/posts/2013/08/30/jquery-html-source.html","title":"jQuery源码解析之jQuery.fn.html","summary":"<p>今天来看看<code>jQuery.fn.html</code>的源码。jQuery通过一个<code>access</code>方法封装了jQuery风格的<code>getter</code>和<code>setter</code>。今天先不关注<code>access</code>是怎么实现的，具体来看看<code>html</code>内部的代码逻辑。</p>\n<p>首先来看一下这几个正则：</p>\n<pre><code>var rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^&gt;]*)\\/&gt;/gi,\n  rtagName = /&lt;([\\w:]+)/,\n  rhtml = /&lt;|&amp;#?\\w+;/,\n  rnoInnerhtml = /&lt;(?:script|style|link)/i,\n</code></pre><ol>\n<li>第一个正则是匹配一些自关闭的HTML标签。</li>\n<li>第二个正则匹配字符串中第一个标签的<code>tagName</code>。</li>\n<li>第三个正则匹配这个字符串是否HTML字符串。</li>\n<li>第四个正则匹配这个字符串里面有没有包含样式或者是脚本。</li>\n</ol>\n<p>先来看<code>getter</code>，这个逻辑非常简单：</p>\n<pre><code>if ( value === undefined &amp;&amp; elem.nodeType === 1 ) {\n  return elem.innerHTML;\n}\n</code></pre><p><code>elem</code>是jQuery对象的第一个元素，如果没有传入任何参数并且jQuery对象的一个元素是HTML元素，则直接返回其<code>innerHTML</code>属性。</p>\n","path":"2013-08-30-jquery-html-source.json","year":"2013","month":"08","day":"30","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/08/29/jquery-html.html","title":"jQuery扫盲之.html","summary":"<p>今天工作中遇到了一个小问题：使用<code>.html</code>和<code>.append</code>往一个元素内部添加内容的时候，在IE7、IE8下有两种不同的表现：用<code>.append</code>往元素内部添加特定的HTML字符串，在IE7、8下面是空白的；用<code>.html</code>刷新元素内部的HTML，虽然显示的样式和结构有点异常，但是大部分元素还是正常显示出来了。原因是那段HTML字符串里面有反引号，而且是当反引号成对而且是特定结构的时候才会导致页面空白。到现在还没有查出为什么会有这个问题，今天先来看看<code>.html</code>的使用方法，往后会继续深入<code>.html</code>的源码、<code>append</code>的用法与源码以及两者的区别。</p>\n<blockquote>\n<p>Get the HTML contents of the first element in the set of matched elements or set the HTML contents of every matched element.</p>\n</blockquote>\n<p><code>.html</code>有两种使用方法，分别对应<code>getter</code>和<code>setter</code>，它们按是否传入参数区分。</p>\n<h3 id=\"-html-\">.html()</h3>\n<hr>\n<p>当没有传入任何参数的时候，<code>.html</code>以<code>getter</code>方式调用，返回匹配元素的内部HTML字符串。注意，<strong>如果该jQuery对象包含的元素个数大于1，调用<code>.html</code>方法只会返回第一个元素的内部HTML字符串</strong>。</p>\n<p>返回的字符串未必跟HTML中的代码完全一致，包括HTML标签的大小写或者属性上面的引号等等。</p>\n<h3 id=\"-html-htmlstring-html-function-index-oldhtml-\">.html(HTMLString)或者.html(function(index, oldhtml))</h3>\n<hr>\n<p>当传入HTML字符串或者传入一个回调函数的时候，<code>.html</code>以<code>setter</code>方式调用，设置jQuery对象中所有元素内部的HTML。传入字符串的时候，会直接替换元素内部的HTML字符串；传入回调函数时，会使用回调函数返回的字符串替换元素内部的HTML字符串。</p>\n<p>回调函数接受两个参数，一个是元素的在jQuery对象中的索引，第二个是元素原来的内部HTML字符串。注意，<strong>在调用回调函数之前元素的内部字符串会先被置空</strong>。</p>\n<p>再替换完元素内部的HTML字符串之后，原来内部元素的一些<code>data</code>还有绑定的事件处理程序都会被删除哦。</p>\n","path":"2013-08-29-jquery-html.json","year":"2013","month":"08","day":"29","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/08/28/css-background-about-blank.html","title":"background:url(about:blank)的作用","summary":"<p>接着昨天的话题，做那个需求的时候还有一个问题，就是在IE6上，鼠标指针移动到左右遮盖层上并没有变成对应的箭头！明明其他浏览器都是好的，我艹！这时，想起隔壁前辈跟我说要在遮盖层上面加一个<code>background</code>。参考了公司其他网页的类似功能，是这么一个样式：</p>\n<pre><code>background: url(background.png);\n</code></pre><p>其中那个图片是一个透明的png图片。由于一些历史原因这里才用了一个透明的png图片，其实比较好的实现方式是：</p>\n<pre><code>background: url(about:blank);\n</code></pre><p>例子可以<a href=\"http://jsfiddle.net/6yS7G/1/show/\">参考这里</a>还有<a href=\"http://jsfiddle.net/g7gvq/1/show/\">这里</a>。前者在IE6上只能把鼠标放到<code>border</code>上才会变成手型，而后者则是正常的行为。</p>\n<p>查了一下资料，发现这个样式可以解决以下的一些问题：</p>\n<ol>\n<li>如果给空a标签定义了宽度和高度且使用了<code>absolute</code>，则需要用这个样式“撑开”这个标签。</li>\n<li>IE6上的<code>position: fixed</code>，使用CSS表达式来实现对应的功能时，浏览器滚动条滚动的时候会有抖动的情况。</li>\n</ol>\n<p>以下的内容描述了问题2的解决方案以及原因：</p>\n<blockquote>\n<p>解决此问题的技巧就是使用background-attachment:fixed为body或html元素添加一个background-image。这就会强制页面在重画之前先处理CSS。因为是在重画之前处理CSS，它也就会同样在重画之前首先处理你的CSS表达式。这将让你实现完美的平滑的固定位置元素！</p>\n<p>注：如果是在样式里写position:absolute再用expression()表达式来实现的话，给html一个background:fixed url(about:blank);就能解决抖动的bug，但如果是用js重新计算浮动对像的位置background:fixed url(about:blank);就不能解决抖动问题，因为重新计算浮动对象的位置是基于一个onscroll事件的。</p>\n</blockquote>\n<p>总结，当使用了<code>absolute</code>并指定了宽度或者高度（无论是显示设置<code>witdh</code>和<code>height</code>或者使用<code>top</code>、<code>bottom</code>隐式设定自适应大小），在IE6下面最好加上以下的样式保证显示效果正确：</p>\n","path":"2013-08-28-css-background-about-blank.json","year":"2013","month":"08","day":"28","tags":["css"]},{"link":"/posts/2013/08/27/css-conflicting-absolute-positions.html","title":"利用Absolute进行自适应布局","summary":"<p>昨天做一个类似于幻灯片左右切换的功能，鼠标移动到容器的左边显示前一张的箭头，移动到右边显示后一张的箭头。最简单的实现方式是在容器上面加两个遮盖层，并在遮盖层上设置<code>cursor</code>样式，例如如下代码片段：</p>\n<pre><code>&lt;div id=&quot;wrapper&quot;&gt;\n  &lt;div id=&quot;left&quot;&gt;&lt;/div&gt;\n  &lt;div id=&quot;right&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>CSS：</p>\n<pre><code>#wrapper {\n  width: 100px;\n  height: 100px;\n  background: red;\n  position: relative;\n}\n\n#wrapper div {\n  width: 33.3333%;\n  top: 0;\n  bottom: 0;\n  position: absolute;\n  background: blue;\n</code></pre>","path":"2013-08-27-css-conflicting-absolute-positions.json","year":"2013","month":"08","day":"27","tags":["css"]},{"link":"/posts/2013/08/26/node-child-process-spawn-and-exec.html","title":"Node中spawn和exec的区别","summary":"<p>今天试着结合SPM和Grunt来做项目的构建，在Node中使用子进程调用SPM命令的时候，看文档先用了<code>spawn</code>，发现老是抛出一个错误。后来使用<code>exec</code>就没有什么问题。这两个方法都可以在Node中创建一个子进程执行一些操作系统的命令（bat或者shell脚本），究竟这两者有什么不一样呢？</p>\n<h3 id=\"child_process-spawn\">child_process.spawn</h3>\n<hr>\n<p><code>spawn</code>应该是创建子进程的一个基本的方法。该方法接受三个参数：</p>\n<ol>\n<li><code>command</code>，表示要执行命令的字符串。</li>\n<li><code>args</code>，表示执行命令的命令行参数，如果不提供默认值是一个空数组。</li>\n<li><code>options</code>，可选配置。</li>\n</ol>\n<p>其中<code>options</code>可以配置的属性有：</p>\n<ol>\n<li><code>cwd</code>，配置该命令执行的目录。</li>\n<li><code>stdio</code>，配置子进程跟父进程直接的输入输出方式。</li>\n<li><code>env</code>，配额子进程中的环境变量。</li>\n<li><code>detached</code>，配置子进程是否独立的。默认情况下父进程是需要等待子进程结束才能结束，当这个配置为<code>true</code>时，父进程不需要等待子进程结束，子进程会在后台继续执行。（子进程使用了父进程的io则这个配置始终都是默认情况。）</li>\n<li><code>uid</code>，配置执行子进程的用户id。</li>\n<li><code>gid</code>，配置执行子进程的用户组id。</li>\n</ol>\n<p><code>options</code>的默认值为：</p>\n","path":"2013-08-26-node-child-process-spawn-and-exec.json","year":"2013","month":"08","day":"26","tags":["node"]},{"link":"/posts/2013/08/25/javascript-with-statement-usage.html","title":"Secrets of the JavaScript Ninja 读书笔记之 with语句的应用场景","summary":"<p>昨天介绍了<code>with</code>简单的用法，也大概说明了一下为什么N多书都说不要用<code>with</code>的主要原因。排除这些原因，在真实的应用场景中，有没有适合<code>with</code>使用的场景呢？</p>\n<h3 id=\"-\">使用有命名空间的代码</h3>\n<p>通常为了解决命名冲突问题，我们会使用命名空间，例如：</p>\n<pre><code>var obj = ns1.ns2.ns3.foo(ns1.ns2.ns3.bar);\n</code></pre><p>当命名空间很长的时候，编写类似的代码会非常疲惫。使用<code>with</code>可以使敲入的代码急剧减少：</p>\n<pre><code>with(ns1.ns2.ns3) { var obj = foo(bar); }\n</code></pre><p>是不是比第一段代码要清晰和简单很多？这是最普遍使用<code>with</code>的场景。</p>\n<h3 id=\"-\">测试</h3>\n<p>测试的时候我们需要把各种断言跟测试套件关联起来。如果在同步测试的场景这是非常简单的事情，在异步测试中可能会有一些问题，如果不额外增加一些信息，断言跟测试套件是不能关联起来的。</p>\n<p>解决这个问题的其中一个办法是创建一个测试套件对象，然后在对象中进行异步测试，并且在对象中加入测试套件的信息。这样就可以通过闭包在异步断言内部获取到测试套件的信息，把两者关联起来。如以下代码：</p>\n<pre><code>new Test.Unit.Runner({\n  testSliderBasics: function(){with(this){\n</code></pre>","path":"2013-08-25-javascript-with-statement-usage.json","year":"2013","month":"08","day":"25","tags":["JavaScript"]},{"link":"/posts/2013/08/24/javascript-with-statment.html","title":"Secrets of the JavaScript Ninja 读书笔记之 with语句","summary":"<p>刚接触JavaScript，其中N本入门的书都说不要使用<code>with</code>。可是大家有没有了解过为什么不能使用<code>with</code>，会造成变量的混淆，还是因为别的什么原因？为了了解其中的缘由，我们需要了解<code>with</code>究竟是什么，会对代码造成怎么样的影响。今天先简单介绍一些<code>with</code>的用法以及一些需要注意的地方。</p>\n<blockquote>\n<p>A  with statement creates a scope within which the properties of a specified object can be referenced without a prefix. </p>\n</blockquote>\n<p>使用<code>with</code>可以创建出一个执行作用域。在这个作用域中，作为<code>with</code>的参数传入的对象的属性可以直接引用，而不需要通过这个对象引用，例如：</p>\n<pre><code>var o = { &quot;a&quot;: &quot;a&quot; };\nwith(o) {\n  alert(a); // &quot;a&quot;\n}\n</code></pre><h3 id=\"-with-\">在<code>with</code>中引用属性</h3>\n<p>上面说过，<code>with</code>是创建了一个临时的作用域，使得可以直接访问<code>with</code>参数中变量的属性。所以，在<code>with</code>的作用域中，当属性跟外面的变量冲突的时候，<strong><code>with</code>中的属性优先级比较高</strong>，例如：</p>\n<pre><code>var use = &quot;other&quot;;\nvar katana = {\n  isSharp: true,\n  use: function () {\n    this.isSharp = !this.isSharp;\n  }\n};\n</code></pre>","path":"2013-08-24-javascript-with-statment.json","year":"2013","month":"08","day":"24","tags":["JavaScript"]},{"link":"/posts/2013/08/23/html-object.html","title":"HTML Object标签","summary":"<p>今天看一下<code>object</code>这个标签。</p>\n<blockquote>\n<p>The HTML object Element (or HTML Embedded Object Element) represents an external resource, which can be treated as an image, a nested browsing context, or a resource to be handled by a plugin.</p>\n</blockquote>\n<p><code>object</code>标签用来引用一个外部资源，该资源可以是一个图片、一个被插件使用的资源。最常见的用法是用它来引入一个flash影片，如：</p>\n<pre><code>&lt;object data=&quot;move.swf&quot; type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;\n</code></pre><h3 id=\"html4\">HTML4</h3>\n<p>以下几个特性只能在HTML4中使用了：</p>\n<ol>\n<li><code>archive</code>，由空格分隔的指向档案文件的 URL 列表。这些档案文件包含了与对象相关的资源。</li>\n<li><code>classid</code>，定义嵌入 Windows Registry 中或某个 URL 中的类的 ID 值，此属性可用来指定浏览器中包含的对象的位置。</li>\n<li><code>codebase</code>，定义在何处可找到对象所需的代码，提供一个基准 URL。</li>\n<li><code>codetype</code>，通过 classid 属性所引用的代码的 MIME 类型。</li>\n<li><code>declare</code>，可定义此对象仅可被声明，但不能被创建或例示，直到此对象得到应用为止。</li>\n<li><code>standby</code>，定义当对象正在加载时所显示的文本。</li>\n<li><code>tabindex</code>，定义在文档中的<code>tab</code>键顺序。</li>\n</ol>\n<p>在HTML4里面，这样引用一个flash影片可能更常见：</p>\n","path":"2013-08-23-html-object.json","year":"2013","month":"08","day":"23","tags":["html"]},{"link":"/posts/2013/08/22/alice-css-module-guide.html","title":"搬运：Alice CSS模块化规范","summary":"<p>今天看了一下支付宝的CSS解决方案<a href=\"http://aliceui.org/\">Alice</a>。她包括了一套通用样式模块库，一个模块化样式构建规范，一组帮助书写和组织样式的工具，以及产出更多 Alice 模块和样式库的完善方案。个人感觉它关于模块化样式构建规范比较好，在这里斗胆搬运给大家参考。</p>\n<p>其中比较关键的就是CSS样式命名的规范。在没有规范或者规范比较弱的情况下，各种CSS的class名字都是开发人员随意取的。各种没有意义的class名称、各种重复、各种冗余，导致每次写出来的CSS代码都难以重用，尽管它们实现的效果大同小异。Alice定义了一套模块化的CSS样式命名规范，提高CSS样式的可读性以及可重用性。</p>\n<h3 id=\"-\">前缀</h3>\n<p>首先样式名称以一个前缀开头，例如基础框架以及基础的样式库可以使用<code>ui-</code>，而各产品线自定义的样式可以使用别的前缀来区分。这样既可直观地区分各个级别的CSS样式，又可以减少CSS样式命名冲突。</p>\n<h3 id=\"-\">模块</h3>\n<p>前缀之后就是具体CSS模块的名称，一般是有某种具体功能的区块，例如tab页签<code>ui-tab</code>或者是分页器<code>ui-page</code>等，也可以是产品线定义具体业务区块，如<code>fn-chartroom</code>等。这个样式应该被应用在这个区块的最外层元素（对应一个顶层的HTML元素作为容器）上。</p>\n<h3 id=\"-\">内部模块</h3>\n<p>在容器之内的所有样式名称都要以其父元素应用的样式作为前缀，例如：</p>\n<pre><code>ui-tab {...}\nui-tab-content {...}\n</code></pre><p>虽然这样会导致多级嵌套的模型CSS样式名称过长，但是可以维持CSS代码的可维护性，从名称上就能看出各个样式之间的关系。</p>\n<h3 id=\"-\">状态</h3>\n","path":"2013-08-22-alice-css-module-guide.json","year":"2013","month":"08","day":"22","tags":["css"]},{"link":"/posts/2013/08/21/document-write.html","title":"document.write","summary":"<p>说到<code>document.write</code>，在之前的工作中都不会使用到，有几个原因：一个是不需要，可以通过DOM原生的或者jQuery的相关方法动态增加DOM元素；第二个原因是在文档已经被加载完毕之后再调用<code>document.write</code>会导致整个文档被重写，像以下的代码：</p>\n<pre><code>&lt;div id=&quot;clickme&quot;&gt;Click me!&lt;/div&gt;\n&lt;script&gt;\n  document.write(&quot;&lt;div&gt;Hello World&lt;/div&gt;&quot;)\n  window.onload = function () {\n    document.getElementById(&quot;clickme&quot;).onclick = function () {\n      document.write(&quot;&lt;div&gt;I write after document.loaded!&lt;/div&gt;&quot;);\n    };\n  }\n&lt;/script&gt;\n</code></pre><p>单击按钮之后之前写入的<code>Hello World</code>会被清除，只剩下调用<code>document.write</code>输出的那一行HTML代码。</p>\n<p>但是在展现型的页面，我发现经常都会使用这个方法来做一些输出，例如说广告、页脚等与页面内容关系不大的内容。这样做的好处可能是可以把一些与整个页面没有太大关系的内容独立到一个JavaScript文件里面去，类似于一些服务器脚本的<code>include</code>方法实现的效果。</p>\n<p>这个方法适用于各种类型的DOM（包括XML和HTML等）。</p>\n<blockquote>\n<p>Writes a string of text to a document stream opened by document.open().</p>\n</blockquote>\n<p>这个方法接受一个参数（也可以是可变参数列表，会把所有参数都连接起来），就是要输出的字符串（可以包含标签）。</p>\n","path":"2013-08-21-document-write.json","year":"2013","month":"08","day":"21","tags":["JavaScript"]},{"link":"/posts/2013/08/20/jquery-callbacks-source-code.html","title":"jQuery源码解析之jQuery.Callbacks","summary":"<p>昨天介绍了<code>jQuery.Callbacks</code>方法，今天简单看一下它的源码。github上的代码链接<a href=\"https://github.com/jquery/jquery/blob/master/src/callbacks.js\">在这里</a>。</p>\n<p>jQuery的主干已经是2.0版本了。几乎每个文件的开始都是按照以下的形式给出：</p>\n<pre><code>define([\n  &quot;./core&quot;,\n  &quot;./var/rnotwhite&quot;\n], function( jQuery, rnotwhite ) {\n</code></pre><p>通过一个全局的<code>define</code>函数，实现类似于node的依赖管理。现在还没有看<code>define</code>的源码，可以猜测第一个参数就是这个js文件（模块）的依赖，而这个模块的逻辑都被封装在第二个匿名函数的闭包里面。</p>\n<p>首先是一个工具方法，解析<code>jQuery.Callbacks</code>方法传入的参数，即各种flag。这里有一个性能优化点，<code>Callbacks</code>方法会以每次调用的字符串参数作为key，解析的结果作为value缓存起来，下次使用同样的字符串调用<code>jQuery.Callbacks</code>就可以省去解析参数的过程了。</p>\n<p>这个方法的核心就是返回的对象，这个对象的核心就是<code>fire</code>、<code>add</code>和<code>remove</code>等方法。</p>\n<p>首先来看一个工具函数<code>fire</code>，<code>Callbacks</code>对象上的<code>fire</code>跟<code>fireWidth</code>这两个方法都是基于这个工具函数的。这个工具函数会递归调用自己，并每次更改<code>fire</code>的索引来遍历整个回调列表。这里关注一下递归的结束条件：</p>\n<pre><code>if ( stack ) {\n  if ( stack.length ) {\n    fire( stack.shift() );\n  }\n} else if ( memory ) {\n</code></pre>","path":"2013-08-20-jquery-callbacks-source-code.json","year":"2013","month":"08","day":"20","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/08/19/jquery-callbacks.html","title":"jQuery.Callbacks","summary":"<p>今天第一天入职，就听到<code>jQuery.Callbacks</code>这个方法。使用这个方法可以实现功能强大的观察者模式。</p>\n<blockquote>\n<p>A multi-purpose callbacks list object that provides a powerful way to manage callback lists.</p>\n</blockquote>\n<p>这个方法是<code>jQuery.ajax</code>和<code>jQuery.Deffered</code>的内部实现呢。今天先不看代码，先简单看看这个方法是怎么使用的。这个方法接受一个参数<code>flag</code>，可选的值有以下几个或者这几个的组合（之间用空格隔开）：</p>\n<ol>\n<li><code>once</code>，保证相关的绑定的回调只会调用一次。</li>\n<li><code>memory</code>，这个是一个相当有趣的标志。当先触发，再绑定的情况下绑定的回调照样会执行！</li>\n<li><code>unique</code>，保证每个回调函数只能被绑定一次。</li>\n<li><code>stopOnFalse</code>，当任何一个回调函数返回<code>false</code>的时候停止其他回调函数的执行。</li>\n</ol>\n<p>执行这个方法后会返回一个<code>Callbacks</code>类型的对象。该对象有几个比较重要的方法：</p>\n<ol>\n<li><code>add</code>，绑定回调，可以绑定单个函数或者绑定一个函数的数组。</li>\n<li><code>remove</code>，解除绑定，接受的参数与<code>add</code>一致。</li>\n<li><code>fire</code>，触发回调，传入的参数也会传入到每一个回调函数里面。</li>\n<li><code>disable</code>，不接受参数，禁用该对象，<code>fire</code>、<code>remove</code>等都被禁用。</li>\n</ol>\n<p>使用<code>jQuery.Callbacks</code>可以实现一个观察者模式。下面是jQuery文档里面的一个例子：</p>\n<pre><code>var topics = {};\n</code></pre>","path":"2013-08-19-jquery-callbacks.json","year":"2013","month":"08","day":"19","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/08/18/javascript-timer-usage.html","title":"Secrets of the JavaScript Ninja 读书笔记之 使用定时器","summary":"<p>继续周末读书时间。昨天讨论了定时器的基本原理，今天来看看定时器在实际使用中能做些什么有趣的事情。</p>\n<h3 id=\"-\">连续执行耗时任务</h3>\n<p>在某些应用场景中，需要对一大堆数据进行处理（例如根据数据渲染表格，数据量超过1000+条）。如果仅仅用一个<code>for</code>循环对每一个数据项进行处理，由于整个处理的过程都是同步的，而JavaScript的处理线程（包括浏览器渲染、事件处理等）是单线程的，这样连续的同步操作会导致浏览器没有办法对用户的操作进行响应，某些浏览器（例如FireFox），在超过特定的时间内执行的JavaScript代码，会弹出提示框提示用户是否继续执行这些操作。这样的用户体验是相当糟糕的。那么如何在处理这一大堆数据的同时，也不让浏览器弹出类似的提示框呢？</p>\n<p>我们可以利用定时器把这一系列的同步操作分割成多个异步操作连续执行，在每个异步操作执行的间隔，把JavaScript线程空闲出来处理浏览器另外的事务。可以抽象出这样一个方法，对大数据（一般是<code>length</code>相当长的数组）进行分段操作：</p>\n<pre><code>function asyncProcess(data, fn, complete, blockSize, timeout, context) {\n  data = data || [];\n  fn = fn || function () {};\n  blockSize = blockSize || data.length;\n  timeout = timeout || 200;\n  complete = complete || function () {};\n\n  var index = tId = 0;\n\n  function process() {\n    var block = data.slice(index, index + blockSize);\n    for (var i = 0; i &lt; block.length; i++) {\n      fn.call(context, block[i]);\n    }\n</code></pre>","path":"2013-08-18-javascript-timer-usage.json","year":"2013","month":"08","day":"18","tags":["JavaScript"]},{"link":"/posts/2013/08/17/javascript-timer.html","title":"Secrets of the JavaScript Ninja 读书笔记之 定时器是怎么运作的","summary":"<p>又到周末读书的时间啦！今天分享一下书中关于定时器的一些简单的原理。</p>\n<h3 id=\"-\">创建、撤销定时器</h3>\n<p>在JavaScript中，定时器有两种。一种是Timeout，只会在设置的时间之后执行一次。另一种是Interval，会以设置的时间为周期反复执行。有两个创建定时器的方法与之对应：<code>setTimeout</code>和<code>setInterval</code>。这两个方法都接受两个参数：</p>\n<ol>\n<li>执行的代码，这个参数可以是一个匿名函数、一个函数的引用，甚至是一段以字符串形式表示的JavaScript代码。</li>\n<li>设置的时间。</li>\n</ol>\n<p>这两个参数都会返回一个<code>id</code>，通过这个<code>id</code>可以调用对应的<code>clearTimeout</code>和<code>clearInterval</code>撤销对应的定时器。撤销之后（Timeout必须在设置事件之前撤销）指定的代码将不会被执行。虽然有些浏览器可以用<code>clearTimeout</code>去撤销<code>setInterval</code>或者用<code>clearInterval</code>去撤销<code>setTimeout</code>，但是<strong>强烈建议创建跟撤销的方法配对使用</strong>。</p>\n<h3 id=\"-\">定时器执行</h3>\n<p>记住一点，<strong>在定时器中设置的时间并不是精确的</strong>。例如以下代码：</p>\n<pre><code>setTimeout(fn, 10);\n</code></pre><p><code>fn</code>并不一定在10毫秒之后被调用。这个是跟JavaScript是单线程处理有关。每一个时刻只有一段JavaScript代码被执行。在设置完定时器之后，可能有一段耗时超过10毫秒的代码一直在执行，也可能用户在这10毫秒之内频繁与浏览器进行交互，导致对应的事件处理程序不断被触发等。所以，尤其是Interval，这个时间并不是精确的。</p>\n<h3 id=\"timeout-interval-\">Timeout跟Interval的区别</h3>\n<p>最大的区别肯定是Timeout只执行一次，而Interval则会周期执行，一个Interval可以看作是一个不断Timouet不断地重复。其实它们之间还有很多不一样的地方，当设置时间到达之后还有代码在执行导致定时器发生延时：</p>\n","path":"2013-08-17-javascript-timer.json","year":"2013","month":"08","day":"17","tags":["JavaScript"]},{"link":"/posts/2013/08/16/css-media-query.html","title":"响应式设计入门之media query","summary":"<p>今天再简单介绍一下响应式设计中的另外一个比较重要的技术，媒体查询media query。</p>\n<blockquote>\n<p>A media query consists of a media type and at least one expression that limits the style sheets&#39; scope by using media features, such as width, height, and color. Media queries, added in CSS3, let the presentation of content be tailored to a specific range of output devices without having to change the content itself.</p>\n</blockquote>\n<p>相比HTML4和CSS2中，只能根据特定的媒体类型（例如屏幕、打印机等）选择应用不同的样式，在CSS3中，可以利用更多的属性进行判断，例如宽度、高度还有颜色等。因此，可以根据当前设备的分辨率等要素，决定整个页面的布局以及应用特定的样式，从而让页面能够适应不同的设备以及不同的分辨率。</p>\n<p>CSS3中的媒体查询跟CSS2中的使用方式一样，有以下两种方式：</p>\n<pre><code>&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt; // 在link标签上声明媒体查询\n</code></pre><p>或者在样式文件或者内联的style标签中声明媒体查询：</p>\n<pre><code>&lt;style&gt;\n@media (max-width: 600px) {\n  .facet_sidebar {\n    display: none;\n  }\n}\n&lt;/style&gt;\n</code></pre><p>媒体查询表达式由属性还有其可选的值组成，属性与值之间用<code>:</code>分隔。日常使用中常用的属性有下列几个：</p>\n","path":"2013-08-16-css-media-query.json","year":"2013","month":"08","day":"16","tags":["css"]},{"link":"/posts/2013/08/15/ie-conditional-comment.html","title":"IE条件注释","summary":"<p>IE条件注释提供了一个浏览器端的手段，去做浏览器检测。这个手段不需要去判断<code>window.navigator</code>，所以不用担心各种<code>navigator</code>的篡改。但是这个手段目前只能用在IE上，但是，这不就已经够了吗？</p>\n<p><strong>注意，IE10已经不支持条件注释了</strong>。但是貌似IE10已经向W3的规范靠拢了，影响应该不大。</p>\n<p>IE的条件注释原来有两种：</p>\n<ol>\n<li>不支持条件注释的浏览器不显示：<code>&lt;!--[if IE 8]&gt;...&lt;![endif]--&gt;</code></li>\n<li>不支持条件注释的浏览器显示：<code>&lt;![if IE 8]&gt;...&lt;![endif]&gt;</code></li>\n</ol>\n<p>原理很简单，由于前者跟HTML的注释要求的格式是一样的，所以在不支持条件注释的浏览器会认为这个是一个HTML的注释，不会解析里面的HTML片段。而后者则是被认为是一个HTML标签（虽然明显不符合XML的规范……），就会解析里面的HTML片段。</p>\n<p>前者可以为判断IE的版本决定是否需要加入额外的HTML、CSS、JavaScript来提供完整的功能，如在IE9以下的版本使用<code>canvas</code>，增加<code>exCanvas</code>的引用：</p>\n<pre><code>&lt;!--[if lt IE 9]&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;excanvas.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;\n</code></pre><p>后者可以提示一些非特定版本IE的用户使用特定版本IE，如：</p>\n<pre><code>&lt;![if lt IE 8]&gt;\n&lt;p&gt;Please upgrade to Internet Explorer version 8.&lt;/p&gt;\n&lt;![endif]&gt;\n</code></pre><p>再来看看条件注释里面的表达式，由<code>if</code>以及后面的条件表达式组成。条件表达式有三种：</p>\n","path":"2013-08-15-ie-conditional-comment.json","year":"2013","month":"08","day":"15","tags":["html"]},{"link":"/posts/2013/08/14/dom-removeattribute.html","title":"DOM 的removeAttribute方法","summary":"<p>今天是Attribute系列的最后一篇。前面两篇讨论了如何获取、增加、修改一个DOM元素的特性。今天轻松一下，把删除讨论完。</p>\n<blockquote>\n<p>removeAttribute removes an attribute from the specified element.</p>\n</blockquote>\n<p><code>removeAttribute</code>的功能很简单，就是删除指定名称的特性。该方法只接受一个参数，就是指定特性名称的字符串。以下是一个使用的例子：</p>\n<pre><code>document.getElementById(&quot;div1&quot;).removeAttribute(&quot;align&quot;);\n</code></pre><p>昨天也讨论过类似的例子，就是如果需要删除一个特性的话，使用<code>removeAttribute</code>比使用<code>setAttribute</code>把该特性置成<code>null</code>或者空字符串要好。尝试删除一个不存在的特性不会抛出任何异常。</p>\n<p>既然用<code>setAttribute</code>可以为一个DOM元素绑定事件处理程序，那么对应使用<code>removeAttribute</code>也可以解除事件绑定，如以下代码：</p>\n<pre><code>&lt;div id=&quot;test&quot; onclick=&quot;alert(1);&quot;&gt;Test&lt;/div&gt;\n</code></pre><p>JavaScript：</p>\n<pre><code>document.getElementById(&quot;test&quot;).removeAttribute(&quot;onclick&quot;);\n</code></pre><p>单击该<code>div</code>元素不会弹出消息框。可惜IE7又再一次华丽地失败了。例子<a href=\"http://jsfiddle.net/PnKh6/show/\">参考这里</a>。</p>\n<p>最后一个要注意的点是，如果删除的特性有默认值，则调用<code>removeAttribute</code>删除该特性之后会把该特性重置成该特性的默认值，如以下代码：</p>\n","path":"2013-08-14-dom-removeattribute.json","year":"2013","month":"08","day":"14","tags":["JavaScript"]},{"link":"/posts/2013/08/13/dom-setattribute.html","title":"DOM的setAttribute方法","summary":"<p>昨天讨论了<code>getAttribute</code>，今天继续讨论<code>setAttribute</code>的使用方法。</p>\n<h3 id=\"-\">标准</h3>\n<blockquote>\n<p>Adds a new attribute or changes the value of an existing attribute on the specified element.</p>\n</blockquote>\n<p><code>setAttribute</code>这个方法就是用来增加或者修改一个DOM元素上的特性（Attribute）。当指定名称的特性不存在，则会新增一个该名称的特性；如果该特性已经存在，则会修改现有特性的值。这个方法接受两个参数：</p>\n<ol>\n<li>表示特性名称的字符串。</li>\n<li>这个特性的新的值。当传入的参数不是字符串的时候会隐式调用参数的<code>toString</code>方法。例子<a href=\"http://jsfiddle.net/7Tenq/\">参考这里</a>。IE7貌似有不一样的行为，下面会提到。</li>\n</ol>\n<p>使用的例子如下:</p>\n<pre><code>var d = document.getElementById(&quot;d1&quot;); \nd.setAttribute(&quot;align&quot;, &quot;center&quot;);\n</code></pre><p>与<code>getAttribute</code>类似，在HTML DOM里面<code>setAttribute</code>也是大小写不敏感的。当需要删除一个特性的时候不应该使用<code>setAttribute(&quot;someAttr&quot;, null)</code>，而是应该使用<code>removeAttribute</code>。</p>\n<h3 id=\"-ie\">又是IE</h3>\n<p>与<code>getAttribute</code>类似，IE7以及更早的版本有一套自己的实现。在比较早的IE的版本又可以传入第三个参数：<code>lflag</code>，这个标志位接受以下两个值：</p>\n","path":"2013-08-13-dom-setattribute.json","year":"2013","month":"08","day":"13","tags":["JavaScript"]},{"link":"/posts/2013/08/12/dom-getattribute.html","title":"DOM的getAttribute方法","summary":"<p>获取一个DOM元素的特性（Attribute），相信也是一个前端攻城师天天都要涉及的问题。虽然日常我们都被jQuery宠坏了，还是要了解一下原生的应该如何获取一个DOM元素的特性值的方法。</p>\n<blockquote>\n<p>getAttribute() returns the value of the named attribute on the specified element.</p>\n</blockquote>\n<p><code>getAttribute</code>返回特定DOM元素上的特性的值。该方法接受一个参数，就是表示特性的名称的字符串。当该特性存在时返回该特性的字符串的值，否则返回<code>null</code>或者空字符串。</p>\n<h3 id=\"-\">标准</h3>\n<p>调用<code>getAttribute</code>，传入的代表特性名称的字符串是大小写不敏感的，内部实现先会把参数转换成小写再进行操作。</p>\n<p>大部分浏览器在没有找到该特性值的时候会返回<code>null</code>，例子<a href=\"http://jsfiddle.net/GVT4E/\">参考这里</a>。但是，在DOM 3 Core的标准下应该返回的是<strong>空字符串</strong>，而某些浏览器是按照标准去实现的。所以，当<code>getAttribute</code>返回一个空字符串的时候，可能是该特性没有找到，也可能是该特性的值就是一个空字符串。此时，应该使用<code>hasAttribute</code>去判断一个元素上的某个特性是否存在，如：</p>\n<pre><code>function getAttr(test) {\n  if (test.hasAttribute(&quot;a&quot;)) {\n    alert(&quot;has attribute a, value is &quot; + test.getAttribute(&quot;a&quot;));\n  } else {\n    alert(&quot;has not attribute a&quot;);\n  }\n}\n</code></pre><p>例子<a href=\"http://jsfiddle.net/crctX/\">参考这里</a>。P.S. IE 7不支持<code>hasAttribute</code>……</p>\n","path":"2013-08-12-dom-getattribute.json","year":"2013","month":"08","day":"12","tags":["JavaScript"]},{"link":"/posts/2013/08/11/javascript-code-evaluate.html","title":"Secrets of the JavaScript Ninja 读书笔记之 执行字符串形式的表达式","summary":"<p>周末还是继续读书笔记。今天讨论的是JavaScript中执行字符串形式的表达式的几种方式。</p>\n<h3 id=\"eval\">eval</h3>\n<p>这个应该是最简单的执行字符串表达式的方法了。<code>eval</code>接受一个参数，就是字符串形式的表达式，并返回最后一条语句的返回结果。比较常见的用法就是把JSON格式的字符串转换成JavaScript的对象：</p>\n<pre><code>var o = eval(&#39;({ninja: 1})&#39;);\n</code></pre><p>如果把圆括号省略，<code>o</code>的值是<code>undefined</code>，因为参数语句执行时没有返回任何东西。加上圆括号之后，执行该语句会返回这个对象的值，<code>o</code>才能正确赋值。</p>\n<p>还有一点需要注意的是<code>eval</code>中的语句执行的作用域与上下文与调用<code>eval</code>所在的作用域和上下文一致。</p>\n<h3 id=\"function-\">Function构造器</h3>\n<p>Function构造器的参数列表是可变的。其中最后一个参数是字符串形式的函数逻辑，前面所有参数声明了构造的函数接受哪些参数，如：</p>\n<pre><code>var add = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a + b;&quot;);\n</code></pre><p>与<code>eval</code>不一样的是，使用Function构造器创建的函数<strong>不会产生闭包</strong>，即不能访问外部函数的变量，如：</p>\n<pre><code>(function () {\n  var a = &quot;outter&quot;;\n</code></pre>","path":"2013-08-11-javascript-code-evaluate.json","year":"2013","month":"08","day":"11","tags":["JavaScript"]},{"link":"/posts/2013/08/10/javascript-oo-gotchas.html","title":"Secrets of the JavaScript Ninja 读书笔记之 面向对象陷阱","summary":"<p>又到了周末读书的时间了。今天跟大家分享一下书中关于原型、实例化和继承的一些陷阱。</p>\n<h3 id=\"-object-\">扩展<code>Object</code></h3>\n<p>先来看看扩展<code>Object.prototype</code>可能会发生什么潜在的问题。假如我们为<code>Object</code>的原型增加一个获取对象上键值的个数，可能会这么写：</p>\n<pre><code>Object.prototype.keys = function() {      \n  var keys = [];\n  for (var p in this) keys.push(p);\n  return keys;\n};\nvar obj = { a: 1, b: 2, c: 3 };              \nalert(obj.keys());\n</code></pre><p>结果返回了<code>[a, b, c, keys]</code>。这种遍历方式甚至把我们刚才扩展<code>Object.prototype</code>的那个<code>keys</code>方法都遍历出来了！一般情况下，我们对一个对象进行遍历，是不需要把对象上的方法遍历出来的。解决上面的问题，一种方案是判断遍历的值是否是方法，另一种方案就是使用<code>hasOwnProperty</code>来判断对象是否拥有这个属性，过滤掉原型链中的其他属性。</p>\n<h3 id=\"-number-\">扩展<code>Number</code></h3>\n<p>为<code>Number.prototype</code>做扩展要注意的是，在其文档中要说明如何使用这个扩展。假设我们为<code>Number.prototype</code>增加了一个<code>add</code>方法，那只能按以下的方式调用：</p>\n<pre><code>var n = 5;\nn.add(2);\n</code></pre>","path":"2013-08-10-javascript-oo-gotchas.json","year":"2013","month":"08","day":"10","tags":["JavaScript"]},{"link":"/posts/2013/08/09/jquery-each.html","title":"jQuery源码解析之jQuery.each","summary":"<p>昨天讨论了<code>for...in</code>的用法，今天来看一个可能我们日常使用频率更高另外一个遍历的方法：<code>jQuery.each</code>。先来看看jQuery对<code>each</code>的描述：</p>\n<blockquote>\n<p>A generic iterator function, which can be used to seamlessly iterate over both objects and arrays. Arrays and array-like objects with a length property (such as a function&#39;s arguments object) are iterated by numeric index, from 0 to length-1. Other objects are iterated via their named properties.</p>\n</blockquote>\n<p>从描述中可以看出来，<code>jQuery.each</code>即可以遍历数组（包括<code>arguments</code>对象），也可以遍历一个对象上的属性。该方法接受两个参数：</p>\n<ol>\n<li><code>collection</code>，需要遍历的数组或者对象。</li>\n<li><code>callback</code>，遍历时的回调函数，该函数接受两个参数，一个是这次遍历的下标（数组）或者键值（对象），另一个是这次遍历的迭代子的值。</li>\n</ol>\n<p>执行这个方法返回的是被遍历的对象，便于写出链式写法的代码。</p>\n<p>在每次遍历的回调中，我们可以通过<code>return false</code>来实现<code>for</code>循环中的<code>break</code>功能，通过返回非<code>false</code>的值来实现<code>continue</code>的功能。如以下代码：</p>\n<pre><code>$.each([1, 2, 3, 4], function(i, v) {\n  if (v === 1) {\n    return true;\n  }\n  if (v === 3) {\n    return false;\n  }\n  console.log(v);\n});\n</code></pre>","path":"2013-08-09-jquery-each.json","year":"2013","month":"08","day":"09","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/08/08/javascript-iteract-an-object.html","title":"在JavaScript中遍历一个对象的所有属性","summary":"<p>在JavaScript中遍历一个对象的所有属性，相信这个一个前端开发人员几乎每天都要面对的事情。最简单的莫过于<code>for...in</code>循环：</p>\n<pre><code>for (variable in object) {\n  ...\n}\n</code></pre><p>其中：</p>\n<ol>\n<li><code>variable</code>是这个对象里面的键值。</li>\n<li><code>object</code>是要遍历的对象。</li>\n</ol>\n<p>注意：这个循环是不会去遍历那些被声明为不可遍历的属性（例如<code>Object.prototype</code>或者<code>String.prototype</code>上面的属性）。执行<code>for...in</code>循环时，不仅会遍历这个对象上的所有属性，也会沿着这个对象的原型链遍历所有原型链上的属性，例如：</p>\n<pre><code>function A () {\n  this.b = &quot;b&quot;;\n  this.a = &quot;a&quot;;\n}\n\nA.prototype.a = &quot;prototype a&quot;;\nA.prototype.c = &quot;prototype c&quot;;\n\nvar a = new A();\n</code></pre>","path":"2013-08-08-javascript-iteract-an-object.json","year":"2013","month":"08","day":"08","tags":["JavaScript"]},{"link":"/posts/2013/08/07/css-bfc.html","title":"了解BFC","summary":"<p>BFC，Block Formatting Context，简单的说就是一个块元素布局上下文，MDN中是这么解释的：</p>\n<blockquote>\n<p>A block formatting context is a part of a visual CSS rendering of a Web page. It is the region in which the layout of block boxes occurs and in which floats interact with each other.</p>\n</blockquote>\n<p>在触发了BFC的容器中，声明了内部浮动元素的布局规则。一个元素浮动或者清除浮动，不会影响另一个BFC的内部元素的布局。</p>\n<p>通过以下条件可以使一个元素生成BFC：</p>\n<ol>\n<li>aHTML文档的根节点。</li>\n<li>a浮动元素。</li>\n<li>a绝对定位的元素。</li>\n<li>a<code>display</code>是<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>或者<code>inline-flex</code>的元素。</li>\n<li>a<code>overflow</code>不是<code>visible</code>的元素。</li>\n</ol>\n<p>当一个元素触发了BFC，会有以下几个布局规则：</p>\n<ol>\n<li>a不与浮动元素重叠。</li>\n<li>a清除元素内部的浮动。通过触发BFC，使元素内部的浮动元素造成布局的影响限制在触发BFC元素之内。</li>\n<li>a不让内外<code>margin</code>合并。</li>\n</ol>\n<p>看上去跟昨天介绍的<code>hasLayout</code>造成的效果有点类似啊。所以才说在触发BFC的同时最好也同时触发<code>hasLayout</code>，以保证不同浏览器中的显示效果一致。</p>\n","path":"2013-08-07-css-bfc.json","year":"2013","month":"08","day":"07","tags":["css"]},{"link":"/posts/2013/08/06/css-ie-haslayout.html","title":"IE的hasLayout","summary":"<p>只有在IE8之前版本的IE上才会有hasLayout这个纠结的东西。在这些版本的IE中，有两种类型的元素：</p>\n<ol>\n<li>a拥有布局的元素，可以控制自己的大小及其子元素的布局。</li>\n<li>a没有布局的元素，只能根据最近的拥有布局的祖先元素来确定自己的大小和布局。</li>\n</ol>\n<p>拥有布局的元素可以控制自己的大小，也可以控制其自身及其子元素的布局。一些没有特定声明宽度和高度的元素，但是有一些大小限制的元素，例如表单控件、图片等，通常也是拥有布局的元素。只有拥有布局的元素才能控制是否出现滚动条。</p>\n<p>拥有布局的元素意味着：</p>\n<ol>\n<li>a限制这个元素成为一个矩形（强制行内元素的布局行为变得像块元素一样）。</li>\n<li>a一些关于这个元素的大小位置等属性会被缓存起来，也会参与到大小位置改变的算法中，造成额外的内存于时间消耗。</li>\n<li>a不能根据子元素的内容进行自适应。</li>\n</ol>\n<p>当一个元素拥有布局的时候，我们说这个元素触发了<code>hasLayout</code>，也就是说这个元素有个内部属性为<code>hasLayout: true</code>。注意，这个不是一个CSS的样式，某种特定的情况下一个元素就会拥有布局。</p>\n<p>首先是默认就拥有布局的元素：</p>\n<ol>\n<li>a图片</li>\n<li>a表格、表格行、单元格</li>\n<li>a表单控件</li>\n<li>a<code>frameset</code>等框架元素</li>\n<li>a<code>object</code>等嵌入元素</li>\n</ol>\n","path":"2013-08-06-css-ie-haslayout.json","year":"2013","month":"08","day":"06","tags":["css"]},{"link":"/posts/2013/08/05/javascript-flash-comunication.html","title":"JavaScript与Flash通信","summary":"<p>虽然说iOS不支持Flash，但是Flash在桌面端的使用量还是很大的。作为一个专业的前端开发人员，至少也要懂得如何使用JavaScript与Flash进行通信。</p>\n<h3 id=\"javascript-flash\">JavaScript =&gt; Flash</h3>\n<p>使用JavaScript调用Flash内部的方法。假设有以下Flash片段：</p>\n<pre><code>&lt;object type=&quot;application/x-shockwave-flash&quot; id=&quot;myFlashID&quot; width=&quot;85&quot; height=&quot;85&quot; data=&quot;framejump.swf&quot;&gt;\n  &lt;param name=&quot;allowScriptAccess&quot; value=&quot;sameDomain&quot;&gt;\n  &lt;param name=&quot;movie&quot; value=&quot;framejump.swf&quot;&gt;\n  &lt;param name=&quot;quality&quot; value=&quot;high&quot;&gt;\n  &lt;param name=&quot;scale&quot; value=&quot;noscale&quot;&gt;\n  &lt;param name=&quot;wmode&quot; value=&quot;transparent&quot;&gt;\n&lt;/object&gt;\n</code></pre><p>我们可以通过JavaScript先获取该Flash影片的引用：</p>\n<pre><code>function getFlashMovieObject(movieName){\n  if (window.document[movieName]){\n    return window.document[movieName];\n  }else if (navigator.appName.indexOf(&quot;Microsoft&quot;)==-1){\n    if (document.embeds &amp;&amp; document.embeds[movieName])\n      return document.embeds[movieName];\n</code></pre>","path":"2013-08-05-javascript-flash-comunication.json","year":"2013","month":"08","day":"05","tags":["前端"]},{"link":"/posts/2013/08/04/high-performance-javascript-read-note.html","title":"High Performance JavaScript 读书笔记之 数据存取","summary":"<p>今天再来一篇有关提高性能的读书笔记。标题中的数据存储，说白了就是JavaScript中获取与设置数据的方式，例如局部变量、全局变量、对象属性、数组等。大家有没有想过函数或者方法中使用以上的不同方式存取数据对性能造成的影响也是不一样的呢？</p>\n<h3 id=\"-\">变量</h3>\n<p>当数据存储在局部变量中，读取与写入的方式都是最快的。这是由于局部变量存放在作用域链的最顶层。当变量出现在特定的作用域链中，对作用域链的遍历就可以停止了，减少遍历作用域链的性能开销。与之相反的就是全局变量。全局变量放置在全局作用域中，这个作用域处于作用域链的最底层。当反复引用全局变量的时候，每次引用都要完整遍历整个作用域链（当然，某些现代浏览器会对代码进行解析型的编译优化如此问题，但是我们还是要兼容那些古老的浏览器，难道不是吗？），这样会造成额外的开销。</p>\n<p>还有一些语句会对作用域链做动态的修改。例如<code>with</code>，会在作用域链的顶端加入一个临时的作用域，包含<code>with</code>参数中的对象的所有属性。又如<code>try-catch</code>中<code>catch</code>字句，会在作用域链的顶端加入一个临时作用域，加入错误对象。这些语句都会造成作用域链的长度增加，也增加了遍历作用域链的性能开销。</p>\n<p>闭包也会对变量的读取和写入造成性能影响。当闭包的内部函数被执行的时候，它的作用域链是由内部函数的活动对象加上外部函数的作用域链合并而成。当闭包的嵌套层数很深，查找一个变量也会去遍历这个很深的作用域链，造成性能消耗。</p>\n<p>对于<code>with</code>，尽量不使用。对于<code>try-catch</code>，不要把它作为JavaScript的异常处理机制。更合理的做法是在代码中尽量避免抛出异常，手工处理异常分支，只把<code>try-catch</code>当作最后的安全手段。</p>\n<p>对于访问和修改全局变量或者是闭包变量，所做的优化就是使用一个局部变量把相关的全局变量和闭包变量引入到函数的内部，当需要使用这些变量的时候使用局部变量的引用，减少遍历作用域链的次数。</p>\n<p>虽然以上的优化效果有限，但是当函数被频繁执行的时候效果就会很明显了。当然，这些优化可以交给以后的编译器或者部署工具（JavaScript压缩工具等），但是在没有这些工具、没有浏览器JavaScript引擎优化的情况下，在性能需求非常高的场景，我们也要注意这些细节。</p>\n<h3 id=\"-\">属性</h3>\n<p>数据也可以作为一个对象的属性进行访问或者写入。我们知道，JavaScript中的对象是通过原型的方式来模拟OO中的继承关系。在一个对象中访问某个属性，需要遍历原型链去查找某个属性是否存在。这样意味着一个没有<code>toString</code>方法的对象调用像<code>Object</code>的<code>toString</code>方法，需要遍历整个原型链才能找到这个方法，然后才能执行。当原型链很深的时候，调用原型上的方法需要更多次数的遍历，也会造成额外的性能开销。</p>\n<p>对于属性上的优化，思想跟变量是一致的：使用一个局部变量“缓存”这些方法的属性。这样能把相关属性提高到作用域链的最顶端，当访问的时候直接访问局部变量，就不需要再去原型链中查找了。<strong>注意，对象上的方法最好不要使用这中方式缓存，可能会造成执行上下文的改变，需要使用<code>call</code>或者<code>apply</code>去手工控制方法的执行上下文才能保证逻辑的正确性。</strong></p>\n","path":"2013-08-04-high-performance-javascript-read-note.json","year":"2013","month":"08","day":"04","tags":["JavaScript"]},{"link":"/posts/2013/08/03/yahoo-performance-rules.html","title":"Yahoo!性能优化规则","summary":"<p>最近接二连三地被问到有做过什么性能优化的东西，感觉之前做了很多都没有仔细总结积累下来，到用的时候还得拼命去想这些规则。现在就先看看Yslow里面的性能优化规则吧，以作参考。</p>\n<h3 id=\"-http-\">减少HTTP请求</h3>\n<p>由于请求一个外部的JavaScript或者样式表需要发送一个HTTP请求，而建立HTTP请求、接收响应这个过程会带来一些性能的开销。应该尽量避免发送太多HTTP请求，减少建立请求时造成的不必要的开销。以下是几个减少HTTP请求的方法：</p>\n<ol>\n<li>合并JavaScript脚本和样式表。当页面应用的脚本跟样式表的个数比较多的时候会发送等量的HTTP请求或者这些文件的内容。可以在部署的时候静态打包出合并后的release文件，或者运行时状态下动态合并相关的脚本与样式表。</li>\n<li>CSS Sprites，结合<code>background-image</code>和<code>background-position</code>这两个CSS样式可以把一系列的小背景图（例如图标）全部合并到一个文件上面，减少不同样式获取背景图片的时候发送的HTTP请求。</li>\n<li>Image Map，把多个图片合并到一个图片中，使用<code>coords</code>属性限制图片的显示区域，与CSS Sprites类似。</li>\n<li><code>data:URL</code>，把一些小图片的内容直接通过这个属性内联到<code>img</code>标签中，这样这个图片就不需要额外发送一个HTTP请求了。</li>\n</ol>\n<h3 id=\"-cdn-\">使用CDN内容分发网络</h3>\n<p>超过80%的响应时间消耗在等待内容下载的阶段，例如外部JavaScript脚本、CSS样式表等。所以静态资源存放在哪也影响到网站响应的效率。CDN可以帮助用户从最效率的服务器（例如地理位置最近、网络延迟最少等）返回对应的静态资源，保证静态资源的下载效率最高。这个工作在网站上线之后是最容易操作的，但是也比较容易被忽略。</p>\n<p>这里吐槽一句，由于在我司做的项目都是基于内网用户的，所以这个没法使用CDN，相信使用了CDN之后还可能造成性能下降（囧）。</p>\n<h3 id=\"-\">激活缓存机制</h3>\n<p>通过配置HTTP头<code>Expires</code>或者<code>Cache-Controll</code>可以激活缓存机制。由于静态资源已经被存放到缓存中，下次请求同样的资源的时候可以直接读取缓存的内容，减少多次重复请求的资源的下载量。</p>\n<p>这个工作可以在页面上增加对应的<code>meta</code>或者在Web容器中配置对应的HTTP头去控制缓存的机制，包括过期时间等。</p>\n","path":"2013-08-03-yahoo-performance-rules.json","year":"2013","month":"08","day":"03","tags":["前端"]},{"link":"/posts/2013/08/02/javascript-bind-event-handler.html","title":"三种原生JavaScript绑定事件方式对比","summary":"<p>今天又被问到三种原生JavaScript绑定事件的方式有什么不一样。感觉自己答不全啊，惭愧。晚上立马来恶补一下它们究竟有什么区别。下文主要从执行上下文（<code>this</code>）、返回值等几个方面说明三者的区别。</p>\n<h3 id=\"html-onclick-\">HTML标签上面的<code>onclick</code>特性</h3>\n<p>曾经有那么一个时候，以下这种事件绑定的方式使用频率最高：</p>\n<pre><code>&lt;input type=&quot;button&quot; value=&quot;Click me!&quot; onclick=&quot;alert(&#39;Hello World&#39;);&quot; /&gt;\n</code></pre><p>当单击按钮的时候会弹出一个消息框。先来看看这个事件处理程序的特点：</p>\n<ol>\n<li>执行上下文是DOM元素。而MDN上面说的是<code>window</code>对象。</li>\n<li>当返回值是<code>false</code>的时候阻止默认行为，但不阻止事件传播。</li>\n<li>事件的传播只能是冒泡的。</li>\n</ol>\n<p>对于第一点MDN说的情况我猜是这样的，假如有以下代码：</p>\n<pre><code>&lt;input type=&quot;button&quot; value=&quot;Click me!&quot; onclick=&quot;doSomething();&quot; /&gt;\n</code></pre><p>JavaScript：</p>\n<pre><code>function doSomething() { alert(this === window); } // true\n</code></pre>","path":"2013-08-02-javascript-bind-event-handler.json","year":"2013","month":"08","day":"02","tags":["JavaScript"]},{"link":"/posts/2013/08/01/javascript-typeof.html","title":"JavaScript typeof操作符","summary":"<p>昨天讨论<code>instanceof</code>运算符，其中有一个比较坑的限制是，当使用iframe的时候可能会有意想不到的场景：</p>\n<pre><code>var a = [];\nalert(a instanceof top.Array); // 当这段代码出现在iframe里面的时候是false\n</code></pre><p>原因很简单，就是<code>window.Array</code>跟<code>top.Array</code>是两个不同的对象。虽然我们写代码的时候不会像上面那样显式地引用<code>top.Array</code>，但是在iframe集成的场景下我们可能会这么调用：</p>\n<pre><code>if (isArray(a)) { ... }\n</code></pre><p>而<code>isArray</code>可能会这么写：</p>\n<pre><code>function isArray(a) { return top.isArray(a); }\n</code></pre><p>这样就会出现上述的坑爹问题。今天来讨论另外一个检测JavaScript变量的运算符<code>typeof</code>，看它是否能解决以上这个坑爹的问题。</p>\n<blockquote>\n<p>typeof操作符返回一个字符串，代表一个未估值的操作数(unevaluated operand)的类型。</p>\n</blockquote>\n<p><code>typeof</code>接受一个操作数和一对可选的括号，返回表示该操作数的类型的字符串，操作数可以是字符串、对象、数字甚至是未定义的变量等。</p>\n<p><code>typeof</code>运算符能返回以下表示操作数类型的字符串：</p>\n<ol>\n<li><code>undefined</code>，操作数是未定义的变量或者属性，例如<code>undefined</code>，或者<code>var a = {}; alert(typeof a.foo);</code>。</li>\n</ol>\n","path":"2013-08-01-javascript-typeof.json","year":"2013","month":"08","day":"01","tags":["JavaScript"]},{"link":"/posts/2013/07/31/javascript-instanceof.html","title":"JavaScript instanceof操作符","summary":"<p>JavaScript中的<code>instanceof</code>操作符通常是用来判断一个对象是否具体“类型”的“实例”，比较常见的用法是：</p>\n<pre><code>if (obj instanceof Array) { ... }\n</code></pre><p>大家有没有想过这个<code>instanceof</code>操作符是怎么判断一个对象是否一个“类型”的实例呢？</p>\n<blockquote>\n<p>instanceof运算符可以用来判断某个构造函数的prototype属性是否存在另外一个要检测对象的原型链上。</p>\n</blockquote>\n<p>通常来说，一个<code>obj instanceof c</code>中，会比较<code>obj</code>的<code>__proto__</code>是否存在于<code>c</code>的原型链上。在<a href=\"http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/\">JavaScript instanceof 运算符深入剖析</a>中有一段JavaScript代码模拟了<code>instanceof</code>的执行过程：</p>\n<pre><code>function instance_of(L, R) {//L 表示左表达式，R 表示右表达式\n  var O = R.prototype;// 取 R 的显示原型\n  L = L.__proto__;// 取 L 的隐式原型\n  while (true) { \n    if (L === null) \n      return false; \n    if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true \n      return true; \n    L = L.__proto__; \n  } \n} \n</code></pre>","path":"2013-07-31-javascript-instanceof.json","year":"2013","month":"07","day":"31","tags":["JavaScript"]},{"link":"/posts/2013/07/30/beforeunload-event.html","title":"beforeunload事件","summary":"<p>去jsFiddle写代码片段的时候，如果没保存又去关闭浏览器的话，会弹出一个浏览器自带的消息框，提示是否要离开这个编辑中的页面。这种类似的功能使用的就是<code>beforeunload</code>这个事件。</p>\n<blockquote>\n<p>The beforeunload event is fired when the window, the document and its resources are about to be unloaded.</p>\n</blockquote>\n<p>这个事件在页面即将被unload的时候触发，并可以通过返回值告诉浏览器是否要弹出消息框。如果返回非空字符串，则浏览器会弹出消息框，并显示返回的字符串；否则这个事件的处理程序会静默地执行。</p>\n<p>注意，这个事件不能让浏览器跳转到某个URL，例如以下的代码是无效的，例子<a href=\"http://jsfiddle.net/wpMpa/5/show/\">参考这里</a>：</p>\n<pre><code>$(window).on(&quot;beforeunload&quot;, function () {\n  window.location.href = &quot;http://some.other.site&quot;; // 这句代码没有任何作用\n  return &quot;Are you sure to leave?&quot;;\n});\n</code></pre><p>还有一个值得注意的地方是，FireFox、IE跟Safari、Chrome对显示信息的处理方式也不一样。前者是通过事件对象的<code>returnValue</code>属性去控制显示信息，而后者则是通过<code>return</code>返回的字符串控制显示信息。以下是一个兼容多个浏览器的写法：</p>\n<pre><code>window.addEventListener(&quot;beforeunload&quot;, function (e) {\n  var confirmationMessage = &quot;\\o/&quot;;\n  (e || window.event).returnValue = confirmationMessage;     //Gecko + IE\n  return confirmationMessage;                                //Webkit, Safari, Chrome etc.\n});\n</code></pre><p>这个事件的效果不能通过弹出自定义的对话框（例如jQuery UI中的dialog）来模拟同样的效果哦。如果不需要弹出确认框，又需要在页面卸载的时候处理一些逻辑，例如垃圾回收之类的操作，那最好还是绑定<code>unload</code>事件。以后也会继续讨论<code>unload</code>事件的用法。</p>\n","path":"2013-07-30-beforeunload-event.json","year":"2013","month":"07","day":"30","tags":["JavaScript"]},{"link":"/posts/2013/07/29/html-link-tag.html","title":"HTML LINK 标签","summary":"<p>我们平常用的最多的<code>link</code>标签就是引入外部的样式文件。大家有没有想过其实<code>link</code>还有别的作用。今天就来看看<code>link</code>究竟还能做些什么东西。</p>\n<blockquote>\n<p>The HTML link Element specifies relationships between the current document and other documents. </p>\n</blockquote>\n<p>以上是MDN对<code>link</code>标签的解释。其实<code>link</code>标签就是声明文档与文档之间的关系，例如HTML与外部样式文件之间的关系就是<code>stylesheet</code>的关系。这个标签的属性有：</p>\n<ol>\n<li><code>charset</code>，声明被链接的文件使用的字符编码。<strong>注意，这个属性在HTML5中已经被HTML文档中的<code>Content-Type</code>头取代。</strong></li>\n<li><code>href</code>，声明被链接的文档的URI。</li>\n<li><code>hreflang</code>，声明被链接的文档的语言，在<code>href</code>的值不为空的时候才有效。</li>\n<li><code>type</code>，声明这个链接的MIME类型。例如平常使用的外部样式表就是<code>text/css</code>。</li>\n<li><code>rel</code>，声明被链接文档与该文档的关系。如<code>stylesheet</code>，更多的关系请留意下文。</li>\n<li><code>rev</code>，声明该文档与被链接文档的关系。</li>\n<li><code>media</code>，声明目标样式与设备的关系。响应式设计中的<code>media query</code>就是基于这个属性来进行媒体查询的。关于媒体查询会在以后的博客中作介绍。</li>\n</ol>\n<p>还有几个不是标准的属性，<strong>不是每个浏览器都支持哦</strong>：</p>\n<ol>\n<li><code>disabled</code>，声明链接是否可用，例如可以通过设置值为<code>false</code>禁用某个外部样式表。</li>\n<li><code>target</code>，声明在哪里加载这个外部文档，如<code>a</code>的<code>target</code>属性的取值。</li>\n</ol>\n<p>还有几个HTML5专用的属性：</p>\n<ol>\n<li><code>crossorigin</code>，声明这个<code>link</code>标签是否需要使用跨域请求（CROS）来获取。取值范围是<code>anonymous</code>（匿名访问）或者<code>use-credentials</code>（需要认证）。如果没有设置这个属性，则会以一般的请求来获取外部文档。</li>\n</ol>\n","path":"2013-07-29-html-link-tag.json","year":"2013","month":"07","day":"29","tags":["html"]},{"link":"/posts/2013/07/28/closure-usage-3.html","title":"Secrets of the JavaScript Ninja 读书笔记之 闭包（三）","summary":"<p>这次读书笔记的最后一篇。今天主要分享即时执行函数的作用。我们知道，在JavaScript中是没有块作用域的（例如<code>if</code>里面的块），唯一产生作用域的就是函数。常见的制造私有作用域的方法如以下代码所示：</p>\n<pre><code>(function () {...})();\n</code></pre><p>书中强调了两个括号有不同的作用。第一组括号其实是声明了运算的优先级，而第二组括号却是一个运算符，用来执行第一组括号中的匿名函数。比较有趣的用法是：</p>\n<pre><code>document.addEventListener(&quot;click&quot;, (function(){\n  var numClicks = 0;  \n  return function(){\n    alert( ++numClicks );\n  };\n})(), false);\n</code></pre><p>这里使用了闭包，为事件处理程序增加了一个<code>numClicks</code>的状态。这种写法适用于这个状态只是在这个事件处理程序中使用，可以减少外围作用域中的变量，也可以使代码更加简洁，层次更加清晰。</p>\n<p>通过给即时执行函数传入参数，可以解决一些重名冲突的问题。例如在即时执行函数中使用<code>$</code>来使用jQuery，而在外部则可以让<code>$</code>指向另外的变量（例如Prototype框架的<code>$</code>）：</p>\n<pre><code>(function ($, undefined) {...})(jQuery, undefined);\n</code></pre><p>这种方式也可以解决一些长变量名或者引用层次深的变量的引用问题，也可以帮助JavaScript代码压缩的时候提高压缩比，例如把<code>undefined</code>压缩成<code>a</code>等。</p>\n<p>书中也讲到了一个循环与闭包的常见问题，例如给一系列的DOM元素绑定事件处理程序（不使用jQuery）。通常我们使用<code>for</code>循环来绑定事件，要注意以下代码：</p>\n","path":"2013-07-28-closure-usage-3.json","year":"2013","month":"07","day":"28","tags":["JavaScript"]},{"link":"/posts/2013/07/27/closure-usage-2.html","title":"Secrets of the JavaScript Ninja 读书笔记之 闭包（二）","summary":"<p>今天接着分享JavaScript闭包的作用。</p>\n<h3 id=\"memorize\">Memorize</h3>\n<p>在一些需要频繁调用执行效率又比较低的方法可以使用Memorize这个方法，记录每次调用后的结果，下次传入相同的参数就可以直接返回缓存的结果，不需要重新再次执行其逻辑，提高执行效率。书中实现这个Memorize的代码如下：</p>\n<pre><code>Function.prototype.memoized = function(key){\n  this._values = this._values || {};\n  return this._values[key] !== undefined ?\n    this._values[key] :\n    this._values[key] = this.apply(this, arguments);\n  };\nFunction.prototype.memoize = function(){\n  var fn = this;                        \n  return function(){                           \n    return fn.memoized.apply( fn, arguments );\n  };\n};\n</code></pre><p>在<code>memoize</code>这个方法里面，使用闭包记录原始方法，在返回的新方法中让原来的方法附加上Memorize的特性。这样封装了Memorize的具体实现，而且使用起来非常方便，甚至可以为一个匿名方法添加Memorize的功能，如：</p>\n<pre><code>var func = (function (n) { ... }).memoize();\n</code></pre>","path":"2013-07-27-closure-usage-2.json","year":"2013","month":"07","day":"27","tags":["JavaScript"]},{"link":"/posts/2013/07/26/closure-usage.html","title":"Secrets of the JavaScript Ninja 读书笔记之 闭包（一）","summary":"<p>又到读书笔记的时候了！闭包，是JavaScript的重要特性之一，这里不聊什么是闭包，这篇文章主要关注闭包的作用。</p>\n<h3 id=\"-\">绑定函数的执行上下文</h3>\n<p>我们知道，为一个DOM元素绑定事件，无论使用原生的<code>addEventListener</code>或者jQuery的<code>on</code>，事件处理程序里面的上下文<code>this</code>都是DOM元素本身。如果把一个对象的方法作为事件处理程序绑定到DOM元素的某个事件上，而这个方法又使用了<code>this</code>引用这个对象的其他方法，这样触发事件执行处理程序的时候必然会出错。所以我们需要手动把事件处理程序的执行上下文<code>this</code>改变成这个对象本身，如：</p>\n<pre><code>if (!Function.prototype.bind) {\n  Function.prototype.bind = function (context){\n    var fn = this;\n    return function(){                                \n      return fn.apply(context,arguments);  \n    };                                                \n  }\n｝\n</code></pre><p>这里我作了一些小改动，在JavaScript 1.8.5中，<code>bind</code>已经是<code>Function</code>原型的方法了。通过闭包把原来的方法记录下来，在返回的匿名函数中调用原来方法的<code>apply</code>改变执行上下文<code>this</code>指向的对象，这样就可以手动地改变事件处理程序中的<code>this</code>。</p>\n<p>我个人更偏好于使用jQuery的<code>proxy</code>方法来做这个事情，如：</p>\n<pre><code>$(&quot;#id&quot;).on(&quot;click&quot;, $.proxy(obj.func, obj));\n</code></pre><p>保持对象（或者“类”的“实例”）方法中<code>this</code>的指向永远是该对象本身，对于面向对象的JavaScript来说我认为是十分必要的，可以增加一个“类”中代码的可读性与可维护性。</p>\n","path":"2013-07-26-closure-usage.json","year":"2013","month":"07","day":"26","tags":["JavaScript"]},{"link":"/posts/2013/07/25/http-method.html","title":"HTTP协议之HTTP方法","summary":"<p>今天看阿雄写代码，封装与服务器交互的相关工具方法。各种<code>get</code>、<code>post</code>、<code>put</code>、<code>del</code>的方法，对应各种HTTP方法。<code>get</code>和<code>post</code>不用说，看到<code>put</code>和<code>delete</code>的时候，阿雄说这两个方法的参数都不是放在请求体里面。奇怪了，按照常理来说对服务有影响的操作都应该把参数放到请求体里面啊（类似<code>post</code>），难道不是这样的？</p>\n<p>看W3的规范里面，HTTP协议能使用的方法大概有以下几种：</p>\n<ol>\n<li><code>OPTIONS</code>，列出当前服务器支持哪些HTTP方法（几乎没有人用这个HTTP方法，不过可以利用这个方法做自文档的Restful服务的查询方法，<a href=\"http://zacstewart.com/2012/04/14/http-options-method.html\">参考这里</a>）。</li>\n<li><code>GET</code>，最常用的HTTP方法之一，从服务器获取URI指定的资源。资源会放到响应体里面返回。<code>GET</code>方法获取数据应该是有缓存机制的，通过<code>If-Modified-Since</code>等HTTP头可以声明当前这个URI对应的信息是否发生变化，如果没有变化则可以使用之前的缓存信息，这样可以减少不必要的网络数据传输。当请求含有<code>Range</code>头的时候，这次<code>GET</code>请求所返回的信息是部分的，当分块下载的时候会用到。<strong>注意，<code>GET</code>请求的参数都是作为查询串放到URL后面，所以当请求参数含有敏感数据的时候千万不要用<code>GET</code>。</strong></li>\n<li><code>HEAD</code>，与<code>GET</code>类似，只是返回的响应体的内容是空的，只包含响应头。这个方法常用作校验有效性、校验权限以及查看信息是否被修改。</li>\n<li><code>POST</code>，往URI指定的路径新增一个资源。<code>POST</code>的参数是放在请求体里面的，一般这个参数就是声明了一个新的资源，例如文件夹里面的一个新文件、邮件列表里面的一个新邮箱或者数据表中的一条新的记录。与我们日常使用的场景不同，如果服务器没有增加新的资源，或者这个请求体是空的，应该返回状态码200或者204；如果服务器正确增加了一个新的资源，应该返回一个201表示资源已经被创建。而我们日常一般就是用200表示服务器已经正确处理请求而已。一般<code>POST</code>是不会缓存的，除非设置了<code>Cache-Control</code>或者<code>Expires</code>头。</li>\n<li><code>PUT</code>，分两种情况。如果URI指定的资源不存在，则当<code>POST</code>处理，往服务器新增一个指定的资源；如果存在，则修改现有的资源，修改成功返回状态码200或者204，修改失败则按照失败的具体原因返回5XX等状态码。</li>\n<li><code>DELETE</code>，删除URI指定的资源。</li>\n<li><code>TRACE</code>，对可能经过代理服务器传送到服务器上去的报文进行追踪。</li>\n<li><code>CONNECT</code>，一个保留的方法，指定代理改变发送请求时使用的协议，例如从HTTP到HTTPS。</li>\n</ol>\n<p>下面使用<code>jQuery.ajax</code>方法来看看真实场景下HTTP方法是如何运用的。例子<a href=\"http://jsfiddle.net/4Y8t2/2/show/\">参考这里</a>。</p>\n<p>例子非常简单，就是使用不同的HTTP方法往服务器发送HTTP请求。可以看到<code>GET</code>和<code>HEAD</code>的参数是放到查询串（search）上面的。其他方法一律是放到请求体里面。这个例子里面的<code>POST</code>、<code>PUT</code>和<code>DELETE</code>都被服务器拒绝了，返回状态码403（Forbidden）。</p>\n<p>有趣的是，同样一段代码，在IE9上面返回的结果跟Chrome上不一样。主要表现在<code>TRACE</code>和<code>CONNECT</code>上。IE9上的<code>TRACE</code>输出“参数无效”，<code>CONNECT</code>是403；而Chrome则都是输出一个“DOM Exception 18”，这个往后可以研究一下<code>jQuery.ajax</code>的具体实现才能看出什么端倪来。</p>\n","path":"2013-07-25-http-method.json","year":"2013","month":"07","day":"25","tags":["http"]},{"link":"/posts/2013/07/24/css-word-break.html","title":"换行还是不换行之word-break","summary":"<p>再继续前两天的问题，今天介绍另一个影响单词断行的CSS样式<code>word-break</code>。</p>\n<blockquote>\n<p>The word-break property specifies line breaking rules for non-CJK scripts.</p>\n</blockquote>\n<p><code>word-break</code>声明了非CJK单词的断行规则，其中也有属性值是跟CJK单词有关系。这个样式的可选取值有以下几个：</p>\n<ol>\n<li><code>normal</code>，默认值，单词根据其默认的规则进行断行。</li>\n<li><code>break-all</code>，非CJK单词会在一个单词之间断行以防止单词内容溢出。</li>\n<li><code>keep-all</code>，保持CJK单词，不让其断行。</li>\n</ol>\n<p>看样子跟昨天介绍的<code>word-wrap</code>看上去作用都是差不多的，都是控制单词的断行规则。与<code>word-wrap</code>类似，<strong>当<code>white-space</code>声明为不允许自动换行的情况下是没有任何效果的</strong>。</p>\n<p>而<code>word-break</code>跟<code>word-wrap</code>主要有以下这几个不同点：</p>\n<ol>\n<li>Opera和低版本的FireFox（低于15）不支持<code>word-break</code>，而所有主流的浏览器都支持<code>word-wrap</code>。</li>\n<li>虽然<code>word-break: break-all</code>和<code>word-wrap: break-word</code>都是允许断开非CJK单词，但是前者明显暴力于后者。前者会忽略所有排版规则强制断开单词，而后者则会尽最大限度保持现有的排版规则。例子<a href=\"http://jsfiddle.net/RsUqv/\">参考这里</a>。</li>\n<li><code>word-break: keep-all</code>还特别声明了针对CJK单词的规则，这个是<code>word-wrap</code>所没有的。<em>（但是<code>keep-all</code>Chrome和Safari都不支持……）。</em></li>\n</ol>\n<p>针对<code>word-break</code>：</p>\n<ol>\n<li>当需要强制换行时，设置成<code>break-all</code>。</li>\n<li>当需要强制不换行时，设置成<code>normal</code>。</li>\n</ol>\n","path":"2013-07-24-css-word-break.json","year":"2013","month":"07","day":"24","tags":["css"]},{"link":"/posts/2013/07/23/css-word-wrap.html","title":"换行还是不换行之word-wrap","summary":"<p>继续昨天的话题，今天介绍另一个影响文字换行的属性<code>word-wrap</code>。</p>\n<blockquote>\n<p>This property specifies whether the UA may arbitrarily break within a word to prevent overflow when an otherwise-unbreakable string is too long to fit within the line box. <strong>It only has an effect when ‘white-space’ allows wrapping.</strong></p>\n</blockquote>\n<p><code>word-wrap</code>这个属性声明用户代理（一般就是指浏览器）能否从一个单词中间断开，防止这个单词溢出容器。这里值得注意的是，要<code>word-wrap</code>属性生效，必须让<code>white-space</code>这个属性允许自动换行（即<code>white-space</code>的属性只能是<code>normal</code>、<code>pre-wrap</code>和<code>pre-line</code>）。</p>\n<p>可选的取值有：</p>\n<ol>\n<li><code>normal</code>，默认值，不允许从一个单词中间断开，显示溢出部分。</li>\n<li><code>break-word</code>，如果一行中没有其他可接受的断点，那么将强行断开文本单词。</li>\n</ol>\n<p>这里的“单词”，指的是非CJK（Chinese、Japanese、Korean）中由若干个字母组成的单词。这个单词是有独立意义的，不同单词使用空格或者<code>-</code>分开。所以如果随意把超长的单词从中间断开，可能会导致理解上的误差。例子<a href=\"http://jsfiddle.net/VKP78/\">参考这里</a>。</p>\n<p>这个属性所有浏览器都支持。IE引入了一个别名叫<code>-ms-word-wrap</code>，在标准的IE8里面已经支持标准的<code>word-wrap</code>，所以也不需要加上这个前缀了。</p>\n<p>还有一个值得注意的是，在最近的CSS3规范中，<code>word-wrap</code>已经被改名叫<code>overflow-wrap</code>了，在最新的Chrome和Opera中已经支持新名字了哦。在往后的标准实现中，<code>word-wrap</code>只能作为<code>overflow-wrap</code>的一个别名存在，太悲催了。</p>\n<p>总结一下，在<code>white-space</code>声明支持自动换行的情况下：</p>\n<ol>\n<li><code>normal</code>不会中断一个非CJK单词。</li>\n<li><code>break-wrod</code>会最大限度维持排版规则去中断溢出的非CJK单词。</li>\n</ol>\n","path":"2013-07-23-css-word-wrap.json","year":"2013","month":"07","day":"23","tags":["css"]},{"link":"/posts/2013/07/22/css-white-space.html","title":"换行还是不换行之white-space","summary":"<p>今天又给一个换行还是不换行的问题困扰了。决定好好地研究一下块元素中的行内元素是如何控制换行的。主要从几个CSS样式入手，包括<code>white-space</code>、<code>word-break</code>等，最后会综合讨论块元素的其他CSS是如何影响行内元素的换行控制。</p>\n<p>今天先看看<code>white-space</code>这个CSS属性。</p>\n<blockquote>\n<p>The white-space property specifies how white-space inside an element is handled.</p>\n</blockquote>\n<p><code>white-space</code>这个属性是用来声明一个元素内部的空白（包括空格还有换行符等）是如何处理的。可选的取值有以下几个：</p>\n<ol>\n<li><code>normal</code>，默认值，合并所有空白，当内容接触容器元素边界的时候自动换行。</li>\n<li><code>nowrap</code>，与<code>normal</code>类似，只是不会自动换行<strong>（强制不换行必须配上这个CSS样式）</strong>。</li>\n<li><code>pre</code>，保留所有空白，也不会自动换行。</li>\n<li><code>pre-wrap</code>，保留所有空白，会自动换行。</li>\n<li><code>pre-line</code>，除了换行符之外的空格合并，会自动换行。</li>\n<li><code>inherit</code>，继承父元素的值。</li>\n</ol>\n<p>对于行内元素来说：</p>\n<ol>\n<li>当值是<code>normal</code>、<code>nowrap</code>和<code>pre-line</code>的时候，换行符前后的空白会被删除。</li>\n<li>当值是<code>pre</code>和<code>pre-wrap</code>的时候，多个空格组成的序列不会在遇到元素边缘的时候被中断。而<code>pre-wrap</code>则会在序列的最后自动换行。</li>\n<li>当值是<code>normal</code>和<code>nowrap</code>的时候，换行符会被转化成一个空格、一个长度为0的字符串或者压根不显示，具体如何转化需要看浏览器的实现算法。</li>\n<li>当值是<code>normal</code>、<code>nowrap</code>和<code>pre-line</code>的时候，制表符会被转化成一个空格，多个连续的空格会被归并成一个空格。</li>\n</ol>\n","path":"2013-07-22-css-white-space.json","year":"2013","month":"07","day":"22","tags":["css"]},{"link":"/posts/2013/07/21/a-http-request.html","title":"HTTP协议之简述一个HTTP请求的经过","summary":"<p>之前已经科普过HTTP的请求/响应头还有HTTP状态码，今天简单的看看一个HTTP请求的过程。</p>\n<p>先来根据W3的HTTP 1.1官方规范来看一些术语：</p>\n<ol>\n<li>连接（connection），指的是两个程序为了通讯而建立的一个“虚拟”的通道。</li>\n<li>客户端（client），指的是发出HTTP请求的一方。</li>\n<li>服务端（server），指的是接收HTTP请求并返回HTTP响应的一方。</li>\n<li>代理（proxy），指的是接收HTTP请求，作出一些处理（例如翻译），然后发送HTTP请求到某个特定的服务端的中间件。</li>\n<li>网关（gateway），与代理类似，不过它更着重于一个“关口”的概念，把接收到的HTTP请求继续传递给其下级子网来进行处理。</li>\n<li>隧道（tunnel），与代理类似，不过它更着重于一个“透传”的概念，把接收到HTTP请求直接透传到某个特定的服务端中间件。</li>\n<li>缓存（cache），一个本地存储及其管理系统，程序可以根据特定的机制决定是否在服务端真正地进行处理作为响应还是直接读取本地存储中的内容作为响应。</li>\n</ol>\n<p>术语还有很多，详情可以<a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec1.html\">参考这里</a>。同学们如果发现英文翻译有误的请赶紧拍砖啊。</p>\n<p>现在来看看一个HTTP请求究竟经历了哪些步骤：</p>\n<ol>\n<li>建立连接，客户端会根据服务器的ip地址和端口号与服务器建立socket连接。</li>\n<li>客户端发送一个HTTP请求，里面的HTTP请求头会包含一些这个请求的信息，例如URI、HTTP方法等。</li>\n<li>服务器根据请求的内容进行处理，并返回一个HTTP响应。</li>\n<li>客户端接收HTTP响应，关闭socket连接。</li>\n</ol>\n<p>这样，一个最简单的HTTP请求就完成了。现实中的场景可能会比较复杂，例如一个HTTP请求，经过N个中间件（例如代理、网关和隧道），转发了N+1这么多次才到达真正要处理这个请求的服务器。而每一个中间件也有可能把接收到的HTTP请求进行转发，转发到更多的服务器上面进行处理。</p>\n","path":"2013-07-21-a-http-request.json","year":"2013","month":"07","day":"21","tags":["http"]},{"link":"/posts/2013/07/20/javascript-overload.html","title":"Secrets of the JavaScript Ninja 读书笔记之 JavaScript重载","summary":"<p>今天来点轻松的，分享一个之前的读书笔记。我们知道，JavaScript是不支持重载的。后面定义的重名函数，无论参数的个数是否一样，都会把前面已经定义的重名函数给覆盖掉。要想实现类似Java中的重载机制，一般只能把所有的逻辑都写在同一个函数里，类似这样：</p>\n<pre><code>var ninja = {\n    whatever: function() {\n        switch (arguments.length) {\n        case 0:\n            /* do something */\n            break;\n        case 1:\n            /* do something else */\n            break;\n        case 2:\n            /* do yet something else */\n            break;\n        //and so on ...\n        }\n    }\n}\n</code></pre><p>根据<code>arguments.length</code>这个属性，可以判断当前调用这个函数的时候传入了多少个参数，根据参数的个数判断应该执行什么逻辑。这种方式虽然简单，但是如果以后扩展的时候需要再增加一个重载的逻辑，就需要增加一个<code>case</code>分支，这样是违背了开放封闭原则的，提高了维护的成本（估计大家也不想看到铺天盖地的<code>case</code>）。</p>\n<p>为了解决这个问题，我们尝试使用一种新的思路去分析。首先，需要提供自定义的重载机制，例如：</p>\n","path":"2013-07-20-javascript-overload.json","year":"2013","month":"07","day":"20","tags":["JavaScript"]},{"link":"/posts/2013/07/19/css-equal-height-again.html","title":"再谈CSS等高布局","summary":"<p>之前写过一篇CSS等高布局相关的文章，讲的是使用负外边距和内边距的相互抵消做出来的一个“障眼法”。大湿看过之后立马表示有更科学的办法实现，就是CSS3的<code>box-flex</code>。今天再来回顾一下到底还有什么方法实现CSS等高布局。</p>\n<h3 id=\"display-box\">display: box</h3>\n<p>通过<code>display: box</code>声明该元素的盒模型是一个弹性的盒模型，与CSS2中的盒模型是不一样的。其内部元素可以通过设置<code>box-flex</code>来声明其空间占的比例是多少。</p>\n<p>简单看一下声明了<code>display: box</code>之后该元素还能设置CSS属性：</p>\n<ol>\n<li><code>box-orient</code>，声明其内部元素的排列方向，可选的值有<code>horizontal</code>、<code>vertical</code>、<code>inline-axis</code>、<code>block-axis</code>、<code>inherit</code>。默认值是<code>inline-axis</code>，所以在<code>diplay: box</code>元素内部的子元素都会表现得像行内元素一般的行为。</li>\n<li><code>box-direction</code>，声明其内部元素的排列顺序，可选的值有<code>normal</code>、<code>reverse</code>、<code>inherit</code>。通过设置<code>reverse</code>可以把元素的顺序反转过来。</li>\n<li><code>box-align</code>，声明其内部元素的垂直对齐方式（有点类似<code>vertical-align</code>），可选的值有<code>start</code>、<code>end</code>、<code>center</code>、<code>baseline</code>、<code>stretch</code>。<strong>默认值<code>stretch</code>就是拉伸其子元素让其高度（或者宽度）一致，所以在<code>display: box</code>下使用<code>box-flex</code>就可以做出等高的效果。</strong></li>\n<li><code>box-pack</code>，声明其内部元素的对齐方式（有点类似<code>text-align</code>），可选的值有<code>start</code>、<code>end</code>、<code>center</code>、<code>justify</code>。</li>\n</ol>\n<p><code>box-flex</code>用来声明子元素占父元素内部的空间，其值是一个大于1的整数。当一个弹性盒模型计算其内部元素占用的空间时，优先计算显式声明了<code>width</code>（以默认排列方向为例）的元素，其占用的空间就是<code>width</code>声明的空间。然后根据<code>box-flex</code>这个属性的权重值去设置该子元素的占用的空间。</p>\n<p>一个简单的例子<a href=\"http://jsfiddle.net/gt8rN/1/\">参考这里</a>。</p>\n<p>这个方法的优点是代码简洁、功能强大。缺点则是CSS3面临的其中一个严重的缺点：老版本的IE不支持CSS3（甚至IE9也不支持，太惨烈了）。</p>\n<h3 id=\"display-table\">display: table</h3>\n<p>看了这个标题，仿佛又回到了那个使用<code>table</code>做布局的石器时代。很多人反对使用<code>table</code>作为布局工具，但是有没有想过究竟为什么不使用<code>table</code>来布局？因为<code>table</code>布局不具有语义。这个不是一个表，是一个布局，所以用<code>table</code>是不合适的。但是反过来看，这里说的<code>table</code>只得是HTML中的<code>table</code>标签。可以通过CSS，使元素能像表格一样布局，而又可以保持元素原来的语义，这样何乐而不为呢？</p>\n","path":"2013-07-19-css-equal-height-again.json","year":"2013","month":"07","day":"19","tags":["css"]},{"link":"/posts/2013/07/18/negative-margin.html","title":"神奇的负边距","summary":"<p>之前写过一篇<a href=\"http://dafeizizhu.github.io/2013/07/08/three-column-layout-middle-first/\">《经典三列布局之如何让中间的列先显示出来》</a>，里面讲的就是使用浮动、相对定位和负边距来做的一套布局。写那篇文章的时候还没太搞懂负边距是怎么回事，今天简单分析一下对不同元素（正常、浮动、绝对定位等）的负边距是如何起作用的。</p>\n<p>首先明确几点：</p>\n<ol>\n<li>负边距是完全合法的CSS写法，W3允许边距的值是负值。</li>\n<li>负边距不属于CSS hack。</li>\n<li>a负边距不会使元素脱离文档流。</li>\n<li>所有现代浏览器都支持负边距（IE6也部分支持，太棒了！）。</li>\n</ol>\n<p>简单看看负边距的工作原理：</p>\n<ol>\n<li>在<code>top</code>和<code>left</code>方向上应用负边距，该元素会向指定的方向移动，随后的元素也会跟着一起移动。</li>\n<li>在<code>bottom</code>和<code>right</code>方向上应用负边距，该元素的位置不会发生任何移动，但是随后的元素会挤压过来，看上去的效果就是该元素占的空间变小了。</li>\n<li>当该元素没有应用宽度（<code>width: auto</code>也算），为该元素设置<code>left</code>和<code>right</code>方向上的负边距会让元素的宽度边大。</li>\n</ol>\n<p>负边距有什么用呢？其中最重要的一个作用我认为是把DOM树中较后出现的元素显示在页面较前的位置。我们知道HTML解析DOM树的时候是根据书写的顺序解析的。而文档的解析顺序是从上到下，从左到右（当然方向是<code>ltr</code>）的，那么正常书写的N列布局肯定是第一列写在最前边，但是可能我们需要中间第n列先解析，这时候就要把第n列的内容书写在前边，通过负边距调整位置，达到理想的效果。</p>\n<p>现在分析一下之前写过的那篇文章中，左列的CSS究竟是如何达到最后的效果的。现来看看左列的CSS代码。</p>\n<pre><code>#left {\n    position: relative; // 1\n    left: -100px;       // 2\n</code></pre>","path":"2013-07-18-negative-margin.json","year":"2013","month":"07","day":"18","tags":["css"]},{"link":"/posts/2013/07/17/viewport.html","title":"响应式设计入门之viewport","summary":"<p>今天为我的博客加入了一些响应式设计的要素，现在妈妈再也不用担心我的微信中阅读原文之后布局全乱了。说白了就是使用了两个响应式设计相关的技术：<code>viewport</code>和<code>media query</code>而已。今天先写一下为什么需要viewport，viewport这个东西怎么用。</p>\n<h3 id=\"-\">背景</h3>\n<p>先看看w3的定义：</p>\n<blockquote>\n<p>This specification introduces a way of overriding the size of the viewport provided by the user agent (UA).</p>\n</blockquote>\n<p>由于移动终端的分辨率一般比桌面浏览器的分辨率要小，移动终端上的浏览器通常会把页面放入一个虚拟的“视口“中，让页面的内容缩小以适配该移动终端的分辨率，用户可以通过缩放和移动来查看整个页面的全部内容。Safari引入<code>viewport</code>这个<code>meta</code>头，旨在让开发人员控制视口的大小和缩放。</p>\n<p><strong>注：<code>body</code>元素（如果不是HTML和XHTML的文档则是根元素）中的<code>direction</code>会影响缩放时的原点（<code>ltr</code>是左上角，<code>rtl</code>是右上角）。</strong></p>\n<h3 id=\"-\">用法</h3>\n<p>来个最简单的<code>viewport</code>使用例子：</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;\n</code></pre><p>声明一个<code>meta</code>头，<code>name</code>是<code>viewport</code>，其中的<code>content</code>是一个逗号分隔的键值对列表。可供设置的键值对有：</p>\n<ol>\n<li><code>width</code>，视口宽度，数字表示绝对宽度，如<code>width=900</code>，也可以使用字符串常量<code>device-width</code>表示设备的横向分辨率。在iOS的Safari上默认值是980。</li>\n<li><code>height</code>，视口宽度，与<code>width</code>类似。</li>\n</ol>\n","path":"2013-07-17-viewport.json","year":"2013","month":"07","day":"17","tags":["css"]},{"link":"/posts/2013/07/16/css-equal-hight.html","title":"CSS等高布局","summary":"<p>今天本来想写express的，不过还没看清楚它的文档，以免误人子弟，先放一下。今天来写一个以前遗留的问题，CSS三列布局如何等高。</p>\n<p>接着上次写的“经典三列布局之如何让中间的列先显示出来“的代码，<a href=\"http://jsfiddle.net/zBXbp/7/\">参考这里</a>：</p>\n<p>HTML：</p>\n<pre><code>&lt;div id=&quot;container&quot;&gt;\n    &lt;div id=&quot;middle&quot;&gt;This is middle!&lt;/div&gt;\n    &lt;div id=&quot;left&quot;&gt;This is left!&lt;/div&gt;\n    &lt;div id=&quot;right&quot;&gt;This is right!&lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>CSS：</p>\n<pre><code>#left { width: 100px; background: red;}\n#right { width: 100px; background: blue;}\n#middle { width: 100%; background: green;}\n\n#container { \n    position: relative;\n    padding: 0 100px;\n    overflow: hidden;\n</code></pre>","path":"2013-07-16-css-equal-hight.json","year":"2013","month":"07","day":"16","tags":["css"]},{"link":"/posts/2013/07/15/event-constructor-and-jquery-trigger.html","title":"模拟触发DOM事件之jQuery trigger","summary":"<p>昨天写了一下<code>document.createEvent</code>这个方法，并描述了如何使用该方法模拟DOM事件。今天看看MDN建议的<code>Event</code>构造函数，以及jQuery是如何处理<code>trigger</code>的。</p>\n<p><code>Event</code>构造函数接受两个参数：</p>\n<ol>\n<li>表示事件类型的字符串，如<code>click</code>、<code>change</code>甚至是自定义的字符串。</li>\n<li>事件的附加属性，用一个JavaScript对象表示，如<code>{ &quot;a&quot;: &quot;something additional&quot; }</code>。</li>\n</ol>\n<p>由于简化了事件附加属性的设置，不需要像<code>document.createEvent</code>那样分开各种事件类型，并且使用不同的<code>init</code>方法。下面给出一个MDN上面的例子：</p>\n<pre><code>var event = new Event(&#39;build&#39;);\n\n// Listen for the event.\nelem.addEventListener(&#39;build&#39;, function (e) { ... }, false);\n\n// Dispatch the event.\nelem.dispatchEvent(event);\n</code></pre><p><code>Event</code>构造函数在绝大部分的现代浏览器里面都支持（IE9也支持，可怜的IE8）。如果要兼容老版本的IE浏览器，需要使用昨天的<code>document.createEvent</code>方法。</p>\n<p>现在来看看jQuery的<code>trigger</code>方法，是如何实现跨浏览器模拟触发DOM事件的。</p>\n<p>看了源码我震惊了，jQuery完全没有使用上述任何一个API，包括<code>document.createEvent</code>和<code>Event</code>构造函数。jQuery使用的是自定义的事件对象<code>jQuery.Event</code>，里面包括了原生事件里面的所有属性和方法（封装了浏览器的差异），以及一些jQuery的扩展属性。当使用<code>trigger</code>时，jQuery会遍历这个DOM元素的事件冒泡路径，就是这个DOM元素在DOM树里面的完整路径。然后收集在DOM树上所有这个事件的处理程序，根据冒泡的顺序触发对应的事件处理程序。整个过程都没有使用DOM原生的模拟事件。</p>\n","path":"2013-07-15-event-constructor-and-jquery-trigger.json","year":"2013","month":"07","day":"15","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/07/14/simulate-event.html","title":"模拟触发DOM事件之原生模拟事件","summary":"<p>昨天讲到一个如何在测试的时候模拟一个DOM事件，例如单击鼠标、输入文字等。当时我第一反应就是使用jQuery的<code>trigger</code>方法触发事件，那哥们竟然说了一个原生的API：<code>document.createEvent</code>。当时我就震惊了，为啥不用jQuery哦亲。今天先简单了解一下这个API的作用，科普科普。</p>\n<p>先看看MDN上面对<code>document.createEvent</code>的说明是啥：</p>\n<blockquote>\n<p>Creates an event of the type specified. The returned object should be first initialized and can then be passed to element.dispatchEvent.</p>\n</blockquote>\n<p>这个API是创建一个Event对象，接受一个参数，就是表示事件类型的字符串。该字符串的可能取值为：</p>\n<ol>\n<li><code>UIEvent</code>，通用的UI事件，键盘鼠标事件都是继承于这个事件。</li>\n<li><code>MouseEvent</code>，鼠标事件。</li>\n<li><code>MutationEvent</code>，通用的突变事件。</li>\n<li><code>HTMLEvent</code>，通用的HTML事件。</li>\n</ol>\n<p>使用该API创建出事件对象之后，需要在触发模拟事件的DOM上调用<code>dispatchEvent</code>方法，触发该模拟事件。MDN的实例代码如下，<a href=\"http://developer.mozilla.org/samples/domref/dispatchEvent.html\">参考这里</a>：</p>\n<pre><code>function simulateClick() {\n    var evt = document.createEvent(&quot;MouseEvents&quot;);\n    evt.initMouseEvent(&quot;click&quot;, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n    var cb = document.getElementById(&quot;checkbox&quot;); \n    var canceled = !cb.dispatchEvent(evt);\n    if(canceled) {\n        // A handler called preventDefault\n</code></pre>","path":"2013-07-14-simulate-event.json","year":"2013","month":"07","day":"14","tags":["JavaScript"]},{"link":"/posts/2013/07/13/http-status-code.html","title":"HTTP协议之HTTP状态码","summary":"<p>继续HTTP协议科普贴。讲一下HTTP状态码，这个已经被人问过N次了。记得上次只能答出200、304、404、503等，然后被深深的鄙视。HTTP状态码表示该HTTP响应状态的三位数字代码，所有状态的第一个数字表示的是同一类的状态。</p>\n<h3 id=\"1xx\">1XX</h3>\n<p>这类的响应指的是服务器已经接受到客户端的请求，在继续处理。<strong>由于HTTP协议没有定义1XX的状态码，除非在某些试验的情况下，不应该向客户端发送该类响应的状态码。</strong></p>\n<ol>\n<li>100 Continue，表示客户端应该继续发送剩余的请求部分。服务器必须在请求完成后返回一个最终的请求结果。</li>\n<li>101 Switch Protocol，表示客户端应该使用不同的协议继续完成这个请求。只能转移到比现在这个协议更加好的协议上去。</li>\n<li>103 Processing，WebDAV定义的状态码，表示处理将继续进行。</li>\n</ol>\n<h3 id=\"2xx\">2XX</h3>\n<p>这类的响应指的是请求已经被正确接收并理解，是正确的状态。</p>\n<ol>\n<li>200 OK，请求成功，并根据不同的HTTP Method返回不同的信息。</li>\n<li>201 Created，请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回&#39;202 Accepted&#39;。</li>\n<li>202 Accepted，表示请求已经被接受，但是还没有处理。这个状态码特别适合某种异步操作的场景，当服务器操作可能比较慢的场景下，可以通过发送202状态码通知客户端，不需要客户端继续保持与服务器的这个HTTP连接。</li>\n<li>203 Non-Authoritative Information，表示这个请求已经成功处理了，但是entity-header的信息在当前服务器上没有有效的确定集合，可能存在本地或者第三方的某个拷贝。</li>\n<li>204 No Content，表示返回的响应没有内容。</li>\n<li>205 Reset Content，表示返回的响应没有内容。与204不一样，205会重置文档视图，即会重置表单的输入域的值。</li>\n<li>206 Partial Content，表示只返回了部分响应的内容，这个状态码在分块下载的时候非常有用，以后会单独进行分析。</li>\n<li>207 Multi-Status，WebDAV定义的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</li>\n</ol>\n","path":"2013-07-13-http-status-code.json","year":"2013","month":"07","day":"13","tags":["http"]},{"link":"/posts/2013/07/12/http-header.html","title":"HTTP协议之HTTP 头","summary":"<p>今天启程去阿里ADC，无奈被困机场，飞机起飞遥遥无期，故趁等飞机起飞的闲暇事件写一下HTTP协议之HTTP头的简介，来慰藉我寂寞的心（顺便鄙视周围的家伙们都在玩手机）。</p>\n<p>看了一下RFC关于HTTP头的规范，我跟我的小伙伴们都惊呆了，有这么多，<a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\">参考这里</a>。今天我决定先从一个比较简单的角度入手，对HTTP头及几个重要的头进行解析，抛砖引玉一下。</p>\n<blockquote>\n<p>HTTP header fields are components of the message header of requests and responses in the Hypertext Transfer Protocol (HTTP). They define the operating parameters of an HTTP transaction.</p>\n</blockquote>\n<p>简单地说就是一些关于HTTP协议中请求与响应的传输中的控制参数。HTTP头由多个头域组成，至一个空的头域结束。每个头域是一个冒号分隔的键值对。HTTP头有标准头跟自定义头两种。标准头是每个实现都必须支持的头，如<code>Expires</code>、<code>Set-Cookie</code>等。非标准头可以由实现者自己定义，如IE的<code>X-UA-Compatible</code>等。</p>\n<p>在HTTP协议本身是没有限制HTTP头的大小。尽管如此，很多Web服务器、客户端和代理软件都对HTTP头的大小进行限制。如Apache2.3中，每个头的大小最多是8160个字节，一个请求里面最多包含100个头。</p>\n<p>头域大致可以分成两种，一种是请求头，客户端向服务器发请求的时候使用什么方法、请求什么URI、协议版本等都是在请求头中指定。另一种是响应头，服务器接到客户端的请求后返回响应的是否成功、返回的MIME类型是什么都在请求头中指定。</p>\n<h3 id=\"-\">请求头</h3>\n<p>常用的标准请求头包括下面几个：</p>\n<ol>\n<li><code>Accept</code>，声明哪种相应是可接受的，如<code>text\\plain</code>、<code>application\\json</code>等。</li>\n<li><code>Cache-Control</code>，声明缓存控制机制，如<code>no-cache</code>声明不做缓存。</li>\n<li><code>Connection</code>，声明与服务器的连接机制，如<code>keep-alive</code>等。</li>\n<li><code>Cookie</code>，声明Cookie信息。</li>\n<li><code>Content-Type</code>，声明请求体的MIME类型。</li>\n</ol>\n","path":"2013-07-12-http-header.json","year":"2013","month":"07","day":"12","tags":["http"]},{"link":"/posts/2013/07/11/jquery-event-2.html","title":"jQuery事件绑定研究续","summary":"<p>昨天留下了两个问题：</p>\n<ol>\n<li>究竟<code>on</code>能否解决在事件委托的情况下不能使用<code>event.stopPropagation</code>的问题？</li>\n<li>假如在委托模式下，选择元素的其中一个子元素阻止事件冒泡，<code>on</code>委托的事件处理程序还能否顺利执行？</li>\n</ol>\n<p>针对问题1，先做一个实验，<a href=\"http://jsfiddle.net/Ask5n/2/\">参考这里</a>：</p>\n<p>HTML：</p>\n<pre><code>&lt;div id=&quot;root&quot;&gt;\n    &lt;div id=&quot;outer&quot;&gt;\n        Outer\n        &lt;div id=&quot;inner&quot;&gt;Inner&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>JavaScript：</p>\n<pre><code>$(&quot;#root&quot;).on(&quot;click&quot;, function (evt) {\n    alert(&quot;click on root&quot;);\n});\n</code></pre>","path":"2013-07-11-jquery-event-2.json","year":"2013","month":"07","day":"11","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/07/10/jquery-bind-live-on-delegate.html","title":"简析jQuery几个绑定事件方法的优劣异同","summary":"<p>今天被问到jQuery中绑定事件的方式，回答了<code>bind</code>、<code>live</code>、<code>on</code>三种。继续被问到哪种方式比较好。当时我毫不犹豫地说是<code>on</code>。继续被追问说除了<code>on</code>还知不知道有什么更好的方式绑定事件。当时哥就蒙了，还有更好的绑定事件的方式吗？决定写一下jQuery中绑定事件有哪些方式，各种方式之间的区别又是啥。</p>\n<h3 id=\"-bind\">.bind</h3>\n<p>先看看jQuery官方是怎么描述<code>bind</code>的：</p>\n<blockquote>\n<p>Attach a handler to an event for the elements.</p>\n</blockquote>\n<p>简单地说就是往元素上绑定事件处理程序。该方法接受三个参数：</p>\n<ol>\n<li><code>eventType</code>，绑定事件的名称。名称可以是任意的，接受自定义事件（只能通过<code>trigger</code>触发）。</li>\n<li><code>eventData</code>，可选，绑定事件附加的数据，这个数据会附在事件对象的<code>data</code>属性里面。</li>\n<li><code>handler</code>，事件处理程序，每次触发事件都会执行这个事件处理程序。</li>\n</ol>\n<p><strong>必须在一个已存在的元素上才能使用<code>bind</code>。</strong><code>bind</code>只能把事件处理程序绑定到指定的DOM元素上面。注意的是，如果为该对象的同一个事件绑定多个事件处理程序，则其执行的顺序是按照其绑定的先后顺序决定的。</p>\n<p>假如绑定的对象只是一个DOM元素（例如通过id选择器选择），那么用<code>bind</code>是可以的，不会带来太多额外的开销。但是当选择器选择的DOM对象个数非常多，由于要在每一个元素上都绑定同一个事件处理程序，会带来额外的开销，包括获取DOM元素、遍历所有DOM元素绑定事件处理程序等。而且由于<code>bind</code>绑定时机的局限性，一般在频繁动态创建和删除DOM的场景下都不会使用<code>bind</code>。</p>\n<h3 id=\"-live\">.live</h3>\n<p>又看看jQuery官方是怎么描述<code>live</code>的：</p>\n","path":"2013-07-10-jquery-bind-live-on-delegate.json","year":"2013","month":"07","day":"10","tags":["JavaScript","jQuery"]},{"link":"/posts/2013/07/08/three-column-layout-middle-first.html","title":"经典三列布局之如何让中间的列先显示出来","summary":"<p>在某些并发访问非常高的页面，由于服务器压力过大，导致页面的内容要很久才能加载完。这个时候，我们应该尽可能把用户觉得重要的信息（大多数情况放在中栏）先显示出来。</p>\n<p>首先是原始的HTML：</p>\n<pre><code>&lt;div id=&quot;container&quot;&gt;\n    &lt;div id=&quot;left&quot;&gt;This is left!&lt;/div&gt;\n    &lt;div id=&quot;middle&quot;&gt;This is middle!&lt;/div&gt;\n    &lt;div id=&quot;right&quot;&gt;This is right!&lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>按照HTML解析顺序，上面的HTML片段应该是先显示left，再显示middle，最后显示right。</p>\n<h3 id=\"-\">第一步</h3>\n<p>先调整HTML的顺序，让middle先行。</p>\n<pre><code>&lt;div id=&quot;container&quot;&gt;\n    &lt;div id=&quot;middle&quot;&gt;This is middle!&lt;/div&gt;\n    &lt;div id=&quot;left&quot;&gt;This is left!&lt;/div&gt;\n    &lt;div id=&quot;right&quot;&gt;This is right!&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>","path":"2013-07-08-three-column-layout-middle-first.json","year":"2013","month":"07","day":"08","tags":["html","css"]},{"link":"/posts/2013/07/07/window-location.html","title":"window.location 浅析","summary":"<p>国际惯例，先看看<code>window.location</code>在w3schools的简单描述：</p>\n<blockquote>\n<p>The window.location object can be used to get the current page address (URL) and to redirect the browser to a new page.</p>\n</blockquote>\n<p>简单地说，这个对象就是用来获取页面的URL，控制页面跳转等功能。</p>\n<h3 id=\"-\">属性</h3>\n<p>可以通过以下属性获取关于当前页面路径的信息，也可以设置某些属性跳转到新的url上面。</p>\n<ol>\n<li><code>hash</code>，url中跟着<code>#</code>的内容，包含<code>#</code>。注意，<strong>如果<code>#</code>后面没用东西或者没有<code>#</code>，则这个属性的值是空字符串</strong>。还可以绑定<code>hashchange</code>事件监听<code>hash</code>变化。</li>\n<li><code>host</code>，由url的主机名称<code>hostname</code>跟端口<code>port</code>组成的字符串。</li>\n<li><code>hostname</code>，url的主机名称。注意，<strong>在Chrome跟Safari是包括括号的（IPv6的情况），而IE跟FireFox则不包括括号</strong>。</li>\n<li><code>href</code>，完整的url。</li>\n<li><code>pathname</code>，相对于主机名的路径。</li>\n<li><code>port</code>，url的端口号。如果使用的是默认端口（80），则这个属性的值是空字符串。</li>\n<li><code>protocol</code>，url的协议。</li>\n<li><code>search</code>，url中跟着<code>?</code>的内容，包含<code>?</code>。</li>\n<li><code>orign</code>，由url的协议、主机名跟端口组成的字符串。目前只有Chrome跟FireFox 21支持这个属性。</li>\n</ol>\n<h3 id=\"-\">方法</h3>\n<ol>\n<li><code>assign(url)</code>，将当前页面跳转到指定的url。</li>\n</ol>\n","path":"2013-07-07-window-location.json","year":"2013","month":"07","day":"07","tags":["JavaScript"]},{"link":"/posts/2013/07/06/frontend-career.html","title":"前端攻城师的职业规划","summary":"<p>直接上图。</p>\n<p><img alt=\"frontend\" src=\"http://popotang.com/blog/wp-content/uploads/2011/12/655534efgw1do2a8dvcldj.jpg\" width=\"100%\" /></p>\n","path":"2013-07-06-frontend-career.json","year":"2013","month":"07","day":"06","tags":["前端"]},{"link":"/posts/2013/07/05/href-javascript-expression.html","title":"Href中的JavaScript link","summary":"<p>在<code>A</code>标签的<code>href</code>属性写上JavaScript“表达式”，其中一个目的就是为了那些不是链接的<code>A</code>标签通过HTML验证，<a href=\"http://stackoverflow.com/questions/7755088/href-expression-a-href-javascript-a\">参考这里</a>。<em>（注：刚才试了一下在最新的W3C的HTML在线校验里面没有<code>name</code>和<code>href</code>属性的<code>A</code>标签也能通过校验）</em></p>\n<p>不能写“#”，因为会跳到页面的头部<em>（可以通过取消浏览器默认事件防止该行为，<a href=\"http://dafeizizhu.github.io/2013/07/03/a-tag/\">参考这里</a>）</em>。也不能写空字符串，在IE下会刷新页面。那只能写一个JavaScript表达式，该表达式什么也不做。最常见的就是以下这个代码：</p>\n<pre><code>&lt;a href=&quot;javascript:void(0)&quot;&gt;Do not refresh or go to the top of this page.&lt;/a&gt;\n</code></pre><p>JavaScrit提供了一种机制，供页面与JavaScript方法进行交互，其中一种机制就是<code>href</code>中的JavaScript链接（JavaScript link）。一个最简单的JavaScript链接示例如下：</p>\n<pre><code>&lt;a href=&quot;javascript:MyFunction();&quot;&gt;Text to Click&lt;/a&gt;\n</code></pre><p>其中<code>MyFunction</code>是全局的一个函数，当单击这个<code>A</code>标签的时候，对应JavaScript链接的语句会被执行。</p>\n<p>如果同时设置了<code>href</code>上的JavaScript链接，又设置了<code>onclick</code>属性<em>（当然这个应该存在于黑暗之中永远不让它出来o(╯□╰)o）</em>，会是怎样的一个场景呢？立马做一个实验，<a href=\"http://jsfiddle.net/b7YLJ/1/\">参考这里</a>。</p>\n<pre><code>&lt;a href=&quot;javascript:alert(1);&quot; onclick=&quot;alert(2);&quot;&gt;Text to Click&lt;/a&gt;\n</code></pre><p>结果是先弹出了2，再弹出1。仔细思考一下，其实这个结果是跟前天写的内容是吻合的。事件处理函数先执行，再执行浏览器的默认行为，在这里浏览器的默认行为就是弹出1。</p>\n<p>最后简单看看JavaScript中一个被忽略的运算符：<code>void</code>。这个运算符有两种使用方式：</p>\n<pre><code>void (expression)\n</code></pre>","path":"2013-07-05-href-javascript-expression.json","year":"2013","month":"07","day":"05","tags":["html","JavaScript"]},{"link":"/posts/2013/07/04/html-meta-tag.html","title":"HTML META 标签入门","summary":"<p>今天被妹纸狠狠地鄙视了我的博客样子太丑(/＞皿&lt;)/ ～ ┴┴。闲逛看看有没有好看的博客设计。偷看他们源代码，发现有好多<code>meta</code>标签都不认识，所以写一篇东西好好学习一下<code>html</code>中的<code>meta</code>标签究竟怎么用。</p>\n<h3 id=\"-\">定义</h3>\n<p>又看看w3schools对<code>meta</code>标签的定义：</p>\n<blockquote>\n<p>The meta tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable.</p>\n</blockquote>\n<p>再看看wikipedia的解释：</p>\n<blockquote>\n<p>Meta elements can specify HTTP headers which should be sent <strong>before</strong> the actual content when the HTML page is served from Web server to client.</p>\n</blockquote>\n<p><code>meta</code>标签不会显示在页面中。使用<code>meta</code>可以声明这个页面的描述、作者、关键字、最后修改日期等信息，可以供浏览器、搜索引擎和一些Web服务使用。</p>\n<h3 id=\"-\">注意</h3>\n<p>以下是几点注意事项：</p>\n<ol>\n<li><code>meta</code>标签总是定义在<code>head</code>标签之类。</li>\n<li><code>meta</code>标签总是以键值对（<code>name</code>和<code>content</code>）传递信息。</li>\n<li>在定义<code>name</code>或者<code>http-equiv</code>属性之后才能定义<code>content</code>属性。</li>\n</ol>\n<h3 id=\"name\">NAME</h3>\n","path":"2013-07-04-html-meta-tag.json","year":"2013","month":"07","day":"04","tags":["html"]},{"link":"/posts/2013/07/03/a-tag.html","title":"HTML A 标签简析","summary":"<p>HTML中的<code>A</code>标签，使用频率应该非常高。可以作为一个链接、一个锚点，甚至一些按钮（Extjs和dojo等框架）。先看看w3schools对<code>A</code>标签的定义是：</p>\n<blockquote>\n<p>The a tag defines a hyperlink, which is used to link from one page to another.</p>\n</blockquote>\n<p>简单的说，<code>A</code>标签就是一个超链接。有趣的是，对于HTML4跟HTML5对<code>A</code>标签的定义又有所不同。</p>\n<blockquote>\n<p>In HTML 4.01, the a tag could be either a hyperlink or an anchor. In HTML5, the a tag is always a hyperlink, but if it has no href attribute, it is only a placeholder for a hyperlink.</p>\n</blockquote>\n<p>在HTML4中，如果<code>A</code>标签没有<code>href</code>这个属性，则说明该<code>A</code>标签仅仅是个锚，可以供链接跳转到该位置，就像一个“书签”的作用。但是在HTML5中<code>A</code>标签<strong>只是个链接</strong>。</p>\n<p>最近在项目中发现有个奇怪的问题：在一个<code>A</code>标签的事件处理程序中，改变浏览器的hash，发现不生效，只是在浏览器的地址栏的末尾加上了“#&quot;。打断点调试后发现该行代码执行之后，浏览器的地址栏确实是改变了，可以看到代码设置的hash。但是在代码走完之后，浏览器的hash自动变成“#”，代码设置上去的hash被重置了。观察该事件在jQuery中的处理函数，只有一个事件处理函数，没有其他的事件处理函数被执行，也没有异步方法执行。究竟这个hash是怎么被重置回去了？</p>\n<p>观察该<code>A</code>标签的属性，发现有一行这样的代码：<code>href=&quot;#&quot;</code>。使用Chrome的调试工具，把其改成<code>href=&quot;#123&quot;</code>，神奇的事情发生了。单击按钮后地址栏上的hash被改成了“#123”。难道是<code>A</code>标签的默认行为重置了浏览器的hash？</p>\n<p>为了验证该问题，为一个<code>DIV</code>元素绑定了同样一个鼠标单击的事件处理函数，发现单击该<code>DIV</code>元素，地址栏上的hash被正确修改，没有被重置。</p>\n<p>重现该场景写了一个<a href=\"http://jsfiddle.net/Vy3W7/\">测试代码</a>：</p>\n<p>{% highlight html %}\n<a href=\"#123\">click me!</a>\n{% endhighlight %}</p>\n","path":"2013-07-03-a-tag.json","year":"2013","month":"07","day":"03","tags":["html"]},{"link":"/posts/2013/07/02/position-fixed.html","title":"Position: fixed 浏览器兼容性分析","summary":"<p>写这个是因为现在很多门户网站都采用了顶栏固定的布局，提供导航还有一些工作（例如搜索）。对于现代浏览器来说，可以简单的使用以下这个css样式达到效果：</p>\n<p>{% highlight css %}\n.fixed {\n  positon: fixed;\n}\n{% endhighlight %}</p>\n<p>这个样式在Chrome、FireFox、Safari、Opera、IE7、IE8、IE9都是生效的。<strong>其中需要注意的是，在IE7和IE8下面需要声明文档模式是标准模式才能生效</strong>。</p>\n<p>在IE6下需要CSS hack才能达到<code>position: fixed;</code>的效果：</p>\n<p>{% highlight css %}\nhtml div#fixedbox {\n  position: fixed;\n}</p>\n<ul>\n<li>html {\noverflow-y: hidden;\n}</li>\n<li>html body {\noverflow-y: auto;\nheight: 100%;</li>\n</ul>\n","path":"2013-07-02-position-fixed.json","year":"2013","month":"07","day":"02","tags":["css"]},{"link":"/posts/2013/01/23/post.html","title":"弹出的模态对话框被拦截的条件","summary":"<p>只要从用户行为到弹出模态对话框<code>showModalDialog</code>之间，有任意一个异步调用（例如<code>setTimeout</code>或者ajax调用），则会被浏览器认为是恶意的窗口，导致窗口被拦截。</p>\n<p>解决方案：</p>\n<ol>\n<li>删除任何<code>setTimeout</code></li>\n<li>删除任何ajax调用，如果要跟服务交互，必须使用同步调用</li>\n<li>不使用<code>showModalDialog</code>弹出对话框，使用更现代的方法（例如div模拟的模态对话框效果）</li>\n</ol>\n","path":"2013-01-23-post.json","year":"2013","month":"01","day":"23","tags":["notes"]},{"link":"/posts/2012/12/22/note-2012-12-22.html","title":"2012 12 22 笔记","summary":"<h3 id=\"vertical-align-line-height-\">vertical-align 与line-height的垂直居中答案</h3>\n<p>其实很简单……只要在label里面也加上vertical-align就ok了……</p>\n<p>{% highlight html %}</p>\n<style>\n  p {\n    vertical-align: middle;\n  }\n  label {\n    vertical-align: middle;\n    display: inline-block;\n    width: 50px;\n  }\n</style>\n\n<p>\n  <label>This is long long label</label>\n  <span>I want to vertical middle!</span>\n</p>\n","path":"2012-12-22-note-2012-12-22.json","year":"2012","month":"12","day":"22","tags":["notes"]},{"link":"/posts/2012/12/20/2012-12-20-note.html","title":"2012 12 20 Note","summary":"<h3 id=\"vertical-align-line-height-\">vertical-align 与line-height的垂直居中</h3>\n<p>vertical-align用于块元素内的行内元素的垂直居中，而line-height则用于在行内元素中文字居中，当行高被块元素内部的某个元素（display: inline-block）撑大之后，使用前两个垂直居中的方法都不凑效。</p>\n<ol>\n<li>vertical-aligin作用在块元素中，不能使其他行内元素垂直居中，因为受到了那个撑大元素的影响</li>\n<li>line-height则要显式的设置固定像素值，不能满足自适应那个撑大元素的高度</li>\n</ol>\n<p>到最后还是要使用表格布局……</p>\n<p>遗留一个题目，等自己以后想起来了可以做一下，让那个span居中显示：</p>\n<pre><code>&lt;style&gt;\n    p {\n        vertical-align: center;\n    ｝\n    label {\n        width: 50px;\n        display: inline-block;\n    ｝\n&lt;/style&gt;\n&lt;p&gt;\n    &lt;label&gt;This is a long long long label&lt;/label&gt;\n</code></pre>","path":"2012-12-20-2012-12-20-note.json","year":"2012","month":"12","day":"20","tags":["notes"]},{"link":"/posts/2012/12/18/note-2012-12-18.html","title":"2012-12-18 笔记","summary":"<h3 id=\"-\">兼容的强制换行样式</h3>\n<pre><code>&lt;div class=&quot;content&quot;&gt;\n    &lt;p class=&quot;wrap&quot;&gt;No matter how long, i wrap...&lt;/p&gt;\n&lt;/div&gt;\n\n.content {\n    /* Important! */\n    width: 200px;\n}\n.wrap {\n    word-break: break-all;\n    word-wrap: break-word;\n}\n</code></pre>","path":"2012-12-18-note-2012-12-18.json","year":"2012","month":"12","day":"18","tags":["notes"]},{"link":"/posts/2012/12/17/note-2012-12-17.html","title":"Note 2012 12 17","summary":"<h3 id=\"ff-jquery-ajax-datatype-\">FF jQuery.ajax 默认的dataType属性不生效</h3>\n<p>在FF10以上的环境，使用jQuery的ajax方法，如果没有配置dataType属性，返回的结果类型不可遇见（经调试发现是Document），例如：</p>\n<pre><code>$.ajax({\n    &quot;url&quot;: &quot;xxx&quot;,\n    &quot;success&quot;: function (result) {\n        console.log(result);    // In FF, it may be Document if has no dataType...\n    }\n    // This is nessery\n    &quot;dataType&quot;: &quot;text&quot;\n});\n</code></pre><h3 id=\"-ie8-jquery-attr-boolean-\">在IE8下使用jQuery的attr方法，最好能使用明确的boolean值</h3>\n<p>在IE8下使用attr，如果使用例如空字符串或者undefined之类的去设置对应attr的值，可能会有意想不到的结果，例如：</p>\n<pre><code>function test(booleanValue) {\n    // This is nessery\n    booleanValue = !!booleanValue;        \n\n    $(&quot;#id&quot;).attr(&quot;someAttr&quot;, booleanValue);\n</code></pre>","path":"2012-12-17-note-2012-12-17.json","year":"2012","month":"12","day":"17","tags":["notes"]},{"link":"/posts/2012/12/16/my-first-post.html","title":"My First Post","summary":"<h3 id=\"this-is-the-first-post-\">This is the first Post!!!!!</h3>\n<pre><code>function () {\n    console.log(&quot;Hello World!&quot;);\n}\n</code></pre><p>一个IT闷骚男的闷骚技术剥壳，记录编码中的一点一滴</p>\n","path":"2012-12-16-my-first-post.json","year":"2012","month":"12","day":"16","tags":[""]}]