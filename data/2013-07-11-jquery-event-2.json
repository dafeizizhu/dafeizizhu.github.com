{"year":"2013","month":"07","day":"11","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/07/11/jquery-event-2.html","fileName":"jquery-event-2","layout":"post","title":"jQuery事件绑定研究续","description":"","tags":["JavaScript","jQuery"],"markdownText":"\n\n\n昨天留下了两个问题：\n\n1. 究竟`on`能否解决在事件委托的情况下不能使用`event.stopPropagation`的问题？\n2. 假如在委托模式下，选择元素的其中一个子元素阻止事件冒泡，`on`委托的事件处理程序还能否顺利执行？\n\n针对问题1，先做一个实验，[参考这里](http://jsfiddle.net/Ask5n/2/)：\n\nHTML：\n\n    <div id=\"root\">\n        <div id=\"outer\">\n            Outer\n            <div id=\"inner\">Inner</div>\n        </div>\n    </div>\n\nJavaScript：\n    \n    $(\"#root\").on(\"click\", function (evt) {\n        alert(\"click on root\");\n    });\n\n    $(\"#root\").on(\"click\", \"#outer\", function (evt) {\n        alert(\"click on outer delegate\");\n    });\n\n    $(\"#root\").on(\"click\", \"#inner\", function (evt) {\n        alert(\"click on inner delegate, and i stop propagation!\");\n        evt.stopPropagation();\n    });\n\n单击`#inner`，成功的阻止了`#outer`和`#root`上面的单击事件，说明在全部都用`on`的情况下是可以实现阻止冒泡的功能。这个貌似跟事件委托的原理有点违背的感觉。看看jQuery的源码是怎么实现的。\n\n观察1.7的源码发现，`on`对于选中的元素进行事件绑定的数据是用内部的`_data`方法存在DOM里面的。所有事件都会绑定到内部的`dispatch`方法，由这个方法分发具体的事件，进而触发具体的事件处理程序。其中有这么一段代码：\n\n    if ( selector ) {\n        handlers.splice( handlers.delegateCount++, 0, handleObj );\n    } else {\n        handlers.push( handleObj );\n    }\n\n如果是事件委托，会放到处理程序队列的前端（但是还是按照委托的顺序进行存放），而事件绑定则是放到队列的最后。这样导致事件委托的处理程序会优先于事件绑定的处理程序执行。现在再来看看事件触发的时候jQuery是怎么处理的。\n\n触发事件时，先拿到当前事件处理程序的`elem`属性（即做事件委托时选中的“根”元素），然后以这个元素为事件处理程序的执行上下文（使用`apply`把`dispatch`方法里面的`this`变成该元素），并传入事件对象。`dispatch`方法先把事件对象封装一下，屏蔽浏览器差异（万恶的IE），然后从触发事件的`target`出发，遍历其父元素一直到“根”元素。在每一次循环里面，再遍历“根”元素这个事件上的`handler`队列（就是上文的`handlers`）中的事件委托部分，如果该事件委托的`selector`与当前这个元素匹配，则把该事件处理程序及其对应的元素放入最终的事件处理程序队列。事件委托遍历完成后，把剩余的事件绑定的处理程序及“根”元素一并放入最终队列中。到这个时候，就可以看出前面那个实验的结果是理所当然的。**当为一个“根”元素中若干个子元素进行事件委托，`event.stopPropagation`是有效的。**\n\n经过以上的分析，问题2的答案也出来了。当全部都是使用`on`的事件委托模式去处理事件，是不会出现问题的。但是假如其中一个元素使用的是事件绑定的方式，则有可能会阻止事件委托的处理程序的执行，[参考这里](http://jsfiddle.net/rp3Wp/)：\n\n    $(\"#root\").on(\"click\", function (evt) {\n        alert(\"click on root\");\n    });\n\n    $(\"#outer\").on(\"click\", function (evt) {\n        alert(\"click on outer delegate, and i stop propagation!\");\n        evt.stopPropagation();\n    });\n\n    $(\"#root\").on(\"click\", \"#inner\", function (evt) {\n        alert(\"click on inner\");\n    });\n\n单击`#inner`，有趣的事情发生了，`#outer`的事件处理程序执行，并阻止了事件冒泡，导致`#inner`的事件处理程序没有被执行，坑爹啊！\n\n血淋淋的事实告诉我们，要把`on`的事件委托进行到底到底到底到底……\n","htmlText":"<p>昨天留下了两个问题：</p>\n<ol>\n<li>究竟<code>on</code>能否解决在事件委托的情况下不能使用<code>event.stopPropagation</code>的问题？</li>\n<li>假如在委托模式下，选择元素的其中一个子元素阻止事件冒泡，<code>on</code>委托的事件处理程序还能否顺利执行？</li>\n</ol>\n<p>针对问题1，先做一个实验，<a href=\"http://jsfiddle.net/Ask5n/2/\">参考这里</a>：</p>\n<p>HTML：</p>\n<pre><code>&lt;div id=&quot;root&quot;&gt;\n    &lt;div id=&quot;outer&quot;&gt;\n        Outer\n        &lt;div id=&quot;inner&quot;&gt;Inner&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>JavaScript：</p>\n<pre><code>$(&quot;#root&quot;).on(&quot;click&quot;, function (evt) {\n    alert(&quot;click on root&quot;);\n});\n\n$(&quot;#root&quot;).on(&quot;click&quot;, &quot;#outer&quot;, function (evt) {\n    alert(&quot;click on outer delegate&quot;);\n});\n\n$(&quot;#root&quot;).on(&quot;click&quot;, &quot;#inner&quot;, function (evt) {\n    alert(&quot;click on inner delegate, and i stop propagation!&quot;);\n    evt.stopPropagation();\n});\n</code></pre><p>单击<code>#inner</code>，成功的阻止了<code>#outer</code>和<code>#root</code>上面的单击事件，说明在全部都用<code>on</code>的情况下是可以实现阻止冒泡的功能。这个貌似跟事件委托的原理有点违背的感觉。看看jQuery的源码是怎么实现的。</p>\n<p>观察1.7的源码发现，<code>on</code>对于选中的元素进行事件绑定的数据是用内部的<code>_data</code>方法存在DOM里面的。所有事件都会绑定到内部的<code>dispatch</code>方法，由这个方法分发具体的事件，进而触发具体的事件处理程序。其中有这么一段代码：</p>\n<pre><code>if ( selector ) {\n    handlers.splice( handlers.delegateCount++, 0, handleObj );\n} else {\n    handlers.push( handleObj );\n}\n</code></pre><p>如果是事件委托，会放到处理程序队列的前端（但是还是按照委托的顺序进行存放），而事件绑定则是放到队列的最后。这样导致事件委托的处理程序会优先于事件绑定的处理程序执行。现在再来看看事件触发的时候jQuery是怎么处理的。</p>\n<p>触发事件时，先拿到当前事件处理程序的<code>elem</code>属性（即做事件委托时选中的“根”元素），然后以这个元素为事件处理程序的执行上下文（使用<code>apply</code>把<code>dispatch</code>方法里面的<code>this</code>变成该元素），并传入事件对象。<code>dispatch</code>方法先把事件对象封装一下，屏蔽浏览器差异（万恶的IE），然后从触发事件的<code>target</code>出发，遍历其父元素一直到“根”元素。在每一次循环里面，再遍历“根”元素这个事件上的<code>handler</code>队列（就是上文的<code>handlers</code>）中的事件委托部分，如果该事件委托的<code>selector</code>与当前这个元素匹配，则把该事件处理程序及其对应的元素放入最终的事件处理程序队列。事件委托遍历完成后，把剩余的事件绑定的处理程序及“根”元素一并放入最终队列中。到这个时候，就可以看出前面那个实验的结果是理所当然的。<strong>当为一个“根”元素中若干个子元素进行事件委托，<code>event.stopPropagation</code>是有效的。</strong></p>\n<p>经过以上的分析，问题2的答案也出来了。当全部都是使用<code>on</code>的事件委托模式去处理事件，是不会出现问题的。但是假如其中一个元素使用的是事件绑定的方式，则有可能会阻止事件委托的处理程序的执行，<a href=\"http://jsfiddle.net/rp3Wp/\">参考这里</a>：</p>\n<pre><code>$(&quot;#root&quot;).on(&quot;click&quot;, function (evt) {\n    alert(&quot;click on root&quot;);\n});\n\n$(&quot;#outer&quot;).on(&quot;click&quot;, function (evt) {\n    alert(&quot;click on outer delegate, and i stop propagation!&quot;);\n    evt.stopPropagation();\n});\n\n$(&quot;#root&quot;).on(&quot;click&quot;, &quot;#inner&quot;, function (evt) {\n    alert(&quot;click on inner&quot;);\n});\n</code></pre><p>单击<code>#inner</code>，有趣的事情发生了，<code>#outer</code>的事件处理程序执行，并阻止了事件冒泡，导致<code>#inner</code>的事件处理程序没有被执行，坑爹啊！</p>\n<p>血淋淋的事实告诉我们，要把<code>on</code>的事件委托进行到底到底到底到底……</p>\n","summaryMarkdownText":"\n\n\n昨天留下了两个问题：\n\n1. 究竟`on`能否解决在事件委托的情况下不能使用`event.stopPropagation`的问题？\n2. 假如在委托模式下，选择元素的其中一个子元素阻止事件冒泡，`on`委托的事件处理程序还能否顺利执行？\n\n针对问题1，先做一个实验，[参考这里](http://jsfiddle.net/Ask5n/2/)：\n\nHTML：\n\n    <div id=\"root\">\n        <div id=\"outer\">\n            Outer\n            <div id=\"inner\">Inner</div>\n        </div>\n    </div>\n\nJavaScript：\n    \n    $(\"#root\").on(\"click\", function (evt) {\n        alert(\"click on root\");\n    });\n","summaryHtmlText":"<p>昨天留下了两个问题：</p>\n<ol>\n<li>究竟<code>on</code>能否解决在事件委托的情况下不能使用<code>event.stopPropagation</code>的问题？</li>\n<li>假如在委托模式下，选择元素的其中一个子元素阻止事件冒泡，<code>on</code>委托的事件处理程序还能否顺利执行？</li>\n</ol>\n<p>针对问题1，先做一个实验，<a href=\"http://jsfiddle.net/Ask5n/2/\">参考这里</a>：</p>\n<p>HTML：</p>\n<pre><code>&lt;div id=&quot;root&quot;&gt;\n    &lt;div id=&quot;outer&quot;&gt;\n        Outer\n        &lt;div id=&quot;inner&quot;&gt;Inner&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>JavaScript：</p>\n<pre><code>$(&quot;#root&quot;).on(&quot;click&quot;, function (evt) {\n    alert(&quot;click on root&quot;);\n});\n</code></pre>"}