{"year":"2013","month":"11","day":"15","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/11/15/jquery-when.html","fileName":"jquery-when","layout":"post","title":"jQuery扫盲之jQuery.when","description":"","tags":["JavaScript","jQuery"],"markdownText":"\n\n\n现实工作中我们经常会遇见一个场景，需要多次调用Ajax，在所有请求都完成的时候再执行一个回调函数。我们可以自己做一个计数器，每次Ajax执行完计数器加一，这样就可以知道是不是所有Ajax都调用完成了。其实jQuery已经提供了这么一个功能，就是`jQuery.when`：\n\n> Provides a way to execute callback functions based on one or more objects, usually Deferred objects that represent asynchronous events.\n\n这个方法接受一个或者多个`Deffered`对象，例如`jQuery.ajax`返回的东东。如果只传入一个`Deffered`对象，这个方法会简单地返回这个`Deffered`对象，例如：\n\n    $.when($.ajax());\n    $.ajax(); // equals\n\n如果传入一个不是`Deffered`对象的参数，这相当于`Deffered`对象已经resolve了，所有注册的回调都会立刻执行，例如：\n\n    $.when( { testing: 123 } ).done(function( x ) {\n      alert( x.testing ); // Alerts \"123\"\n    });\n\n这个方法最有用的用法还是传入多个`Deffered`对象的时候。这时，返回的对象要在所有参数都被`resolve`的时候才会被`resolve`，而当有一个参数被`reject`的时候就会被`reject`。当这个对象被`resolve`的时候，会回传各个单独`resolve`时返回的结果（就是每个回调函数中的参数），顺序就是参数传入的顺序，例如：\n\n    $.when( $.ajax( \"/page1.php\" ), $.ajax( \"/page2.php\" ) ).done(function( a1, a2 ) {\n      // a1 and a2 are arguments resolved for the page1 and page2 ajax requests, respectively.\n      // Each argument is an array with the following structure: [ data, statusText, jqXHR ]\n      var data = a1[ 0 ] + a2[ 0 ]; // a1[ 0 ] = \"Whip\", a2[ 0 ] = \" It\"\n      if ( /Whip It/.test( data ) ) {\n        alert( \"We got what we came for!\" );\n      }\n    });\n\n这不就是我们需要的功能吗？当然，这个方法只适用于各个Ajax请求独立的场景，如果这几个Ajax请求是有顺序的话就只能求助于别的方式了。\n","htmlText":"<p>现实工作中我们经常会遇见一个场景，需要多次调用Ajax，在所有请求都完成的时候再执行一个回调函数。我们可以自己做一个计数器，每次Ajax执行完计数器加一，这样就可以知道是不是所有Ajax都调用完成了。其实jQuery已经提供了这么一个功能，就是<code>jQuery.when</code>：</p>\n<blockquote>\n<p>Provides a way to execute callback functions based on one or more objects, usually Deferred objects that represent asynchronous events.</p>\n</blockquote>\n<p>这个方法接受一个或者多个<code>Deffered</code>对象，例如<code>jQuery.ajax</code>返回的东东。如果只传入一个<code>Deffered</code>对象，这个方法会简单地返回这个<code>Deffered</code>对象，例如：</p>\n<pre><code>$.when($.ajax());\n$.ajax(); // equals\n</code></pre><p>如果传入一个不是<code>Deffered</code>对象的参数，这相当于<code>Deffered</code>对象已经resolve了，所有注册的回调都会立刻执行，例如：</p>\n<pre><code>$.when( { testing: 123 } ).done(function( x ) {\n  alert( x.testing ); // Alerts &quot;123&quot;\n});\n</code></pre><p>这个方法最有用的用法还是传入多个<code>Deffered</code>对象的时候。这时，返回的对象要在所有参数都被<code>resolve</code>的时候才会被<code>resolve</code>，而当有一个参数被<code>reject</code>的时候就会被<code>reject</code>。当这个对象被<code>resolve</code>的时候，会回传各个单独<code>resolve</code>时返回的结果（就是每个回调函数中的参数），顺序就是参数传入的顺序，例如：</p>\n<pre><code>$.when( $.ajax( &quot;/page1.php&quot; ), $.ajax( &quot;/page2.php&quot; ) ).done(function( a1, a2 ) {\n  // a1 and a2 are arguments resolved for the page1 and page2 ajax requests, respectively.\n  // Each argument is an array with the following structure: [ data, statusText, jqXHR ]\n  var data = a1[ 0 ] + a2[ 0 ]; // a1[ 0 ] = &quot;Whip&quot;, a2[ 0 ] = &quot; It&quot;\n  if ( /Whip It/.test( data ) ) {\n    alert( &quot;We got what we came for!&quot; );\n  }\n});\n</code></pre><p>这不就是我们需要的功能吗？当然，这个方法只适用于各个Ajax请求独立的场景，如果这几个Ajax请求是有顺序的话就只能求助于别的方式了。</p>\n","summaryMarkdownText":"\n\n\n现实工作中我们经常会遇见一个场景，需要多次调用Ajax，在所有请求都完成的时候再执行一个回调函数。我们可以自己做一个计数器，每次Ajax执行完计数器加一，这样就可以知道是不是所有Ajax都调用完成了。其实jQuery已经提供了这么一个功能，就是`jQuery.when`：\n\n> Provides a way to execute callback functions based on one or more objects, usually Deferred objects that represent asynchronous events.\n\n这个方法接受一个或者多个`Deffered`对象，例如`jQuery.ajax`返回的东东。如果只传入一个`Deffered`对象，这个方法会简单地返回这个`Deffered`对象，例如：\n\n    $.when($.ajax());\n    $.ajax(); // equals\n\n如果传入一个不是`Deffered`对象的参数，这相当于`Deffered`对象已经resolve了，所有注册的回调都会立刻执行，例如：\n\n    $.when( { testing: 123 } ).done(function( x ) {\n      alert( x.testing ); // Alerts \"123\"\n    });\n\n这个方法最有用的用法还是传入多个`Deffered`对象的时候。这时，返回的对象要在所有参数都被`resolve`的时候才会被`resolve`，而当有一个参数被`reject`的时候就会被`reject`。当这个对象被`resolve`的时候，会回传各个单独`resolve`时返回的结果（就是每个回调函数中的参数），顺序就是参数传入的顺序，例如：\n\n    $.when( $.ajax( \"/page1.php\" ), $.ajax( \"/page2.php\" ) ).done(function( a1, a2 ) {\n      // a1 and a2 are arguments resolved for the page1 and page2 ajax requests, respectively.\n      // Each argument is an array with the following structure: [ data, statusText, jqXHR ]\n      var data = a1[ 0 ] + a2[ 0 ]; // a1[ 0 ] = \"Whip\", a2[ 0 ] = \" It\"\n      if ( /Whip It/.test( data ) ) {","summaryHtmlText":"<p>现实工作中我们经常会遇见一个场景，需要多次调用Ajax，在所有请求都完成的时候再执行一个回调函数。我们可以自己做一个计数器，每次Ajax执行完计数器加一，这样就可以知道是不是所有Ajax都调用完成了。其实jQuery已经提供了这么一个功能，就是<code>jQuery.when</code>：</p>\n<blockquote>\n<p>Provides a way to execute callback functions based on one or more objects, usually Deferred objects that represent asynchronous events.</p>\n</blockquote>\n<p>这个方法接受一个或者多个<code>Deffered</code>对象，例如<code>jQuery.ajax</code>返回的东东。如果只传入一个<code>Deffered</code>对象，这个方法会简单地返回这个<code>Deffered</code>对象，例如：</p>\n<pre><code>$.when($.ajax());\n$.ajax(); // equals\n</code></pre><p>如果传入一个不是<code>Deffered</code>对象的参数，这相当于<code>Deffered</code>对象已经resolve了，所有注册的回调都会立刻执行，例如：</p>\n<pre><code>$.when( { testing: 123 } ).done(function( x ) {\n  alert( x.testing ); // Alerts &quot;123&quot;\n});\n</code></pre><p>这个方法最有用的用法还是传入多个<code>Deffered</code>对象的时候。这时，返回的对象要在所有参数都被<code>resolve</code>的时候才会被<code>resolve</code>，而当有一个参数被<code>reject</code>的时候就会被<code>reject</code>。当这个对象被<code>resolve</code>的时候，会回传各个单独<code>resolve</code>时返回的结果（就是每个回调函数中的参数），顺序就是参数传入的顺序，例如：</p>\n<pre><code>$.when( $.ajax( &quot;/page1.php&quot; ), $.ajax( &quot;/page2.php&quot; ) ).done(function( a1, a2 ) {\n  // a1 and a2 are arguments resolved for the page1 and page2 ajax requests, respectively.\n  // Each argument is an array with the following structure: [ data, statusText, jqXHR ]\n  var data = a1[ 0 ] + a2[ 0 ]; // a1[ 0 ] = &quot;Whip&quot;, a2[ 0 ] = &quot; It&quot;\n  if ( /Whip It/.test( data ) ) {\n</code></pre>"}