{"year":"2013","month":"11","day":"16","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/11/16/bottom-up-selector-engine.html","fileName":"bottom-up-selector-engine","layout":"post","title":"Secrets of the JavaScript Ninja 读书笔记之 从下到上的CSS选择器引擎","description":"","tags":["JavaScript"],"markdownText":"\n\n\n如果不想做之前的唯一性的过滤，那么从下到上的CSS选择器实现应该是一个比较好的替换方式。这种实现跟之前的实现最大的不同就是它是从最右边开始解析CSS选择器。举个例子，假如有这么一个CSS选择器`div span`，从下到上的实现会先查找出文档中所有的`span`，然后在这些`span`中过滤出祖先节点有`div`的一个集合，就是最后的结果。\n\n这种先查出一个大集合再过滤的方式，优点就是代码实现起来比较简单，最明显的就是不用之前的唯一性判断。但是，代码简单带来的缺点就是扩展性比较差，而且当选择器比较复杂的时候局限性比较大。\n\n这个实现首先根据选择器的最右的部分查出所有元素。然后的操作就是从右到左，根据每一个选择器在这个集合中过滤掉合适的部分即可：\n\n    function find(selector, root){\n      root = root || document;\n      var parts = selector.split(\" \"),\n      query = parts[parts.length - 1],\n      rest = parts.slice(0,-1).join(\"\"),\n      elems = root.getElementsByTagName(query),\n      results = [];\n      for (var i = 0; i < elems.length; i++) {\n        if (rest) {\n          var parent = elems[i].parentNode;\n          while (parent && parent.nodeName != rest) {\n            parent = parent.parentNode;\n          }\n          if (parent) {\n            results.push(elems[i]);\n          }\n        } else {\n          results.push(elems[i]);\n        }\n      }\n      return results;\n    };\n","htmlText":"<p>如果不想做之前的唯一性的过滤，那么从下到上的CSS选择器实现应该是一个比较好的替换方式。这种实现跟之前的实现最大的不同就是它是从最右边开始解析CSS选择器。举个例子，假如有这么一个CSS选择器<code>div span</code>，从下到上的实现会先查找出文档中所有的<code>span</code>，然后在这些<code>span</code>中过滤出祖先节点有<code>div</code>的一个集合，就是最后的结果。</p>\n<p>这种先查出一个大集合再过滤的方式，优点就是代码实现起来比较简单，最明显的就是不用之前的唯一性判断。但是，代码简单带来的缺点就是扩展性比较差，而且当选择器比较复杂的时候局限性比较大。</p>\n<p>这个实现首先根据选择器的最右的部分查出所有元素。然后的操作就是从右到左，根据每一个选择器在这个集合中过滤掉合适的部分即可：</p>\n<pre><code>function find(selector, root){\n  root = root || document;\n  var parts = selector.split(&quot; &quot;),\n  query = parts[parts.length - 1],\n  rest = parts.slice(0,-1).join(&quot;&quot;),\n  elems = root.getElementsByTagName(query),\n  results = [];\n  for (var i = 0; i &lt; elems.length; i++) {\n    if (rest) {\n      var parent = elems[i].parentNode;\n      while (parent &amp;&amp; parent.nodeName != rest) {\n        parent = parent.parentNode;\n      }\n      if (parent) {\n        results.push(elems[i]);\n      }\n    } else {\n      results.push(elems[i]);\n    }\n  }\n  return results;\n};\n</code></pre>","summaryMarkdownText":"\n\n\n如果不想做之前的唯一性的过滤，那么从下到上的CSS选择器实现应该是一个比较好的替换方式。这种实现跟之前的实现最大的不同就是它是从最右边开始解析CSS选择器。举个例子，假如有这么一个CSS选择器`div span`，从下到上的实现会先查找出文档中所有的`span`，然后在这些`span`中过滤出祖先节点有`div`的一个集合，就是最后的结果。\n\n这种先查出一个大集合再过滤的方式，优点就是代码实现起来比较简单，最明显的就是不用之前的唯一性判断。但是，代码简单带来的缺点就是扩展性比较差，而且当选择器比较复杂的时候局限性比较大。\n\n这个实现首先根据选择器的最右的部分查出所有元素。然后的操作就是从右到左，根据每一个选择器在这个集合中过滤掉合适的部分即可：\n\n    function find(selector, root){\n      root = root || document;\n      var parts = selector.split(\" \"),\n      query = parts[parts.length - 1],\n      rest = parts.slice(0,-1).join(\"\"),\n      elems = root.getElementsByTagName(query),\n      results = [];\n      for (var i = 0; i < elems.length; i++) {\n        if (rest) {\n          var parent = elems[i].parentNode;\n          while (parent && parent.nodeName != rest) {\n            parent = parent.parentNode;\n          }\n          if (parent) {\n            results.push(elems[i]);\n          }","summaryHtmlText":"<p>如果不想做之前的唯一性的过滤，那么从下到上的CSS选择器实现应该是一个比较好的替换方式。这种实现跟之前的实现最大的不同就是它是从最右边开始解析CSS选择器。举个例子，假如有这么一个CSS选择器<code>div span</code>，从下到上的实现会先查找出文档中所有的<code>span</code>，然后在这些<code>span</code>中过滤出祖先节点有<code>div</code>的一个集合，就是最后的结果。</p>\n<p>这种先查出一个大集合再过滤的方式，优点就是代码实现起来比较简单，最明显的就是不用之前的唯一性判断。但是，代码简单带来的缺点就是扩展性比较差，而且当选择器比较复杂的时候局限性比较大。</p>\n<p>这个实现首先根据选择器的最右的部分查出所有元素。然后的操作就是从右到左，根据每一个选择器在这个集合中过滤掉合适的部分即可：</p>\n<pre><code>function find(selector, root){\n  root = root || document;\n  var parts = selector.split(&quot; &quot;),\n  query = parts[parts.length - 1],\n  rest = parts.slice(0,-1).join(&quot;&quot;),\n  elems = root.getElementsByTagName(query),\n  results = [];\n  for (var i = 0; i &lt; elems.length; i++) {\n    if (rest) {\n      var parent = elems[i].parentNode;\n      while (parent &amp;&amp; parent.nodeName != rest) {\n        parent = parent.parentNode;\n      }\n      if (parent) {\n        results.push(elems[i]);\n      }\n</code></pre>"}