{"year":"2013","month":"07","day":"27","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/07/27/closure-usage-2.html","fileName":"closure-usage-2","layout":"post","title":"Secrets of the JavaScript Ninja 读书笔记之 闭包（二）","description":"","tags":["JavaScript"],"markdownText":"\n\n\n今天接着分享JavaScript闭包的作用。\n\n### Memorize\n\n在一些需要频繁调用执行效率又比较低的方法可以使用Memorize这个方法，记录每次调用后的结果，下次传入相同的参数就可以直接返回缓存的结果，不需要重新再次执行其逻辑，提高执行效率。书中实现这个Memorize的代码如下：\n\n    Function.prototype.memoized = function(key){\n      this._values = this._values || {};\n      return this._values[key] !== undefined ?\n        this._values[key] :\n        this._values[key] = this.apply(this, arguments);\n      };\n    Function.prototype.memoize = function(){\n      var fn = this;                        \n      return function(){                           \n        return fn.memoized.apply( fn, arguments );\n      };\n    };\n\n在`memoize`这个方法里面，使用闭包记录原始方法，在返回的新方法中让原来的方法附加上Memorize的特性。这样封装了Memorize的具体实现，而且使用起来非常方便，甚至可以为一个匿名方法添加Memorize的功能，如：\n\n    var func = (function (n) { ... }).memoize();\n\n上述的例子`func`就有了Memorize的功能。\n\n### Function Wrapping\n\n在写与跨浏览器相关代码的时候，由于不同的浏览器对于特定功能也有不同的实现，经常会写出下面的这种daima :\n\n    function func () {\n      if (/** is ie  **/) {\n        /** do something only in IE **/\n      }\n      \n      if (/** is Opera **/) {\n        /** do something only in Opera **/\n      }\n    }\n\n无疑太丑陋了！这时可以使用Function Wrapping来为某种浏览器来做特殊处理。书中的代码如下：\n\n    function wrap(object, method, wrapper) {  \n      var fn = object[method];              \n      return object[method] = function() {         \n        return wrapper.apply(this, [fn.bind(this)].concat(\n          Array.prototype.slice.call(arguments)));\n      };\n    }\n\n这里闭包的作用也是记录原始的方法，然后重新为对象上的方法赋值，第一个参数传入原始的参数，以便在重写的方法里面可以调用原始方法的逻辑，有点像装饰模式。通过这中方式把屏蔽浏览器差异相关的代码提取出来，提高代码的可维护性。\n\n要跟妹纸看电影啦！明天继续！\n\n\n","htmlText":"<p>今天接着分享JavaScript闭包的作用。</p>\n<h3 id=\"memorize\">Memorize</h3>\n<p>在一些需要频繁调用执行效率又比较低的方法可以使用Memorize这个方法，记录每次调用后的结果，下次传入相同的参数就可以直接返回缓存的结果，不需要重新再次执行其逻辑，提高执行效率。书中实现这个Memorize的代码如下：</p>\n<pre><code>Function.prototype.memoized = function(key){\n  this._values = this._values || {};\n  return this._values[key] !== undefined ?\n    this._values[key] :\n    this._values[key] = this.apply(this, arguments);\n  };\nFunction.prototype.memoize = function(){\n  var fn = this;                        \n  return function(){                           \n    return fn.memoized.apply( fn, arguments );\n  };\n};\n</code></pre><p>在<code>memoize</code>这个方法里面，使用闭包记录原始方法，在返回的新方法中让原来的方法附加上Memorize的特性。这样封装了Memorize的具体实现，而且使用起来非常方便，甚至可以为一个匿名方法添加Memorize的功能，如：</p>\n<pre><code>var func = (function (n) { ... }).memoize();\n</code></pre><p>上述的例子<code>func</code>就有了Memorize的功能。</p>\n<h3 id=\"function-wrapping\">Function Wrapping</h3>\n<p>在写与跨浏览器相关代码的时候，由于不同的浏览器对于特定功能也有不同的实现，经常会写出下面的这种daima :</p>\n<pre><code>function func () {\n  if (/** is ie  **/) {\n    /** do something only in IE **/\n  }\n\n  if (/** is Opera **/) {\n    /** do something only in Opera **/\n  }\n}\n</code></pre><p>无疑太丑陋了！这时可以使用Function Wrapping来为某种浏览器来做特殊处理。书中的代码如下：</p>\n<pre><code>function wrap(object, method, wrapper) {  \n  var fn = object[method];              \n  return object[method] = function() {         \n    return wrapper.apply(this, [fn.bind(this)].concat(\n      Array.prototype.slice.call(arguments)));\n  };\n}\n</code></pre><p>这里闭包的作用也是记录原始的方法，然后重新为对象上的方法赋值，第一个参数传入原始的参数，以便在重写的方法里面可以调用原始方法的逻辑，有点像装饰模式。通过这中方式把屏蔽浏览器差异相关的代码提取出来，提高代码的可维护性。</p>\n<p>要跟妹纸看电影啦！明天继续！</p>\n","summaryMarkdownText":"\n\n\n今天接着分享JavaScript闭包的作用。\n\n### Memorize\n\n在一些需要频繁调用执行效率又比较低的方法可以使用Memorize这个方法，记录每次调用后的结果，下次传入相同的参数就可以直接返回缓存的结果，不需要重新再次执行其逻辑，提高执行效率。书中实现这个Memorize的代码如下：\n\n    Function.prototype.memoized = function(key){\n      this._values = this._values || {};\n      return this._values[key] !== undefined ?\n        this._values[key] :\n        this._values[key] = this.apply(this, arguments);\n      };\n    Function.prototype.memoize = function(){\n      var fn = this;                        \n      return function(){                           \n        return fn.memoized.apply( fn, arguments );\n      };\n    };\n\n在`memoize`这个方法里面，使用闭包记录原始方法，在返回的新方法中让原来的方法附加上Memorize的特性。这样封装了Memorize的具体实现，而且使用起来非常方便，甚至可以为一个匿名方法添加Memorize的功能，如：\n\n    var func = (function (n) { ... }).memoize();","summaryHtmlText":"<p>今天接着分享JavaScript闭包的作用。</p>\n<h3 id=\"memorize\">Memorize</h3>\n<p>在一些需要频繁调用执行效率又比较低的方法可以使用Memorize这个方法，记录每次调用后的结果，下次传入相同的参数就可以直接返回缓存的结果，不需要重新再次执行其逻辑，提高执行效率。书中实现这个Memorize的代码如下：</p>\n<pre><code>Function.prototype.memoized = function(key){\n  this._values = this._values || {};\n  return this._values[key] !== undefined ?\n    this._values[key] :\n    this._values[key] = this.apply(this, arguments);\n  };\nFunction.prototype.memoize = function(){\n  var fn = this;                        \n  return function(){                           \n    return fn.memoized.apply( fn, arguments );\n  };\n};\n</code></pre><p>在<code>memoize</code>这个方法里面，使用闭包记录原始方法，在返回的新方法中让原来的方法附加上Memorize的特性。这样封装了Memorize的具体实现，而且使用起来非常方便，甚至可以为一个匿名方法添加Memorize的功能，如：</p>\n<pre><code>var func = (function (n) { ... }).memoize();\n</code></pre>"}