{"year":"2013","month":"12","day":"08","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/12/08/hp-other-about-repaints-and-reflows.html","fileName":"hp-other-about-repaints-and-reflows","layout":"post","title":"High Performance JavaScript 读书笔记之 还有一些关于Repaint和Reflow","description":"","tags":["JavaScript"],"markdownText":"\n\n\n### 缓存关于布局的信息\n\n之前已经讨论过了，虽然浏览器会把触发Repaint和Reflow的DOM操作用一个队列缓存起来，但是只要我们去访问有关布局的属性（例如各种`offset`），这时候浏览器为了保证返回的值是正确的，只能把操作队列清空，把之前的DOM操作应用到页面中去。例如以下的代码是非常低效的：\n\n    myElement.style.left = 1 + myElement.offsetLeft + 'px';\n    myElement.style.top = 1 + myElement.offsetTop + 'px';\n    if (myElement.offsetLeft >= 500) {\n      stopAnimation();\n    }\n\n由于在设置DOM的位置的时候访问了`offsettLeft`和`offsetTop`两个有关布局的属性，导致第一行代码和第二行代码分别触发了Reflow。比较好的方式是使用一个局部变量把当前位置相关的值记录下来，而不是使用`offset`这样的属性：\n\n    currentLeft++;\n    myElement.style.left = currentLeft + \"px\";\n\n### 在动画的过程中把DOM从文档流中移除\n\n举个例子，像jQuery的`slideDown`和`slideUp`这样的效果在日常的页面中出现的次数非常多，例如各种手风琴菜单、下拉菜单等。像手风琴菜单那样的效果，当菜单展开的时候，会把它之后的菜单往后挤。由于位置不断发生变化，会频繁地触发Reflow。后面的内容越多，对性能的影响就越大。\n\n为了减少动画造成的Reflow次数，我们可以这么修改一下这个效果：\n\n1. 把展开的菜单项的`position`设置成`absolute`。（注：这样可能会导致页面在展开的过程中样式发生错误。）\n2. 在菜单项上应用动画，由于是绝对定位，DOM已经从文档流中移除，只会导致Repaint。\n3. 在动画完毕之后，把`position`恢复回来，样式恢复正常。\n\n### IE和hover伪类\n\n从IE7开始，IE就支持`:hover`了。不过，如果有很多元素都适用于这个`:hover`定义的样式的时候，性能会受到严重的影响，IE8更甚。当存在500－1000个DOM应用`:hover`定义的样式的时候，在IE7、8下CPU占用可能会长期达到80%－90%。所以在大量的DOM存在的时候，在IE7、8上要小心`:hover`造成的性能影响。\n","htmlText":"<h3 id=\"-\">缓存关于布局的信息</h3>\n<p>之前已经讨论过了，虽然浏览器会把触发Repaint和Reflow的DOM操作用一个队列缓存起来，但是只要我们去访问有关布局的属性（例如各种<code>offset</code>），这时候浏览器为了保证返回的值是正确的，只能把操作队列清空，把之前的DOM操作应用到页面中去。例如以下的代码是非常低效的：</p>\n<pre><code>myElement.style.left = 1 + myElement.offsetLeft + &#39;px&#39;;\nmyElement.style.top = 1 + myElement.offsetTop + &#39;px&#39;;\nif (myElement.offsetLeft &gt;= 500) {\n  stopAnimation();\n}\n</code></pre><p>由于在设置DOM的位置的时候访问了<code>offsettLeft</code>和<code>offsetTop</code>两个有关布局的属性，导致第一行代码和第二行代码分别触发了Reflow。比较好的方式是使用一个局部变量把当前位置相关的值记录下来，而不是使用<code>offset</code>这样的属性：</p>\n<pre><code>currentLeft++;\nmyElement.style.left = currentLeft + &quot;px&quot;;\n</code></pre><h3 id=\"-dom-\">在动画的过程中把DOM从文档流中移除</h3>\n<p>举个例子，像jQuery的<code>slideDown</code>和<code>slideUp</code>这样的效果在日常的页面中出现的次数非常多，例如各种手风琴菜单、下拉菜单等。像手风琴菜单那样的效果，当菜单展开的时候，会把它之后的菜单往后挤。由于位置不断发生变化，会频繁地触发Reflow。后面的内容越多，对性能的影响就越大。</p>\n<p>为了减少动画造成的Reflow次数，我们可以这么修改一下这个效果：</p>\n<ol>\n<li>把展开的菜单项的<code>position</code>设置成<code>absolute</code>。（注：这样可能会导致页面在展开的过程中样式发生错误。）</li>\n<li>在菜单项上应用动画，由于是绝对定位，DOM已经从文档流中移除，只会导致Repaint。</li>\n<li>在动画完毕之后，把<code>position</code>恢复回来，样式恢复正常。</li>\n</ol>\n<h3 id=\"ie-hover-\">IE和hover伪类</h3>\n<p>从IE7开始，IE就支持<code>:hover</code>了。不过，如果有很多元素都适用于这个<code>:hover</code>定义的样式的时候，性能会受到严重的影响，IE8更甚。当存在500－1000个DOM应用<code>:hover</code>定义的样式的时候，在IE7、8下CPU占用可能会长期达到80%－90%。所以在大量的DOM存在的时候，在IE7、8上要小心<code>:hover</code>造成的性能影响。</p>\n","summaryMarkdownText":"\n\n\n### 缓存关于布局的信息\n\n之前已经讨论过了，虽然浏览器会把触发Repaint和Reflow的DOM操作用一个队列缓存起来，但是只要我们去访问有关布局的属性（例如各种`offset`），这时候浏览器为了保证返回的值是正确的，只能把操作队列清空，把之前的DOM操作应用到页面中去。例如以下的代码是非常低效的：\n\n    myElement.style.left = 1 + myElement.offsetLeft + 'px';\n    myElement.style.top = 1 + myElement.offsetTop + 'px';\n    if (myElement.offsetLeft >= 500) {\n      stopAnimation();\n    }\n\n由于在设置DOM的位置的时候访问了`offsettLeft`和`offsetTop`两个有关布局的属性，导致第一行代码和第二行代码分别触发了Reflow。比较好的方式是使用一个局部变量把当前位置相关的值记录下来，而不是使用`offset`这样的属性：\n\n    currentLeft++;\n    myElement.style.left = currentLeft + \"px\";\n\n### 在动画的过程中把DOM从文档流中移除\n\n举个例子，像jQuery的`slideDown`和`slideUp`这样的效果在日常的页面中出现的次数非常多，例如各种手风琴菜单、下拉菜单等。像手风琴菜单那样的效果，当菜单展开的时候，会把它之后的菜单往后挤。由于位置不断发生变化，会频繁地触发Reflow。后面的内容越多，对性能的影响就越大。\n\n为了减少动画造成的Reflow次数，我们可以这么修改一下这个效果：\n\n1. 把展开的菜单项的`position`设置成`absolute`。（注：这样可能会导致页面在展开的过程中样式发生错误。）","summaryHtmlText":"<h3 id=\"-\">缓存关于布局的信息</h3>\n<p>之前已经讨论过了，虽然浏览器会把触发Repaint和Reflow的DOM操作用一个队列缓存起来，但是只要我们去访问有关布局的属性（例如各种<code>offset</code>），这时候浏览器为了保证返回的值是正确的，只能把操作队列清空，把之前的DOM操作应用到页面中去。例如以下的代码是非常低效的：</p>\n<pre><code>myElement.style.left = 1 + myElement.offsetLeft + &#39;px&#39;;\nmyElement.style.top = 1 + myElement.offsetTop + &#39;px&#39;;\nif (myElement.offsetLeft &gt;= 500) {\n  stopAnimation();\n}\n</code></pre><p>由于在设置DOM的位置的时候访问了<code>offsettLeft</code>和<code>offsetTop</code>两个有关布局的属性，导致第一行代码和第二行代码分别触发了Reflow。比较好的方式是使用一个局部变量把当前位置相关的值记录下来，而不是使用<code>offset</code>这样的属性：</p>\n<pre><code>currentLeft++;\nmyElement.style.left = currentLeft + &quot;px&quot;;\n</code></pre><h3 id=\"-dom-\">在动画的过程中把DOM从文档流中移除</h3>\n<p>举个例子，像jQuery的<code>slideDown</code>和<code>slideUp</code>这样的效果在日常的页面中出现的次数非常多，例如各种手风琴菜单、下拉菜单等。像手风琴菜单那样的效果，当菜单展开的时候，会把它之后的菜单往后挤。由于位置不断发生变化，会频繁地触发Reflow。后面的内容越多，对性能的影响就越大。</p>\n<p>为了减少动画造成的Reflow次数，我们可以这么修改一下这个效果：</p>\n<ol>\n<li>把展开的菜单项的<code>position</code>设置成<code>absolute</code>。（注：这样可能会导致页面在展开的过程中样式发生错误。）</li>\n</ol>\n"}