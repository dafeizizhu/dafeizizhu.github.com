{"year":"2013","month":"09","day":"24","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/09/24/javascript-for-in-order.html","fileName":"javascript-for-in-order","layout":"post","title":"再谈for-in循环的顺序","description":"","tags":["JavaScript"],"markdownText":"\n\n\n今天终于重现了两年前出现过的`for...in`循环的顺序问题，多谢永胜哥给出的例子。原来是当键值是整数的时候，使用`for...in`循环去遍历一个对象，不同浏览器的顺序是不一样的。\n\nECMA-262标准中有这么一句说明：\n\n> The mechanics and order of enumerating the properties (step 6.a in the first algorithm, step 7.a in the second) is not specified.\n\n关于`for...in`的具体顺序在最新的标准中是没有说明的。这也意味着每一个浏览器都可以有其特定的实现。之前的文章也强调过，**不要依赖`for...in`遍历一个对象的顺序**。为了彻底搞清楚不同浏览器的实现，蛋疼的我写了个测试，代码[参考这里](http://jsfiddle.net/k5DBh/18/)。\n\n比较有规律的IE6的实现，全部都跟定义时的顺序一致。IE7、8、9跟Chrome的最新版本的实现是一样的：\n\n1. a把key中是整数的先抽取出来。注意一定要是整数，像`3a`、`1.1`等不在范围之内哦。\n2. a抽取出来的按数字大小正序排列，放到最前面。\n3. a其他key则按照定义的顺序放到整数key的后面。\n\n有趣的是最新版本的FireFox。当数字比较小的时候，跟Chrome的实现是一致的。当数字比较大的时候，跟IE6的表现是一致的。为了揭示问题的真相，我又蛋疼地写了一段代码，去测试FireFox的边界值，[参考这里](http://jsfiddle.net/9pYL4/4/)。\n\n得出的结论是FireFox把超过1000的数字排除在优先范围之外。所以当key值小于1000的时候是跟Chrome的行为一致，大于的时候跟IE6的行为一致。\n","htmlText":"<p>今天终于重现了两年前出现过的<code>for...in</code>循环的顺序问题，多谢永胜哥给出的例子。原来是当键值是整数的时候，使用<code>for...in</code>循环去遍历一个对象，不同浏览器的顺序是不一样的。</p>\n<p>ECMA-262标准中有这么一句说明：</p>\n<blockquote>\n<p>The mechanics and order of enumerating the properties (step 6.a in the first algorithm, step 7.a in the second) is not specified.</p>\n</blockquote>\n<p>关于<code>for...in</code>的具体顺序在最新的标准中是没有说明的。这也意味着每一个浏览器都可以有其特定的实现。之前的文章也强调过，<strong>不要依赖<code>for...in</code>遍历一个对象的顺序</strong>。为了彻底搞清楚不同浏览器的实现，蛋疼的我写了个测试，代码<a href=\"http://jsfiddle.net/k5DBh/18/\">参考这里</a>。</p>\n<p>比较有规律的IE6的实现，全部都跟定义时的顺序一致。IE7、8、9跟Chrome的最新版本的实现是一样的：</p>\n<ol>\n<li>a把key中是整数的先抽取出来。注意一定要是整数，像<code>3a</code>、<code>1.1</code>等不在范围之内哦。</li>\n<li>a抽取出来的按数字大小正序排列，放到最前面。</li>\n<li>a其他key则按照定义的顺序放到整数key的后面。</li>\n</ol>\n<p>有趣的是最新版本的FireFox。当数字比较小的时候，跟Chrome的实现是一致的。当数字比较大的时候，跟IE6的表现是一致的。为了揭示问题的真相，我又蛋疼地写了一段代码，去测试FireFox的边界值，<a href=\"http://jsfiddle.net/9pYL4/4/\">参考这里</a>。</p>\n<p>得出的结论是FireFox把超过1000的数字排除在优先范围之外。所以当key值小于1000的时候是跟Chrome的行为一致，大于的时候跟IE6的行为一致。</p>\n","summaryMarkdownText":"\n\n\n今天终于重现了两年前出现过的`for...in`循环的顺序问题，多谢永胜哥给出的例子。原来是当键值是整数的时候，使用`for...in`循环去遍历一个对象，不同浏览器的顺序是不一样的。\n\nECMA-262标准中有这么一句说明：\n\n> The mechanics and order of enumerating the properties (step 6.a in the first algorithm, step 7.a in the second) is not specified.\n\n关于`for...in`的具体顺序在最新的标准中是没有说明的。这也意味着每一个浏览器都可以有其特定的实现。之前的文章也强调过，**不要依赖`for...in`遍历一个对象的顺序**。为了彻底搞清楚不同浏览器的实现，蛋疼的我写了个测试，代码[参考这里](http://jsfiddle.net/k5DBh/18/)。\n\n比较有规律的IE6的实现，全部都跟定义时的顺序一致。IE7、8、9跟Chrome的最新版本的实现是一样的：\n\n1. a把key中是整数的先抽取出来。注意一定要是整数，像`3a`、`1.1`等不在范围之内哦。\n2. a抽取出来的按数字大小正序排列，放到最前面。\n3. a其他key则按照定义的顺序放到整数key的后面。\n\n有趣的是最新版本的FireFox。当数字比较小的时候，跟Chrome的实现是一致的。当数字比较大的时候，跟IE6的表现是一致的。为了揭示问题的真相，我又蛋疼地写了一段代码，去测试FireFox的边界值，[参考这里](http://jsfiddle.net/9pYL4/4/)。\n\n得出的结论是FireFox把超过1000的数字排除在优先范围之外。所以当key值小于1000的时候是跟Chrome的行为一致，大于的时候跟IE6的行为一致。\n","summaryHtmlText":"<p>今天终于重现了两年前出现过的<code>for...in</code>循环的顺序问题，多谢永胜哥给出的例子。原来是当键值是整数的时候，使用<code>for...in</code>循环去遍历一个对象，不同浏览器的顺序是不一样的。</p>\n<p>ECMA-262标准中有这么一句说明：</p>\n<blockquote>\n<p>The mechanics and order of enumerating the properties (step 6.a in the first algorithm, step 7.a in the second) is not specified.</p>\n</blockquote>\n<p>关于<code>for...in</code>的具体顺序在最新的标准中是没有说明的。这也意味着每一个浏览器都可以有其特定的实现。之前的文章也强调过，<strong>不要依赖<code>for...in</code>遍历一个对象的顺序</strong>。为了彻底搞清楚不同浏览器的实现，蛋疼的我写了个测试，代码<a href=\"http://jsfiddle.net/k5DBh/18/\">参考这里</a>。</p>\n<p>比较有规律的IE6的实现，全部都跟定义时的顺序一致。IE7、8、9跟Chrome的最新版本的实现是一样的：</p>\n<ol>\n<li>a把key中是整数的先抽取出来。注意一定要是整数，像<code>3a</code>、<code>1.1</code>等不在范围之内哦。</li>\n<li>a抽取出来的按数字大小正序排列，放到最前面。</li>\n<li>a其他key则按照定义的顺序放到整数key的后面。</li>\n</ol>\n<p>有趣的是最新版本的FireFox。当数字比较小的时候，跟Chrome的实现是一致的。当数字比较大的时候，跟IE6的表现是一致的。为了揭示问题的真相，我又蛋疼地写了一段代码，去测试FireFox的边界值，<a href=\"http://jsfiddle.net/9pYL4/4/\">参考这里</a>。</p>\n<p>得出的结论是FireFox把超过1000的数字排除在优先范围之外。所以当key值小于1000的时候是跟Chrome的行为一致，大于的时候跟IE6的行为一致。</p>\n"}