{"year":"2013","month":"12","day":"30","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/12/30/html-form-multipart.html","fileName":"html-form-multipart","layout":"post","title":"HTML Form的enctype","description":"","tags":["html"],"markdownText":"\n\n\n表单的这个特性用来声明这个表单的内容类型。当我们没有显式声明这个特性的值的时候，使用的是其默认值`application/x-www-form-urlencoded`，对表单中的每个控件的值进行URL编码，提交编码之后的字符串。\n\n这种编码方式满足大部分的场景，但是当我们需要传输一些非文本数据（例如文件、二进制数据等），这种方式是低效的。这时候我们需要把表单的`enctype`特性设置成`multipart/form-data`。\n\n设置成这个值之后提交的表单，请求头的`Content-Type`会变成`multipart/form-data`。还需要跟上一个字符串，这个字符串不能存在于每个部分当中。这样表单接收方就可以根据这个字符串正确地分割请求体。分割后的每一个部分对应表单中的一个“控件”，里面包含了这个部分的名字和值。\n\n每一个部分由以下几个部分组成：\n\n1. `Content-Disposition`，固定为`form-data`。\n2. `name`，声明这个部分“控件”的名称，例如一般表单提交的时候就是表单控件对应的`name`特性的值。\n\n例如：\n\n    Content-Disposition: form-data; name=\"mycontrol\"\n\n然后一个回车换行之后就是这个部分对应的值。默认的`Content-Type`是`text/plain`，即是一个文本。当这个部分是一个文件或者二进制数据，需要显式声明这个部分的`Content-Type`，例如：\n\n    Content-Disposition: file; filename=\"file2.gif\"\n    Content-Type: image/gif\n\n这种部分还需要一个额外的头信息，`filename`，声明这个文件或者二进制块的名称，方便表单接收方获取文件的原来的名字。\n\n当表单中的上传文件控件可以上传多个文件（`multiple`）的时候，这个控件的部分的`Content-Type`则会声明成`multipart/mixed`，再跟上一个边界字符串，以分割这个部分里面的每一个文件：\n\n    --AaB03x\n    Content-Disposition: form-data; name=\"files\"\n    Content-Type: multipart/mixed; boundary=BbC04y\n\n    --BbC04y\n    Content-Disposition: file; filename=\"file1.txt\"\n    Content-Type: text/plain\n\n    ... contents of file1.txt ...\n    --BbC04y\n    Content-Disposition: file; filename=\"file2.gif\"\n    Content-Type: image/gif\n    Content-Transfer-Encoding: binary\n\n    ...contents of file2.gif...\n    --BbC04y--\n    --AaB03x--\n\n如果我们是使用HTML表单的提交，那这些编码的工作浏览器其实已经做好了，我们只需要把表单设置好就可以了。但是，现在很多上传的控件都是不需要刷新页面的，类似于Ajax的效果。这时候，有没有可能我们自己构筑这个请求的请求体，然后通过Ajax提交出去呢？明天将继续介绍HTML5的File API，还有`multipart/form-data`的Ajax提交利器`FormData`。\n","htmlText":"<p>表单的这个特性用来声明这个表单的内容类型。当我们没有显式声明这个特性的值的时候，使用的是其默认值<code>application/x-www-form-urlencoded</code>，对表单中的每个控件的值进行URL编码，提交编码之后的字符串。</p>\n<p>这种编码方式满足大部分的场景，但是当我们需要传输一些非文本数据（例如文件、二进制数据等），这种方式是低效的。这时候我们需要把表单的<code>enctype</code>特性设置成<code>multipart/form-data</code>。</p>\n<p>设置成这个值之后提交的表单，请求头的<code>Content-Type</code>会变成<code>multipart/form-data</code>。还需要跟上一个字符串，这个字符串不能存在于每个部分当中。这样表单接收方就可以根据这个字符串正确地分割请求体。分割后的每一个部分对应表单中的一个“控件”，里面包含了这个部分的名字和值。</p>\n<p>每一个部分由以下几个部分组成：</p>\n<ol>\n<li><code>Content-Disposition</code>，固定为<code>form-data</code>。</li>\n<li><code>name</code>，声明这个部分“控件”的名称，例如一般表单提交的时候就是表单控件对应的<code>name</code>特性的值。</li>\n</ol>\n<p>例如：</p>\n<pre><code>Content-Disposition: form-data; name=&quot;mycontrol&quot;\n</code></pre><p>然后一个回车换行之后就是这个部分对应的值。默认的<code>Content-Type</code>是<code>text/plain</code>，即是一个文本。当这个部分是一个文件或者二进制数据，需要显式声明这个部分的<code>Content-Type</code>，例如：</p>\n<pre><code>Content-Disposition: file; filename=&quot;file2.gif&quot;\nContent-Type: image/gif\n</code></pre><p>这种部分还需要一个额外的头信息，<code>filename</code>，声明这个文件或者二进制块的名称，方便表单接收方获取文件的原来的名字。</p>\n<p>当表单中的上传文件控件可以上传多个文件（<code>multiple</code>）的时候，这个控件的部分的<code>Content-Type</code>则会声明成<code>multipart/mixed</code>，再跟上一个边界字符串，以分割这个部分里面的每一个文件：</p>\n<pre><code>--AaB03x\nContent-Disposition: form-data; name=&quot;files&quot;\nContent-Type: multipart/mixed; boundary=BbC04y\n\n--BbC04y\nContent-Disposition: file; filename=&quot;file1.txt&quot;\nContent-Type: text/plain\n\n... contents of file1.txt ...\n--BbC04y\nContent-Disposition: file; filename=&quot;file2.gif&quot;\nContent-Type: image/gif\nContent-Transfer-Encoding: binary\n\n...contents of file2.gif...\n--BbC04y--\n--AaB03x--\n</code></pre><p>如果我们是使用HTML表单的提交，那这些编码的工作浏览器其实已经做好了，我们只需要把表单设置好就可以了。但是，现在很多上传的控件都是不需要刷新页面的，类似于Ajax的效果。这时候，有没有可能我们自己构筑这个请求的请求体，然后通过Ajax提交出去呢？明天将继续介绍HTML5的File API，还有<code>multipart/form-data</code>的Ajax提交利器<code>FormData</code>。</p>\n","summaryMarkdownText":"\n\n\n表单的这个特性用来声明这个表单的内容类型。当我们没有显式声明这个特性的值的时候，使用的是其默认值`application/x-www-form-urlencoded`，对表单中的每个控件的值进行URL编码，提交编码之后的字符串。\n\n这种编码方式满足大部分的场景，但是当我们需要传输一些非文本数据（例如文件、二进制数据等），这种方式是低效的。这时候我们需要把表单的`enctype`特性设置成`multipart/form-data`。\n\n设置成这个值之后提交的表单，请求头的`Content-Type`会变成`multipart/form-data`。还需要跟上一个字符串，这个字符串不能存在于每个部分当中。这样表单接收方就可以根据这个字符串正确地分割请求体。分割后的每一个部分对应表单中的一个“控件”，里面包含了这个部分的名字和值。\n\n每一个部分由以下几个部分组成：\n\n1. `Content-Disposition`，固定为`form-data`。\n2. `name`，声明这个部分“控件”的名称，例如一般表单提交的时候就是表单控件对应的`name`特性的值。\n\n例如：\n\n    Content-Disposition: form-data; name=\"mycontrol\"\n\n然后一个回车换行之后就是这个部分对应的值。默认的`Content-Type`是`text/plain`，即是一个文本。当这个部分是一个文件或者二进制数据，需要显式声明这个部分的`Content-Type`，例如：\n\n    Content-Disposition: file; filename=\"file2.gif\"\n    Content-Type: image/gif\n\n这种部分还需要一个额外的头信息，`filename`，声明这个文件或者二进制块的名称，方便表单接收方获取文件的原来的名字。\n","summaryHtmlText":"<p>表单的这个特性用来声明这个表单的内容类型。当我们没有显式声明这个特性的值的时候，使用的是其默认值<code>application/x-www-form-urlencoded</code>，对表单中的每个控件的值进行URL编码，提交编码之后的字符串。</p>\n<p>这种编码方式满足大部分的场景，但是当我们需要传输一些非文本数据（例如文件、二进制数据等），这种方式是低效的。这时候我们需要把表单的<code>enctype</code>特性设置成<code>multipart/form-data</code>。</p>\n<p>设置成这个值之后提交的表单，请求头的<code>Content-Type</code>会变成<code>multipart/form-data</code>。还需要跟上一个字符串，这个字符串不能存在于每个部分当中。这样表单接收方就可以根据这个字符串正确地分割请求体。分割后的每一个部分对应表单中的一个“控件”，里面包含了这个部分的名字和值。</p>\n<p>每一个部分由以下几个部分组成：</p>\n<ol>\n<li><code>Content-Disposition</code>，固定为<code>form-data</code>。</li>\n<li><code>name</code>，声明这个部分“控件”的名称，例如一般表单提交的时候就是表单控件对应的<code>name</code>特性的值。</li>\n</ol>\n<p>例如：</p>\n<pre><code>Content-Disposition: form-data; name=&quot;mycontrol&quot;\n</code></pre><p>然后一个回车换行之后就是这个部分对应的值。默认的<code>Content-Type</code>是<code>text/plain</code>，即是一个文本。当这个部分是一个文件或者二进制数据，需要显式声明这个部分的<code>Content-Type</code>，例如：</p>\n<pre><code>Content-Disposition: file; filename=&quot;file2.gif&quot;\nContent-Type: image/gif\n</code></pre><p>这种部分还需要一个额外的头信息，<code>filename</code>，声明这个文件或者二进制块的名称，方便表单接收方获取文件的原来的名字。</p>\n"}