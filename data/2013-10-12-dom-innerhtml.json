{"year":"2013","month":"10","day":"12","filePath":"/home/dafeizizhu/workspace/github/dafeizizhu/dafeizizhu.github.com/site/posts/2013/10/12/dom-innerhtml.html","fileName":"dom-innerhtml","layout":"post","title":"DOM的innerHTML属性","description":"","tags":["JavaScript"],"markdownText":"\n\n\n`innerHTML`可以访问一个DOM对象的子孙节点的HTML字符串，也可以设置该DOM元素内部的HTML字符串，浏览器会自动把这些字符串转成DOM结构并塞到该DOM元素内，例如：\n\n    var content = element.innerHTML;\n    element.innerHTML = content;\n\n访问`innerHTML`属性的时候，该元素内部的文本节点如果有`&`、`<`或者`>`，则会转成对应的XML实体，需要注意。\n\n`innerHTML`简化了DOM操作，多层嵌套的DOM结构如果用`document.createElement`等DOM API生成的话需要非常多的代码，而使用`innerHTML`则只需要编写一段HTML字符串即可，简单高效。\n\n`innerHTML`的作用有很多，可以清空一个元素内部的所有DOM节点：\n\n    element.innerHTML = \"\";\n\n也可以查看页面的DOM结构：\n\n    javascript:\"<pre>\"+document.documentElement.innerHTML.replace(/</g,\"&lt;\") + \"</pre>\";\n\n注意哦，由于安全问题，通过`innerHTML`设置的`script`标签是不会被执行的哦。但是，还是可以通过某种手段执行一些代码：\n\n    var name = \"<img src=x onerror=alert(1)>\";\n    el.innerHTML = name; // shows the alert\n\n所以需要用户输入HTML的场景要格外小心，可以使用一些手段去校验用户输入的HTML，例如[XSS Filter](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)等。\n\n`innerHTML`还有一些坑，第一个就是浏览器会自动校正错误格式的HTML字符串，例如：\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/tSH6a/embedded/js,html,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n可以看到`a`标签被补全了。这很多时候都是一个非常棒的事情，但是也有可能导致上述的mXSS攻击校验手段失效，例如：\n\n    // in\n    <img src=\"foo\" alt=\"``onerror=alert(1)\" />\n    // out in IE8 or older\n    <IMG alt=``onerror=alert(1) src=\"x\">\n\n还有很多关于`innerHTML`的攻击方式，有兴趣的童鞋可以[参考这里](http://www.slideshare.net/x00mario/the-innerhtml-apocalypse)（需要翻墙）。\n\n还有一个设置的`innerHTML`，再访问，就算不校正，也有可能不一样。例如上例在IE8或者IE7，`a`标签的标签名变成大写。还有一个更坑的：\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/tSH6a/1/embedded/js,html,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n在IE7里面，`href`被补全成绝对路径了！这样会导致以下的代码失效：\n\n    $(\"a[href='#']\").length;  // in IE7, is 0\n\n太坑爹了！只能把属性选择器改成`a[href$='#']`才能规避这个问题。\n","htmlText":"<p><code>innerHTML</code>可以访问一个DOM对象的子孙节点的HTML字符串，也可以设置该DOM元素内部的HTML字符串，浏览器会自动把这些字符串转成DOM结构并塞到该DOM元素内，例如：</p>\n<pre><code>var content = element.innerHTML;\nelement.innerHTML = content;\n</code></pre><p>访问<code>innerHTML</code>属性的时候，该元素内部的文本节点如果有<code>&amp;</code>、<code>&lt;</code>或者<code>&gt;</code>，则会转成对应的XML实体，需要注意。</p>\n<p><code>innerHTML</code>简化了DOM操作，多层嵌套的DOM结构如果用<code>document.createElement</code>等DOM API生成的话需要非常多的代码，而使用<code>innerHTML</code>则只需要编写一段HTML字符串即可，简单高效。</p>\n<p><code>innerHTML</code>的作用有很多，可以清空一个元素内部的所有DOM节点：</p>\n<pre><code>element.innerHTML = &quot;&quot;;\n</code></pre><p>也可以查看页面的DOM结构：</p>\n<pre><code>javascript:&quot;&lt;pre&gt;&quot;+document.documentElement.innerHTML.replace(/&lt;/g,&quot;&amp;lt;&quot;) + &quot;&lt;/pre&gt;&quot;;\n</code></pre><p>注意哦，由于安全问题，通过<code>innerHTML</code>设置的<code>script</code>标签是不会被执行的哦。但是，还是可以通过某种手段执行一些代码：</p>\n<pre><code>var name = &quot;&lt;img src=x onerror=alert(1)&gt;&quot;;\nel.innerHTML = name; // shows the alert\n</code></pre><p>所以需要用户输入HTML的场景要格外小心，可以使用一些手段去校验用户输入的HTML，例如<a href=\"https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\">XSS Filter</a>等。</p>\n<p><code>innerHTML</code>还有一些坑，第一个就是浏览器会自动校正错误格式的HTML字符串，例如：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/tSH6a/embedded/js,html,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<p>可以看到<code>a</code>标签被补全了。这很多时候都是一个非常棒的事情，但是也有可能导致上述的mXSS攻击校验手段失效，例如：</p>\n<pre><code>// in\n&lt;img src=&quot;foo&quot; alt=&quot;``onerror=alert(1)&quot; /&gt;\n// out in IE8 or older\n&lt;IMG alt=``onerror=alert(1) src=&quot;x&quot;&gt;\n</code></pre><p>还有很多关于<code>innerHTML</code>的攻击方式，有兴趣的童鞋可以<a href=\"http://www.slideshare.net/x00mario/the-innerhtml-apocalypse\">参考这里</a>（需要翻墙）。</p>\n<p>还有一个设置的<code>innerHTML</code>，再访问，就算不校正，也有可能不一样。例如上例在IE8或者IE7，<code>a</code>标签的标签名变成大写。还有一个更坑的：</p>\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/tSH6a/1/embedded/js,html,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n<p>在IE7里面，<code>href</code>被补全成绝对路径了！这样会导致以下的代码失效：</p>\n<pre><code>$(&quot;a[href=&#39;#&#39;]&quot;).length;  // in IE7, is 0\n</code></pre><p>太坑爹了！只能把属性选择器改成<code>a[href$=&#39;#&#39;]</code>才能规避这个问题。</p>\n","summaryMarkdownText":"\n\n\n`innerHTML`可以访问一个DOM对象的子孙节点的HTML字符串，也可以设置该DOM元素内部的HTML字符串，浏览器会自动把这些字符串转成DOM结构并塞到该DOM元素内，例如：\n\n    var content = element.innerHTML;\n    element.innerHTML = content;\n\n访问`innerHTML`属性的时候，该元素内部的文本节点如果有`&`、`<`或者`>`，则会转成对应的XML实体，需要注意。\n\n`innerHTML`简化了DOM操作，多层嵌套的DOM结构如果用`document.createElement`等DOM API生成的话需要非常多的代码，而使用`innerHTML`则只需要编写一段HTML字符串即可，简单高效。\n\n`innerHTML`的作用有很多，可以清空一个元素内部的所有DOM节点：\n\n    element.innerHTML = \"\";\n\n也可以查看页面的DOM结构：\n\n    javascript:\"<pre>\"+document.documentElement.innerHTML.replace(/</g,\"&lt;\") + \"</pre>\";\n\n注意哦，由于安全问题，通过`innerHTML`设置的`script`标签是不会被执行的哦。但是，还是可以通过某种手段执行一些代码：\n\n    var name = \"<img src=x onerror=alert(1)>\";\n    el.innerHTML = name; // shows the alert\n","summaryHtmlText":"<p><code>innerHTML</code>可以访问一个DOM对象的子孙节点的HTML字符串，也可以设置该DOM元素内部的HTML字符串，浏览器会自动把这些字符串转成DOM结构并塞到该DOM元素内，例如：</p>\n<pre><code>var content = element.innerHTML;\nelement.innerHTML = content;\n</code></pre><p>访问<code>innerHTML</code>属性的时候，该元素内部的文本节点如果有<code>&amp;</code>、<code>&lt;</code>或者<code>&gt;</code>，则会转成对应的XML实体，需要注意。</p>\n<p><code>innerHTML</code>简化了DOM操作，多层嵌套的DOM结构如果用<code>document.createElement</code>等DOM API生成的话需要非常多的代码，而使用<code>innerHTML</code>则只需要编写一段HTML字符串即可，简单高效。</p>\n<p><code>innerHTML</code>的作用有很多，可以清空一个元素内部的所有DOM节点：</p>\n<pre><code>element.innerHTML = &quot;&quot;;\n</code></pre><p>也可以查看页面的DOM结构：</p>\n<pre><code>javascript:&quot;&lt;pre&gt;&quot;+document.documentElement.innerHTML.replace(/&lt;/g,&quot;&amp;lt;&quot;) + &quot;&lt;/pre&gt;&quot;;\n</code></pre><p>注意哦，由于安全问题，通过<code>innerHTML</code>设置的<code>script</code>标签是不会被执行的哦。但是，还是可以通过某种手段执行一些代码：</p>\n<pre><code>var name = &quot;&lt;img src=x onerror=alert(1)&gt;&quot;;\nel.innerHTML = name; // shows the alert\n</code></pre>"}