<!DOCTYPE html>
<html>

  <head>
    <title>小麦的二三事 </title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="/common/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/blog.css">
  </head>

  <body>
    <div class="blog-masthead">
      <div class="container">
        <nav class="blog-nav"><a href="/" class="blog-nav-item active">主页</a><a href="/posts" class="blog-nav-item">文章</a><a href="/tags" class="blog-nav-item">标签</a><a href="/projects" class="blog-nav-item">项目</a><a href="/about" class="blog-nav-item">关于</a></nav>
      </div>
    </div>
    <div class="container">
      <div class="blog-header">
        <h1 class="blog-title">小麦的二三事</h1>
        <p class="lead blog-description">他大舅他二舅，都是他舅</p>
      </div>
      <div class="col-sm-8 blog-main">
        <div class="row">
          <div class="blog-post">
            <h2 class="blog-post-title">High Performance JavaScript 读书笔记之 减少Repaint和Reflow的次数</h2>
            <p class="blog-post-meta">写于2013年12月07日 关于<a href="/tags/JavaScript">JavaScript</a></p>
            <p>之前已经讨论过Repaint和Reflow会对性能造成一定的影响，所以我们在进行DOM操作的时候，需要注意的是要把这些操作“集中”到一个地方，然后一次性地应用到页面上面。例如以下的代码：</p> <pre><code>var el = document.getElementById(&#39;mydiv&#39;);
el.style.borderLeft = &#39;1px&#39;;
el.style.borderRight = &#39;2px&#39;;
el.style.padding = &#39;5px&#39;;
</code></pre>
            <p>这里用了3行代码设置DOM的样式。虽然浏览器会对这些操作进行优化，但是最坏的情况下会进行3次Reflow。为了减少Reflow可能发生的次数，这样修改可能比较合适：</p> <pre><code>var el = document.getElementById(&#39;mydiv&#39;);
el.style.cssText = &#39;border-left: 1px; border-right: 2px; padding: 5px;&#39;;
</code></pre>
            <p>虽然这样可以减少Reflow可能发生的次数，但是造成代码的可读性变差。最佳实践是使用<code>class</code>：</p> <pre><code>var el = document.getElementById(&#39;mydiv&#39;);
el.className = &#39;active&#39;;
</code></pre>
            <p>当对样式的修改不依赖于运行时的时候，修改<code>class</code>这种方式最优。</p>
            <p>进行影响几何属性的DOM操作的时候，可以依照下面的步骤去进行，最小化Reflow或者Repaint的次数：</p>
            <ol>
              <li>把DOM从展现树中暂时“抽出去”。</li>
            </ol>
            <p><a href="/posts/2013/12/07/minimizing-repaints-and-reflows.html">阅读全文 &gt;</a></p>
          </div>
          <div class="blog-post">
            <h2 class="blog-post-title">在Flash中发送请求之二：URLLoader</h2>
            <p class="blog-post-meta">写于2013年12月05日 关于<a href="/tags/Flash">Flash</a></p>
            <p>使用<code>URLRequest</code>生成请求的内容之后，我们需要发送这个请求，这时候就需要用到<code>URLLoader</code>这个类。这个类相当于Ajax中的<code>XMLHttpRequest</code>，使用其<code>load</code>方法就可以把请求发送出去。这个类除了可以处理文本之外，还能处理二进制的数据哦，例如文件等。</p>
            <p>这个类有以下几个实例属性：</p>
            <ol>
              <li><code>bytesLoaded</code>，表示加载完毕的字节数。</li>
              <li><code>bytesTotal</code>，表示这个请求完全加载后的字节数。</li>
              <li><code>data</code>，表示接收到的数据。数据类型又<code>dataFormat</code>这个属性决定。</li>
              <li><code>dataFormat</code>，表示接收数据的格式，默认是文本<code>URLLoaderDataFormat.TEXT</code>。可选的值是二进制<code>URLLoaderDataFormat.BINARY</code>和URL编码变量<code>URLLoaderDataFormat.VARIABLES</code>。</li>
            </ol>
            <p>这个类的实例方法很简单，只有两个：</p>
            <ol>
              <li><code>load(request:URLRequest)</code>，发送请求，参数为请求的内容，类似于<code>xhr.send</code>。</li>
              <li><code>close()</code>，取消这次请求，类似于<code>xhr.abort</code>。</li>
            </ol>
            <p><code>load</code>方法是异步的，所以处理这次请求的过程跟Ajax也是十分类似，需要通过绑定事件去监听加载中的每一个过程。调用<code>load</code>之后，会触发以下几个事件：</p>
            <ol>
              <li><code>complete</code>，请求完成，数据可以通过事件对象的<code>target</code>属性中的<code>data</code>属性获取。</li>
              <li><code>httpStatus</code>，如果请求是通过HTTP协议发送的，当接收到HTTP请求的状态码的时候会触发这个事件。状态码通过事件对象的<code>status</code>属性获取。</li>
              <li><code>ioError</code>，请求无法完成的时候触发，具体失败的内容可以通过事件对象的<code>text</code>属性获取。</li>
              <li><code>progress</code>，请求进行中会触发若干遍，通过监听这个事件我们可以做出进度条的效果。根据事件对象的<code>bytesLoaded</code>属性和<code>bytesTotal</code>属性可以知道当前加载完成的百分比。</li>
              <li><code>securityError</code>，加载操作尝试从调用方安全沙箱外部的服务器检索数据时触发。</li>
              <li><code>open</code>，加载开始的时候触发。</li>
            </ol>
            <p><a href="/posts/2013/12/05/as3-urlloader.html">阅读全文 &gt;</a></p>
          </div>
          <div class="blog-post">
            <h2 class="blog-post-title">在Flash中发送请求之一：URLRequest</h2>
            <p class="blog-post-meta">写于2013年12月04日 关于<a href="/tags/Flash">Flash</a></p>
            <p>无论在哪个前端开发的环境中，向后台发送请求获取数据、修改数据都是必须的。在AS3中，可以使用<code>URLRequest</code>配合<code>URLLoader</code>来发送请求。今天先简单看看<code>URLRequest</code>怎么用。</p>
            <p><code>URLRequest</code>像一个包含这次请求的配置、内容等信息的一个类。类似浏览器中的Ajax，这个类的对象包含一些跟HTTP请求有关的参数，例如头、发送的数据、HTTP方法以及请求的URL等。具体有以下几个属性：</p>
            <ol>
              <li><code>contentType</code>，<code>data</code>的MIME类型，默认跟表单一样<code>application/x-www-form-urlencoded</code>。</li>
              <li><code>data</code>，跟随请求一起发送到服务端的数据。</li>
              <li><code>followRedirects</code>，是否遵循重定向。</li>
              <li><code>method</code>，HTTP方法。</li>
              <li><code>requestHeaders</code>，请求头，是一个包含<code>URLRequestHeader</code>实例的数组。</li>
              <li><code>url</code>，请求的URL。</li>
              <li><code>userAgent</code>，标识用户代理的字符串，类似于浏览器的<code>window.navigator.usrAgent</code>。</li>
            </ol>
            <p>大部分参数都是字符串。<code>data</code>是一个对象，默认会按照表单形式进行编码：</p> <pre><code>key1=value1&amp;key2=value2
</code></pre>
            <p>其中<code>URLRequestHeader</code>的实例其实就是一个键值对：</p> <pre><code>var urlRequestHeader:URLRequestHeader = 
  new URLRequestHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);
</code></pre>
            <p>然后这么加到<code>URLRequest</code>中：</p>
            <p><a href="/posts/2013/12/04/as3-urlrequest.html">阅读全文 &gt;</a></p>
          </div>
          <div class="blog-post">
            <h2 class="blog-post-title">使用flashvars传递参数</h2>
            <p class="blog-post-meta">写于2013年12月03日 关于<a href="/tags/Flash">Flash</a></p>
            <p>我们可以使用可选的<code>name</code>为<code>flashvars</code>的参数传递参数到Flash影片中。这些参数在Flash影片播放第一帧之前传递到Flash影片之中。</p>
            <p>这个参数是一个字符串，只有一个长度限制，就是最多只能传64KB的数据。</p>
            <p>格式跟URL的查询串十分类似，也是<code>key=value&amp;key=value</code>这样的格式，也可以使用<code>encodeURIComponent</code>和<code>decodeURIComponent</code>对里面的值进行编码和解码。</p>
            <p>在<code>object</code>标签里面是这么使用：</p> <pre><code>&lt;object&gt;
  &lt;param name=FlashVars value=&quot;myVariable=Hello%20World&amp;mySecondVariable=Goodbye&quot; /&gt;
&lt;/object&gt;
</code></pre>
            <p>在<code>embed</code>标签里面是这么使用：</p> <pre><code>&lt;embed FlashVars=&quot;myVariable=Hello%20World&amp;mySecondVariable=Goodbye&quot; /&gt;
</code></pre>
            <p>然后我们就可以在AS里面获取这些参数了。在AS3中，可以通过<code>this.loaderInfo.parameters</code>获取这些参数：</p> <pre><code>var params:Object = this.loaderInfo.parameters;
trace(params.myVariable); // Hello World
trace(params.mySecondVariable); // Goodbye
</code></pre>
            <p><a href="/posts/2013/12/03/flashvars.html">阅读全文 &gt;</a></p>
          </div>
          <div class="blog-post">
            <h2 class="blog-post-title">给Flash影片传参数</h2>
            <p class="blog-post-meta">写于2013年12月02日 关于<a href="/tags/Flash">Flash</a>,<a href="/tags/html">html</a></p>
            <p>在页面中插入Flash影片有两个标签都可以用，一个是<code>object</code>，一个是<code>embed</code>。无论使用那个标签，我们都需要传入一些参数给Flash影片，今天来看看有什么参数可以设置。</p>
            <p>首先是必要的参数，<code>width</code>和<code>height</code>这两个属性无论使用哪个标签都必须设置的：</p> <pre><code>&lt;object width=&quot;500&quot; height=&quot;400&quot;&gt;&lt;/object&gt;
</code></pre>
            <p>如果使用的是<code>object</code>，则还需要以下几个参数：</p>
            <ol>
              <li><code>classid</code>，为浏览器指定ActiveX控件，一般都是<code>D27CDB6E-AE6D-11cf-96B8-444553540000</code>。</li>
              <li><code>codebase</code>，如果浏览器没有安装指定的控件，则可以通过这个特性的值去下载指定的控件，例如<code>codebase=&quot;downloader.cab#version=1,0,0,0&quot;</code>。</li>
              <li><code>movie</code>，这个是<code>object</code>内部的一个<code>param</code>标签的<code>name</code>，指定Flash影片的地址：<code>&lt;param name=&quot;movie&quot; value=&quot;path/to/swf&quot; /&gt;</code>。</li>
            </ol>
            <p>如果使用的是<code>embed</code>，内部不会有<code>param</code>标签，所有参数都是以特性写在<code>embed</code>标签里面。使用<code>embed</code>标签的时候还需要以下几个参数：</p>
            <ol>
              <li><code>src</code>，同以上的<code>movie</code>。</li>
              <li><code>pluginspage</code>，同以上的<code>codebase</code>。</li>
            </ol>
            <p>以下是可选的参数，使用<code>object</code>的时候使用<code>param</code>标签在内部声明值，使用<code>embed</code>则直接以特性写在<code>embed</code>里面：</p>
            <ol>
              <li><code>play</code>，表示是否在影片加载完成之后自动播放，默认是<code>true</code>。</li>
              <li><code>loop</code>，表示影片是否循环播放，默认是<code>true</code>。</li>
              <li><code>menu</code>，表示是否在上下文菜单显示播放控件。</li>
            </ol>
            <p><a href="/posts/2013/12/02/flash-params.html">阅读全文 &gt;</a></p>
          </div>
          <div class="blog-post">
            <h2 class="blog-post-title">High Performance JavaScript 读书笔记之 Repaints和Reflow</h2>
            <p class="blog-post-meta">写于2013年12月01日 关于<a href="/tags/JavaScript">JavaScript</a></p>
            <p>当浏览器下载完所有HTML标签、脚本、样式、图片，它会创建两种数据结构：DOM树和展现树。DOM树中不可见的节点在展现树上是没有对应节点的。展现数上的节点通常被称为<code>frames</code>或者<code>boxes</code>，浏览器会把这些节点当成一个个”盒子“来处理（包括<code>padding</code>、<code>margin</code>、<code>border</code>和<code>position</code>）。当展现树构造完成之后，浏览器就可以把整个页面”画“出来了。</p>
            <p>当页面的元素发生几何变化时（例如高度、宽度变化，或者<code>padding</code>、<code>margin</code>、<code>border</code>变化等），浏览器需要重新计算页面上其他元素的几何位置。这个过程就是<code>reflow</code>。当<code>reflow</code>发生的时候，浏览器需要重绘所有受影响的元素，这个过程是一个<code>repaint</code>。</p>
            <p>不是更改所有HTML元素都会出发<code>reflow</code>，例如改变一个元素的背景色，是不会改变这个元素的几何属性的。这种情况下，只会发生<code>repaint</code>。</p>
            <p>不管是<code>reflow</code>还是<code>repaint</code>，都会有比较高昂的性能损耗。所以，减少<code>reflow</code>和<code>repaint</code>的次数对性能是十分重要的。</p>
            <p>什么时候会发生<code>reflow</code>：</p>
            <ol>
              <li>增加或者移除可视的DOM元素。</li>
              <li>元素的位置发生改变。</li>
              <li>元素的大小发生变化，包括<code>padding</code>、<code>margin</code>等。</li>
              <li>元素内容发生变化，当元素是自适应内容的情况下（<code>height</code>为<code>auto</code>等）。</li>
              <li>页面初始化的时候。</li>
              <li>浏览器<code>resize</code>的时候。</li>
            </ol>
            <p>通常浏览器会有一个队列缓冲对展现树的改变，在适当的时候一次性<code>reflow</code>或者<code>repaint</code>。但是，使用到DOM上的某些属性会导致队列被刷新，立刻执行<code>reflow</code>或者<code>repaint</code>：</p>
            <ol>
              <li>使用<code>offsetTop</code>等<code>offsetXxx</code>属性。</li>
              <li>使用<code>scrollTop</code>等<code>scrollXxx</code>属性。</li>
              <li>使用<code>clientTop</code>等<code>clientXxx</code>属性。</li>
            </ol>
            <p><a href="/posts/2013/12/01/hp-repaints-and-reflows.html">阅读全文 &gt;</a></p>
          </div>
          <div class="blog-post">
            <h2 class="blog-post-title">High Performance JavaScript 读书笔记之 遍历DOM</h2>
            <p class="blog-post-meta">写于2013年11月30日 关于<a href="/tags/JavaScript">JavaScript</a></p>
            <p>DOM提供了多种方式供我们去遍历整个文档。虽然使用哪种方式都可以达到目的，但是有些时候还是需要选出一个效率最高的方式去达到某些性能基线。</p>
            <p>我们可以使用<code>childNodes</code>去访问一个DOM的所以子元素，这样就可以递归地遍历整个文档中的DOM，下面是一个使用<code>childNodes</code>的例子：</p> <pre><code>function testChildNodes() {
  var el = document.getElementById(&#39;mydiv&#39;),
      ch = el.childNodes,
      len = ch.length,
      name = &#39;&#39;;
  for (var count = 0; count &lt; len; count++) {
    name = ch[count].nodeName;
  }
  return name;
};
</code></pre>
            <p>我们也可以使用<code>nextSibling</code>去访问一个DOM的邻接节点，这样也可以遍历整个文档中的DOM：</p> <pre><code>function testNextSibling() {
  var el = document.getElementById(&#39;mydiv&#39;),
      ch = el.firstChild,
      name = &#39;&#39;;
  do {
</code></pre>
            <p><a href="/posts/2013/11/30/hp-walking-the-dom.html">阅读全文 &gt;</a></p>
          </div>
          <div class="blog-post">
            <h2 class="blog-post-title">使用JavaScript在页面中嵌入Flash</h2>
            <p class="blog-post-meta">写于2013年11月26日 关于<a href="/tags/JavaScript">JavaScript</a>,<a href="/tags/Flash">Flash</a></p>
            <p>今天讨论的是使用<code>swfobject</code>在页面中嵌入一个Flash影片。对于不熟悉Flash的前端来说，<code>swfobject</code>提供了完整的JavaScript API来插入Flash影片，封装了很多内部的实现细节。使用<code>swfobject</code>还能做一些例如版本检测、提示下载Flash Player等操作。</p>
            <p>这个库的使用方法很简单，首先肯定是在页面中引入这个库的脚本文件：</p> <pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;swfobject.js&quot;&gt;&lt;/script&gt;
</code></pre>
            <p>HTML片段：</p> <pre><code>&lt;div id=&quot;myContent&quot;&gt;
  &lt;p&gt;Alternative content&lt;/p&gt;
&lt;/div&gt;
</code></pre>
            <p>假设我们需要在<code>#myContent</code>中插入一个Flash影片，只需要调用<code>swfobject.embedSWF</code>就可以了，这个方法接受如下几个参数：</p>
            <ol>
              <li><code>swfUrl</code>，影片的地址。</li>
              <li><code>id</code>，影片容器的ID，如上例的<code>myContent</code>。</li>
              <li><code>width</code>，影片的宽度。</li>
              <li><code>height</code>，影片的高度。</li>
              <li><code>version</code>，目标Flash Player的版本。</li>
              <li><code>expressInstallSwfurl</code>，可选，利用这个flash跳转到官方下载最新版本的flash插件。</li>
              <li><code>flashvars</code>，可选，一个JavaScript对象，传递给Flash影片的变量。</li>
              <li><code>params</code>，可选，<code>object</code>内部的<code>param</code>标签。</li>
            </ol>
            <p><a href="/posts/2013/11/26/javascript-swfobject.html">阅读全文 &gt;</a></p>
          </div>
          <div class="blog-post">
            <h2 class="blog-post-title">Script标签上的onload和onreadystatechange</h2>
            <p class="blog-post-meta">写于2013年11月25日 关于<a href="/tags/JavaScript">JavaScript</a></p>
            <p>之前做一个效果，涉及到动态加载脚本的问题。这个效果需要做成本地文件直接打开可以看到效果，所以下面的代码在Chrome是会报错的：</p> <pre><code>$.getScript(&quot;./js/dynamic.js&quot;, function () {...});
</code></pre>
            <p>由于本地文件使用的是<code>file</code>协议，而<code>$.getScript</code>在这个情况下是使用Ajax去请求脚本的内容，Chrome在使用<code>file</code>协议的页面进行Ajax请求时会抛出跨域访问的异常。所以只能用动态插入<code>script</code>标签的方式去实现：</p> <pre><code>var done = false;
var head = document.getElementsByTagName(&quot;head&quot;)[0];
var s = document.createElement(&quot;script&quot;);
s.type = &quot;text/javascript&quot;;
s.onload = s.onreadystatechange = function (evt) {
  if (!done &amp;&amp; (!this.readyState || 
    this.readyState == &quot;loaded&quot; ||
    this.readyState == &quot;complete&quot;)) {
    // do something with the script
    s.onload = s.onreadystatechange = null;
    head.removeChild(s);
  }
}
s.src = &quot;path/to/script.js&quot;;
head.appendChild(s);
</code></pre>
            <p><a href="/posts/2013/11/25/onload-vs-onreadystatechange.html">阅读全文 &gt;</a></p>
          </div>
          <div class="blog-post">
            <h2 class="blog-post-title">High Performance JavaScript 读书笔记之 访问和修改DOM（二）</h2>
            <p class="blog-post-meta">写于2013年11月24日 关于<a href="/tags/JavaScript">JavaScript</a></p>
            <p>今天讨论一下<code>HTMLCollection</code>。<code>HTMLCollection</code>是一个类似数组的东西，里面包含了一组DOM对象。下面的API返回的结果都是一个<code>HTMLCollection</code>：</p>
            <ol>
              <li><code>document.getElementsByName</code>。</li>
              <li><code>document.getElementsByClassName</code>。</li>
              <li><code>document.getElementsByTagName</code>。</li>
            </ol>
            <p>而下面的这些<code>document</code>的属性也会返回一个<code>HTMLCollection</code>：</p>
            <ol>
              <li><code>document.images</code>，返回文档中所有<code>img</code>。</li>
              <li><code>document.links</code>，返回文档中所有带<code>href</code>特性的<code>a</code>。</li>
              <li><code>document.forms</code>，返回文档中所有<code>form</code>。</li>
              <li><code>document.forms[0].elements</code>，返回第一个表单中的所有表单域。</li>
            </ol>
            <p><code>HTMLCollection</code>不是数组，所以它没有<code>push</code>或者<code>slice</code>等方法。但是它有<code>length</code>属性，也可以通过下标访问，所以它是一个“类数组”。值得注意的是，<code>HTMLCollection</code>是“活”的，即在访问这个集合的时候，该集合的状态是当前文档的状态。例如这样的代码可能会进入一个死循环：</p> <pre><code>var alldivs = document.getElementsByTagName(&quot;div&quot;);
for (var i = 0; i &lt; alldivs.length; i++) {
  document.body.appendChild(
    document.createElement(&quot;div&quot;));
}
</code></pre>
            <p>由于在循环中不断加入<code>div</code>，导致<code>alldiv.length</code>不断被增大，退出条件永远都不会成立。</p>
            <p><a href="/posts/2013/11/24/hp-html-collections.html">阅读全文 &gt;</a></p>
          </div>
        </div>
      </div>
      <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
        <div class="sidebar-module">
          <h4>文章</h4>
          <ol class="list-unstyled">
            <li><a href="/posts/2014/02">2014年02月</a></li>
            <li><a href="/posts/2014/01">2014年01月</a></li>
            <li><a href="/posts/2013/12">2013年12月</a></li>
            <li><a href="/posts/2013/11">2013年11月</a></li>
            <li><a href="/posts/2013/10">2013年10月</a></li>
            <li><a href="/posts/2013/09">2013年09月</a></li>
            <li><a href="/posts/2013/08">2013年08月</a></li>
            <li><a href="/posts/2013/07">2013年07月</a></li>
            <li><a href="/posts/2013/01">2013年01月</a></li>
            <li><a href="/posts/2012/12">2012年12月</a></li>
          </ol>
        </div>
        <div class="sidebar-module">
          <h4>标签</h4>
          <ol class="list-unstyled">
            <li><a href="/tags/notes">notes(5)</a></li>
            <li><a href="/tags/css">css(23)</a></li>
            <li><a href="/tags/html">html(10)</a></li>
            <li><a href="/tags/JavaScript">JavaScript(106)</a></li>
            <li><a href="/tags/前端">前端(9)</a></li>
            <li><a href="/tags/jQuery">jQuery(29)</a></li>
            <li><a href="/tags/http">http(4)</a></li>
            <li><a href="/tags/node">node(3)</a></li>
            <li><a href="/tags/html5">html5(7)</a></li>
            <li><a href="/tags/Flash">Flash(30)</a></li>
          </ol>
        </div>
      </div>
    </div>
    <div class="container">
      <nav class="pagination">
        <li><a href="/index/2.html" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a></li>
        <li><a href="/index.html">1</a></li>
        <li><a href="/index/1.html">2</a></li>
        <li><a href="/index/2.html">3</a></li>
        <li class="active"><a href="/index/3.html">4</a></li>
        <li><a href="/index/4.html">5</a></li>
        <li><a href="/index/5.html">6</a></li>
        <li><a href="/index/6.html">7</a></li>
        <li><a href="/index/7.html">8</a></li>
        <li><a href="/index/8.html">9</a></li>
        <li><a href="/index/9.html">10</a></li>
        <li><a href="/index/10.html">11</a></li>
        <li><a href="/index/11.html">12</a></li>
        <li><a href="/index/12.html">13</a></li>
        <li><a href="/index/13.html">14</a></li>
        <li><a href="/index/14.html">15</a></li>
        <li><a href="/index/15.html">16</a></li>
        <li><a href="/index/16.html">17</a></li>
        <li><a href="/index/17.html">18</a></li>
        <li><a href="/index/18.html">19</a></li>
        <li><a href="/index/4.html" aria-label="Next"><span aria-hidden="true">&raquo;</span></a></li>
      </nav>
    </div>
    <footer class="blog-footer">
      <p>Powerby MaiZhiying</p>
    </footer>
  </body>

</html>